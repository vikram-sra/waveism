<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="icons/icon-180.png">
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncertainty | Quantum Limits</title>
    <link rel="stylesheet" href="components/shared.css">
    <script src="components/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: transparent;
        }

        .theory-tab.uncertainty-tab {
            color: #ff00ff;
        }

        .theory-tab.uncertainty-tab.active {
            background: rgba(255, 0, 255, 0.1);
            color: #ff00ff;
            box-shadow: inset 0 0 15px rgba(255, 0, 255, 0.2);
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="three-container"></div>



    <div id="nav-container"></div>

    <div class="theory-nav-header">
        <div class="theory-nav-title">EXPLORE MODES</div>
        <div class="theory-nav-desc">Choose a simulation mode below to change the visualization</div>
    </div>
    <div class="theory-tabs">
        <button class="theory-tab uncertainty-tab active" data-theory="uncertainty">Heisenberg Limit (Δx Δp)</button>
        <button class="theory-tab" data-theory="measurement">Wave-Packet Collapse</button>
        <button class="theory-tab" data-theory="momentum">Wigner Phase Space</button>
        <button class="theory-tab" data-theory="foam">Planck Topology Flux</button>
    </div>

    <div class="params-panel">
        <div class="param-group">
            <div class="param-label" id="param1-label">Precision (Δp)</div>
            <div class="param-value" id="param1-value">5.0Δp</div>
            <input type="range" class="param-slider" id="param1-slider" min="1" max="150" value="50">
        </div>
        <div class="param-group">
            <div class="param-label">Simulation Rate</div>
            <div class="param-value" id="speed-value">1.0×</div>
            <input type="range" class="param-slider" id="speed-slider" min="0" max="300" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Phase Zoom</div>
            <div class="param-value" id="zoom-value">1.0×</div>
            <input type="range" class="param-slider" id="zoom-slider" min="30" max="400" value="100">
        </div>
    </div>

    <div class="info-panel">
        <div class="theory-name" id="theory-name">Heisenberg Uncertainty</div>
        <div class="theory-year" id="theory-year">Werner Heisenberg, 1927</div>
        <div class="equation-box">
            <div class="equation-label">The Invariant Bound</div>
            <div class="equation" id="equation">Δx Δp ≥ ℏ/2</div>
        </div>
        <div class="theory-facts" id="theory-facts"></div>
    </div>

    <button class="info-btn" id="info-btn">ⓘ</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header">
            <span class="info-modal-title">Quantum Observational Protocol</span>
            <button class="info-modal-close" id="info-close">×</button>
        </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Epistemic Description</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Quantum Operators</div>
                <ul id="info-concepts"></ul>
            </div>
            <div class="info-section">
                <div class="info-section-title">Mathematical Backbone</div>
                <p id="info-equation-explanation"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Waveism Interconnect</div>
                <p id="info-physics"></p>
            </div>
        </div>
    </div>

    <script>
        document.getElementById('nav-container').innerHTML = renderMainNav('uncertainty');

        let scene, camera, renderer, currentMode = 'uncertainty';
        let activeGroup;
        let p1 = 50, timeScale = 1.0, time = 0;
        let smoothedZoom = 1.0;

        const theories = {
            'uncertainty': {
                name: 'Heisenberg Squeezed State', year: 'Conjugate Variables',
                equation: 'Δx Δp ≥ ℏ/2',
                equationExpl: 'The Heisenberg Uncertainty Principle. It states that the product of the uncertainties in position (Δx) and momentum (Δp) is bounded by a fundamental constant (ℏ/2).',
                facts: [{ text: 'Fourier Limit', status: 'yes' }, { text: 'Incompressible', status: 'yes' }],
                description: 'The fundamental trade-off of the universe. If you squeeze the momentum (Δp) of a wave-packet, its spatial extent (Δx) must leak and spread. Position and momentum are Fourier transforms of each other; high precision in one domain guarantees "fuzziness" in the other.',
                concepts: [
                    { term: 'Squeezed State', definition: 'A quantum state where uncertainty in one variable is reduced below the symmetric limit at the cost of the other.' },
                    { term: 'Minimal Packet', definition: 'The Gaussian wave-packet which satisfies the equality ΔxΔp = ℏ/2.' }
                ],
                physics: 'In Waveism, uncertainty is the "Tiling of the Vacuum". The substrate has a finite bandwidth. You can resolve a high-frequency (momentum) signal or a localized (position) pulse, but the total area in Phase Space remains constant.'
            },
            'measurement': {
                name: 'The Measurement Crunch', year: 'State Reduction',
                equation: 'ψ → |x₀⟩',
                equationExpl: 'Wave-function collapse. The broad superposition (ψ) is reduced to a single position eigenstate (|x₀⟩) upon interaction with an observer.',
                facts: [{ text: 'Decoherence', status: 'active' }, { text: 'Information Heat', status: 'high' }],
                description: 'A "Measurement" is an energetic interaction that forces a fuzzy superposition to resolve into a single eigenvalue. This is not a passive observation, but a violent synchronization of the system with the macroscopic environment.',
                concepts: [
                    { term: 'Decoherence', definition: 'The leakage of quantum phase information into the environment.' },
                    { term: 'Eigenvalue Reduction', definition: 'The moment the wave-function maps to a discrete observable result.' }
                ],
                physics: 'Waveism views collapse as "Node Selection". The broad interference field is localized by a high-energy hit, forcing the wave-packet to snap to a single spatial grid-point.'
            },
            'momentum': {
                name: 'Wigner Quasi-Probability', year: 'Phase Space Topology',
                equation: 'W(x,p) = ∫ ψ*(x-y)ψ(x+y) e^{i2py} dy',
                equationExpl: 'The Wigner quasi-probability distribution. It provides a phase space representation of quantum states, where negative values signify non-classical interference.',
                facts: [{ text: 'Negative Prob.', status: 'yes' }, { text: 'interference', status: 'yes' }],
                description: 'Visualizing quantum states in Phase Space. Unlike classical probability, the Wigner distribution can have negative values—represented by troughs—which signify pure quantum interference that has no classical equivalent.',
                concepts: [
                    { term: 'Phasor Field', definition: 'The rotational representation of wave-functions in complex space.' },
                    { term: 'Quantum Troughs', definition: 'Negative regions of the Wigner function indicating non-classical behavior.' }
                ],
                physics: 'Phase Space is the "Substrate Map". It shows the underlying density of wave-action. Large peaks indicate classical presence, while troughs indicate purely resonant interference patterns.'
            },
            'foam': {
                name: 'Planck Topology Flux', year: 'Spacetime Jitter',
                equation: 'l_P = √(ℏG/c³)',
                equationExpl: 'The Planck length. It is the fundamental scale where spacetime is no longer a smooth manifold but is composed of violent, fluctuating virtual wormholes.',
                facts: [{ text: 'Geometric Chaos', status: 'high' }, { text: 'Non-Metric', status: 'yes' }],
                description: 'At the Planck Scale, the smooth fabric of spacetime dissolves. Reality becomes a violent, boiling ocean of virtual wormholes and topological fluctuations. There is no "distance" or "time" here, only the raw flux of the substrate.',
                concepts: [
                    { term: 'Quantum Foam', definition: 'The boiling nature of the vacuum at the smallest possible scales.' },
                    { term: 'Metric Discontinuity', definition: 'The breakdown of traditional calculus-based geometry.' }
                ],
                physics: 'The Foam is the vacuum\'s "Noise Floor". It is the broadband, high-entropy background radiation of the Wave-Field before it organizes into coherent particles.'
            }
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('three-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xff00ff, 1, 500);
            pointLight.position.set(100, 100, 100);
            scene.add(pointLight);

            createStarField(scene); // Add 3D Starfield

            initParamSlider('param1-slider', 'param1-value', {
                onChange: v => { p1 = v; updateParamDisplay(); },
                formatter: v => (v / 10).toFixed(1) + 'Δp'
            });
            initParamSlider('speed-slider', 'speed-value', {
                onChange: v => timeScale = v / 100,
                formatter: v => (v / 100).toFixed(1) + '×'
            });
            initParamSlider('zoom-slider', 'zoom-value', {
                onChange: v => { if (window.zoomControl) window.zoomControl.zoom = v / 100; },
                formatter: v => (v / 100).toFixed(1) + '×'
            });

            const drag = initDragRotation(renderer.domElement, { initialRotationX: 0.2 });
            window.globalDrag = drag;
            const zoomControl = initZoomHandler(renderer.domElement, { initialZoom: 1.0 });
            window.zoomControl = zoomControl;

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (window.clickPrevented) { window.clickPrevented = false; return; }
                drag.autoRotate = !drag.autoRotate;
            });

            initTheoryTabs(mode => switchMode(mode));
            initInfoModal();
            switchMode('uncertainty');
            animate(drag, zoomControl);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateParamDisplay() {
            const valEl = document.getElementById('param1-value');
            if (currentMode === 'uncertainty') valEl.innerText = "Δp: " + (p1 / 10).toFixed(1);
            else if (currentMode === 'measurement') valEl.innerText = "Coupling: " + (p1).toFixed(0) + "%";
            else if (currentMode === 'momentum') valEl.innerText = "Res: " + (p1).toFixed(0);
            else if (currentMode === 'foam') valEl.innerText = "Energy: " + (p1).toFixed(0) + " GeV";
        }

        function switchMode(mode) {
            currentMode = mode;
            scene.children.forEach(c => { if (c.type === "Group") scene.remove(c); });

            activeGroup = new THREE.Group();
            activeGroup.position.y = 10;

            if (mode === 'uncertainty') {
                document.getElementById('param1-label').innerText = "Momentum Precision (Δp)";
                const count = 3000;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ color: 0xff00ff, size: 2, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
                const cloud = new THREE.Points(geo, mat);
                cloud.name = "uncertainty_cloud";
                activeGroup.add(cloud);

                const ringGeo = new THREE.TorusGeometry(60, 0.5, 16, 100);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                activeGroup.add(ring);

            } else if (mode === 'measurement') {
                document.getElementById('param1-label').innerText = "Interaction Strength";
                const count = 8000;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    const r = 100 + Math.random() * 20;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    pos[i * 3 + 2] = r * Math.cos(phi);
                    colors[i * 3] = 1; colors[i * 3 + 1] = 0; colors[i * 3 + 2] = 1;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
                const collapseCloud = new THREE.Points(geo, mat);
                collapseCloud.name = "collapse_cloud";
                activeGroup.add(collapseCloud);

                const core = new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                core.name = "collapse_core";
                activeGroup.add(core);

            } else if (mode === 'momentum') {
                document.getElementById('param1-label').innerText = "Interference Res";
                const size = 150;
                const res = 100;
                const geo = new THREE.PlaneGeometry(size, size, res, res);
                const mat = new THREE.MeshPhongMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                const wigner = new THREE.Mesh(geo, mat);
                wigner.rotation.x = -Math.PI / 2;
                wigner.name = "wigner_mesh";
                activeGroup.add(wigner);

                const grid = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
                grid.position.y = -20;
                activeGroup.add(grid);

            } else if (mode === 'foam') {
                document.getElementById('param1-label').innerText = "Energy Density (Flux)";
                const size = 200;
                const res = 60;
                const geo = new THREE.PlaneGeometry(size, size, res, res);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x220033,
                    emissive: 0xff00cc,
                    emissiveIntensity: 0.2,
                    wireframe: true,
                    roughness: 0.1,
                    metalness: 0.8
                });
                const foam = new THREE.Mesh(geo, mat);
                foam.rotation.x = -Math.PI / 2;
                foam.name = "foam_mesh";
                activeGroup.add(foam);
            }

            if (window.globalDrag) {
                activeGroup.rotation.y = window.globalDrag.rotationY;
                activeGroup.rotation.x = window.globalDrag.rotationX;
            }

            scene.add(activeGroup);
            updateTheoryHeader(theories[mode].name, theories[mode].description);
            updateInfoPanel(theories[mode]);
            updateInfoModalContent(theories[mode]);
            updateParamDisplay();
        }

        function updateSim() {
            const dt = 0.01 * timeScale;
            time += dt;

            if (currentMode === 'uncertainty') {
                const cloud = activeGroup.getObjectByName("uncertainty_cloud");
                if (cloud) {
                    const pos = cloud.geometry.attributes.position.array;
                    const dp = Math.max(0.1, p1 / 10);
                    const dx = 100 / dp;

                    for (let i = 0; i < pos.length; i += 3) {
                        const jitter = 0.5;
                        pos[i] += (Math.random() - 0.5) * jitter;
                        pos[i + 1] += (Math.random() - 0.5) * jitter;
                        pos[i + 2] += (Math.random() - 0.5) * jitter;

                        const distSq = pos[i] * pos[i] + pos[i + 1] * pos[i + 1] + pos[i + 2] * pos[i + 2];
                        if (distSq > dx * dx * 16) {
                            pos[i] = (Math.random() - 0.5) * dx * 2;
                            pos[i + 1] = (Math.random() - 0.5) * dx * 2;
                            pos[i + 2] = (Math.random() - 0.5) * dx * 2;
                        }
                    }
                    cloud.geometry.attributes.position.needsUpdate = true;
                    cloud.rotation.y += dt * 0.2;
                }
            } else if (currentMode === 'measurement') {
                const cloud = activeGroup.getObjectByName("collapse_cloud");
                const core = activeGroup.getObjectByName("collapse_core");
                const strength = p1 / 150;
                const decoEl = document.getElementById('decoherence-status');

                if (cloud) {
                    const pos = cloud.geometry.attributes.position.array;
                    const baseRadius = 120 * (1 - strength);
                    for (let i = 0; i < pos.length; i += 3) {
                        const x = pos[i], y = pos[i + 1], z = pos[i + 2];
                        const r = Math.sqrt(x * x + y * y + z * z);
                        const f = dt * strength * 10;
                        pos[i] *= (1 - f);
                        pos[i + 1] *= (1 - f);
                        pos[i + 2] *= (1 - f);

                        if (r < 5) {
                            const th = Math.random() * Math.PI * 2;
                            const ph = Math.random() * Math.PI;
                            pos[i] = 120 * Math.sin(ph) * Math.cos(th);
                            pos[i + 1] = 120 * Math.sin(ph) * Math.sin(th);
                            pos[i + 2] = 120 * Math.cos(ph);
                        }
                    }
                    cloud.geometry.attributes.position.needsUpdate = true;
                    cloud.rotation.y += dt;
                }
                if (core) {
                    core.scale.setScalar(0.5 + strength * 4);
                }
                if (decoEl) {
                    decoEl.innerText = strength > 0.8 ? "LOCALIZED" : (strength > 0.2 ? "DECOHERING" : "COHERENT");
                    decoEl.style.color = strength > 0.8 ? "#ffffff" : "#ff00ff";
                }
            } else if (currentMode === 'momentum') {
                const mesh = activeGroup.getObjectByName("wigner_mesh");
                if (mesh) {
                    const pos = mesh.geometry.attributes.position;
                    const freq = p1 / 50;
                    for (let i = 0; i < pos.count; i++) {
                        const x = pos.getX(i) * 0.1;
                        const y = pos.getY(i) * 0.1;
                        const rSq = x * x + y * y;
                        const envelope = Math.exp(-rSq * 0.5);
                        const interference = Math.cos(rSq * 4 * freq - time * 5);
                        const h = envelope * interference * 40;
                        pos.setZ(i, h);
                    }
                    pos.needsUpdate = true;
                }
            } else if (currentMode === 'foam') {
                const mesh = activeGroup.getObjectByName("foam_mesh");
                if (mesh) {
                    const pos = mesh.geometry.attributes.position;
                    const flux = p1 / 50;
                    for (let i = 0; i < pos.count; i++) {
                        const x = pos.getX(i);
                        const y = pos.getY(i);
                        const h = (Math.sin(x * 0.2 + time * 5) * Math.cos(y * 0.2 + time * 3)) * 10
                            + (Math.sin(x * 0.5 - time * 8) * Math.sin(y * 0.4 + time * 6)) * 5 * flux;
                        pos.setZ(i, h);
                    }
                    pos.needsUpdate = true;
                }
            }
        }

        function animate(drag, zoomControl) {
            requestAnimationFrame(() => animate(drag, zoomControl));
            updateSim();

            const stars = scene.getObjectByName("global_starfield");
            updateStarField(stars, time, drag);

            const targetZoom = zoomControl.zoom;
            smoothedZoom += (targetZoom - smoothedZoom) * 0.1;
            camera.position.z = 300 / smoothedZoom;

            const zSlider = document.getElementById('zoom-slider');
            if (zSlider && !zSlider.matches(':active')) zSlider.value = smoothedZoom * 100;
            document.getElementById('zoom-value').innerText = smoothedZoom.toFixed(1) + '×';

            if (activeGroup) {
                drag.update();
                activeGroup.rotation.y = drag.rotationY;
                activeGroup.rotation.x = drag.rotationX;
            }

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>