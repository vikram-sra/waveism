<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space-Time | Relativistic Manifolds</title>
    <style>
        html,
        body {
            background: #000 !important;
        }
    </style>
    <link rel="stylesheet" href="components/shared.css">
    <script src="components/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: transparent;
        }

        .theory-tab.relativity-tab {
            color: #feeb2c;
        }

        .theory-tab.relativity-tab.active {
            background: rgba(254, 235, 44, 0.1);
            color: #feeb2c;
            box-shadow: inset 0 0 15px rgba(254, 235, 44, 0.2);
        }

        #cinematic-overlay {
            position: fixed;
            bottom: 30px;
            left: 20px;
            color: rgba(254, 235, 44, 0.4);
            font-family: 'JetBrains Mono';
            font-size: 0.52rem;
            letter-spacing: 0.15em;
            pointer-events: none;
            z-index: 100;
            max-width: 180px;
            line-height: 1.4;
        }

        .system-status {
            position: fixed;
            bottom: 30px;
            right: 20px;
            text-align: right;
            font-family: 'JetBrains Mono';
            font-size: 0.52rem;
            color: rgba(254, 235, 44, 0.4);
            line-height: 1.4;
            pointer-events: none;
            z-index: 100;
        }

        .manifold-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.03;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(254, 235, 44, 0.05) 1px, rgba(254, 235, 44, 0.05) 2px);
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="three-container"></div>
    <div id="cinematic-overlay">PHD-GRADE MINKOWSKI METRIC INTERFACE</div>
    <div class="manifold-glitch"></div>

    <div class="system-status">
        [ COORDINATES: LORENTZ COVARIANT ]<br>
        [ METRIC: (-+++) SIGNATURE ]<br>
        [ CAUSALITY: ENFORCED BY c ]
    </div>

    <div id="nav-container"></div>

    <div class="theory-nav-header">
        <div class="theory-nav-title">EXPLORE MODES</div>
        <div class="theory-nav-desc">Choose a simulation mode below to change the visualization</div>
    </div>
    <div class="theory-tabs">
        <button class="theory-tab relativity-tab active" data-theory="block-universe">The 4D Loaf</button>
        <button class="theory-tab" data-theory="light-cone">Light Cone</button>
        <button class="theory-tab" data-theory="gravity">General Relativity</button>
        <button class="theory-tab" data-theory="dilation">Time Dilation</button>
        <button class="theory-tab" data-theory="twin">Twin Paradox</button>
        <button class="theory-tab" data-theory="time-spiral">Time Spiral</button>
        <button class="theory-tab" data-theory="einstein-sr">Lorentz Scissoring</button>
        <button class="theory-tab" data-theory="causal-net">Causal Network</button>
        <button class="theory-tab" data-theory="event-horizon">Event Horizon</button>
    </div>

    <div class="params-panel">
        <div class="param-group">
            <div class="param-label" id="param1-label">Velocity (β)</div>
            <div class="param-value" id="param1-value">0.80c</div>
            <input type="range" class="param-slider" id="param1-slider" min="0" max="99" value="80">
        </div>
        <div class="param-group">
            <div class="param-label">Sim Intensity</div>
            <div class="param-value" id="speed-value">1.0×</div>
            <input type="range" class="param-slider" id="speed-slider" min="0" max="300" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Phase Zoom</div>
            <div class="param-value" id="zoom-value">1.0×</div>
            <input type="range" class="param-slider" id="zoom-slider" min="30" max="400" value="100">
        </div>
    </div>

    <div class="info-panel">
        <div class="theory-name" id="theory-name">Minkowski Light Cone</div>
        <div class="theory-year" id="theory-year">The Geometry of Causality (1908)</div>
        <div class="equation-box">
            <div class="equation-label">The Invariant Interval</div>
            <div class="equation" id="equation">ds² = c²dt² - dx² - dy² - dz²</div>
        </div>
        <div class="theory-facts" id="theory-facts"></div>
    </div>

    <button class="info-btn" id="info-btn">ⓘ</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header">
            <span class="info-modal-title">Relativistic Manifold Protocol</span>
            <button class="info-modal-close" id="info-close">×</button>
        </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Axiomatic Description</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Geometric Invariants</div>
                <ul id="info-concepts"></ul>
            </div>
            <div class="info-section">
                <div class="info-section-title">Waveism Interconnect</div>
                <p id="info-physics"></p>
            </div>
        </div>
    </div>

    <script>
        // ============ CORE SETUP ============
        document.getElementById('nav-container').innerHTML = renderMainNav('spacetime');

        let scene, camera, renderer, currentMode = 'light-cone';
        let activeGroup;
        let p1 = 0.8, timeScale = 1.0, time = 0;
        let smoothedZoom = 1.0;

        const theories = {
            'block-universe': {
                name: 'Block Universe', year: 'Eternalism Protocol',
                equation: 'M⁴ = R³ × T',
                facts: [{ text: 'Formal Past', status: 'yes' }, { text: 'Static Future', status: 'yes' }],
                description: 'The 4D "Meatloaf". Space and time exist as a singular, immutable solid. Your "Now" is a cross-sectional slice traversing the continuum.',
                concepts: [
                    { term: 'Eternalism', definition: 'The view that all temporal points are equally objective.' },
                    { term: 'World-Tube', definition: 'The 4D geometric extrusion of a 3D object\'s total history.' }
                ],
                physics: 'Waveism: The universe is a standing wave in 4D. Experience is the phase-front propagation of consciousness.'
            },
            'light-cone': {
                name: 'Light Cone Topology', year: 'Minkowski Geometry',
                equation: 'ds² = 0',
                facts: [{ text: 'Absolute Future', status: 'yes' }, { text: 'Causal Limit', status: 'yes' }],
                description: 'Causality boundaries. Light defines a 45° manifold. Outside lies "Absolute Elsewhere"—regions biologically unreachable from the origin.',
                concepts: [
                    { term: 'Causal Horizon', definition: 'The limit where signal propagation is blocked by light speed.' },
                    { term: 'Null Geodesic', definition: 'The trajectory of photons along the surface of the cone.' }
                ],
                physics: 'Waveism: Coherence boundary of the cosmic signal. Represents the maximum info-velocity in the vacuum.'
            },
            'gravity': {
                name: 'Einstein Geometry', year: 'Metric Warping',
                equation: 'G_μν = 8πT_μν',
                facts: [{ text: 'Curvature', status: 'yes' }, { text: 'Inertial Flow', status: 'yes' }],
                description: 'Spacetime curvature. Mass-energy density distorts the 4D manifold. Gravity is just the straightest possible path through a bent substrate.',
                concepts: [
                    { term: 'Metric Tensor', definition: 'A function defining the distance between points in the manifold.' },
                    { term: 'Geodesic', definition: 'The natural path followed by a free-falling particle.' }
                ],
                physics: 'Waveism: Gravity is the refractive index of the vacuum. Waves curve through high-density subregions.'
            },
            'dilation': {
                name: 'Lorentz Dilation', year: 'Temporal Distortion',
                equation: 'dt = γ dτ',
                facts: [{ text: 'Time Stretch', status: 'yes' }, { text: 'Invariant c', status: 'yes' }],
                description: 'Relative dimensionality. High velocity stretches the temporal interval to maintain the absolute invariance of c.',
                concepts: [
                    { term: 'Proper Time', definition: 'Time as measured by a clock following the worldline.' },
                    { term: 'Lorentz Shift', definition: 'The compression of space-time axes during high-β transit.' }
                ],
                physics: 'Waveism: Doppler-shift of internal oscillator frequency. Moving clocks beat slower relative to substrate.'
            },
            'twin': {
                name: 'Twin Paradox', year: 'Asymmetry Protocol',
                equation: 'Δτ_1 ≠ Δτ_2',
                facts: [{ text: 'Frame Breaking', status: 'yes' }, { text: 'Metric Drift', status: 'yes' }],
                description: 'The traveler accelerates, physically shortening their metric trajectory. Returning results in a tangible phase-offset in age.',
                concepts: [
                    { term: 'Acceleration', definition: 'The act of breaking inertial frames to traverse the metric.' },
                    { term: 'Path Invariant', definition: 'The length of a worldline through 4D space.' }
                ],
                physics: 'Waveism: The traveler cuts across cosmic phase-lines, returning with a permanent lag in internal frequency.'
            },
            'time-spiral': {
                name: 'Temporal Spiral', year: 'Cyclical Drift',
                equation: 't(θ) = z / (2πb)',
                facts: [{ text: 'Cyclicality', status: 'yes' }, { text: 'Entropy Drift', status: 'yes' }],
                description: 'Time as a 3D helix. Periodicity allows events to repeat in self-similar cycles while drifting forward linearly.',
                concepts: [
                    { term: 'Helical Time', definition: 'Motion through time combining oscillation and linear progress.' },
                    { term: 'Frequency Match', definition: 'The phenomenon of history repeating when the spiral radius aligns.' }
                ],
                physics: 'Waveism: The "Twist" of the vacuum. Energy recycled through cycles during forward drift.'
            },
            'einstein-sr': {
                name: 'Lorentz Scissoring', year: 'Axiomatic Geometry',
                equation: 'x\' = γ(x - vt)',
                facts: [{ text: 'Frame Invariant', status: 'yes' }, { text: 'Relative Now', status: 'yes' }],
                description: 'Visual proof of transformation. Spacetime axes "scissor" toward the light line as velocity approaches c.',
                concepts: [
                    { term: 'Hyperbolic Shift', definition: 'Rotation in Minkowski space by an imaginary angle.' },
                    { term: 'Simultaneity', definition: 'The collapse of "Now" into a relative observer slice.' }
                ],
                physics: 'Waveism: Geometric representation of phase-coherence. Observer rotates to align with signal flux.'
            },
            'causal-net': {
                name: 'Causal Network', year: 'Events & Nodes',
                equation: 'E = {v, e}',
                facts: [{ text: 'Connectivity', status: 'yes' }, { text: 'Information Flow', status: 'yes' }],
                description: 'Spacetime as a graph. Discrete events linked by light-speed signaling, forming a "web" of causality that underpins the continuum.',
                concepts: [
                    { term: 'Node Density', definition: 'The concentration of events in a local metric patch.' },
                    { term: 'Signal Latency', definition: 'The delay inherent in 4D connectivity dictated by c.' }
                ],
                physics: 'Waveism: The quantum graph of interconnected phase-oscillators.'
            },
            'event-horizon': {
                name: 'Event Horizon', year: 'The Final Frontier',
                equation: 'R_s = 2GM/c²',
                facts: [{ text: 'No Exit', status: 'yes' }, { text: 'Time Freeze', status: 'yes' }],
                description: 'The boundary of no return. Beyond this shell, all light-cones tip inward, ensuring every path leads to the singularity.',
                concepts: [
                    { term: 'Schwarzschild Radius', definition: 'The radius where the escape velocity equals the speed of light.' },
                    { term: 'Temporal Tipping', definition: 'The rotation of spacetime axes where time becomes space.' }
                ],
                physics: 'Waveism: The critical damping point where the medium stops propagating signals outward.'
            }
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('three-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x444444, 1.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x00ffff, 2, 100);
            pointLight.position.set(20, 20, 20);
            scene.add(pointLight);

            setupGraphics();
            createStarField(scene); // Add 3D Starfield

            initParamSlider('param1-slider', 'param1-value', {
                onChange: v => { p1 = v / 100; updateParamDisplay(); },
                formatter: v => (v / 100).toFixed(2) + 'c'
            });
            initParamSlider('speed-slider', 'speed-value', {
                onChange: v => timeScale = v / 100,
                formatter: v => (v / 100).toFixed(1) + '×'
            });
            initParamSlider('zoom-slider', 'zoom-value', {
                onChange: v => { if (window.zoomControl) window.zoomControl.zoom = v / 100; },
                formatter: v => (v / 100).toFixed(1) + '×'
            });

            const drag = initDragRotation(renderer.domElement, {
                initialRotationX: 0.5,
                initialRotationY: -0.4
            });
            window.globalDrag = drag;
            const zoomControl = initZoomHandler(renderer.domElement, { initialZoom: 0.7 });
            window.zoomControl = zoomControl;

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (window.clickPrevented) { window.clickPrevented = false; return; }
                drag.autoRotate = !drag.autoRotate;
            });

            initTheoryTabs(mode => switchMode(mode));
            initInfoModal();
            switchMode('block-universe');
            animate(drag, zoomControl);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createLabel(text, color = "#ffffff") {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            // High-res canvas for crisp text
            canvas.width = 512;
            canvas.height = 128;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = color;
            ctx.font = 'bold 40px JetBrains Mono, monospace'; // Slightly smaller font
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(16, 4, 1); // Wider default scale
            return sprite;
        }

        function setupGraphics() { }

        function updateParamDisplay() {
            const valEl = document.getElementById('param1-value');
            if (currentMode === 'light-cone') valEl.innerText = "Slice: " + p1.toFixed(2);
            else if (currentMode === 'gravity') valEl.innerText = "Mass: " + (p1 * 10).toFixed(1) + "M";
            else if (currentMode === 'dilation') valEl.innerText = "β: " + p1.toFixed(2) + "c";
            else if (currentMode === 'twin') valEl.innerText = "Max β: " + p1.toFixed(2) + "c";
            else if (currentMode === 'einstein-sr') valEl.innerText = "β: " + p1.toFixed(2) + "c";
        }

        function switchMode(mode) {
            currentMode = mode;
            scene.children.forEach(c => { if (c.type === "Group") scene.remove(c); });

            activeGroup = new THREE.Group();
            activeGroup.position.y = 0;

            if (mode === 'light-cone') {
                const res = 128, h = 60; // Increased scale and resolution

                // 1. THE CAUSAL HORIZON (MULTI-LAYERED HOLOGRAPHY)
                const horizonGroup = new THREE.Group();
                const colors = [0x00ffff, 0x0088ff, 0x0044ff];
                colors.forEach((col, i) => {
                    const fGeo = new THREE.ConeGeometry(h * (1 - i * 0.02), h, res, 1, true);
                    const fMat = new THREE.MeshPhongMaterial({
                        color: col,
                        transparent: true,
                        opacity: 0.1 / (i + 1),
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending,
                        shininess: 100,
                        emissive: col,
                        emissiveIntensity: 0.2
                    });
                    const fCone = new THREE.Mesh(fGeo, fMat);
                    fCone.position.y = h / 2;
                    fCone.name = "horizon_future_" + i;
                    horizonGroup.add(fCone);

                    const pCone = fCone.clone();
                    pCone.material = fMat.clone();
                    pCone.material.color.setHex(0xffaa00);
                    pCone.material.emissive.setHex(0xffaa00);
                    pCone.position.y = -h / 2;
                    pCone.rotation.x = Math.PI;
                    pCone.name = "horizon_past_" + i;
                    horizonGroup.add(pCone);
                });
                activeGroup.add(horizonGroup);

                // 2. NULL-PATH PHOTON STREAM (Particles screaming at c)
                const rayCount = 500; // 5x more particles
                const rayGeo = new THREE.BufferGeometry();
                const rayPos = new Float32Array(rayCount * 3);
                const rayVels = new Float32Array(rayCount);
                const rayColors = new Float32Array(rayCount * 3);
                for (let i = 0; i < rayCount; i++) {
                    rayVels[i] = Math.random() * h;
                    rayColors[i * 3] = 0; rayColors[i * 3 + 1] = 1; rayColors[i * 3 + 2] = 1;
                }
                rayGeo.setAttribute('position', new THREE.BufferAttribute(rayPos, 3));
                rayGeo.setAttribute('color', new THREE.BufferAttribute(rayColors, 3));
                const rayMat = new THREE.PointsMaterial({
                    size: 0.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                const rayPoints = new THREE.Points(rayGeo, rayMat);
                rayPoints.name = "null_stream";
                rayPoints.userData.velocities = rayVels;
                activeGroup.add(rayPoints);

                // 3. CAUSALITY RIPPLES (Expanding Wavefronts)
                const pulses = new THREE.Group();
                pulses.name = "causality_pulses";
                for (let i = 0; i < 6; i++) {
                    const rGeo = new THREE.TorusGeometry(1, 0.02, 16, 200);
                    const rMat = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0,
                        blending: THREE.AdditiveBlending
                    });
                    const ring = new THREE.Mesh(rGeo, rMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.userData.offset = i * (h / 6);
                    pulses.add(ring);
                }
                activeGroup.add(pulses);

                // 4. THE METRIC LATTICE (Warped Grid)
                const lattice = new THREE.Group();
                lattice.name = "metric_lattice";
                const latticeGeo = new THREE.PlaneGeometry(h * 3, h * 3, 40, 40);
                const latticeMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.03,
                    wireframe: true,
                    blending: THREE.AdditiveBlending
                });
                const plane = new THREE.Mesh(latticeGeo, latticeMat);
                plane.rotation.x = Math.PI / 2;
                lattice.add(plane);

                // Floating Origin Markers
                for (let i = 0; i < 20; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const r = 20 + Math.random() * 80;
                    const dot = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.1 }));
                    dot.position.set(Math.cos(ang) * r, 0, Math.sin(ang) * r);
                    lattice.add(dot);
                }
                activeGroup.add(lattice);

                // 5. CAUSAL EVENT (THE 'NOW' CORE)
                const coreGroup = new THREE.Group();
                coreGroup.name = "now_core";
                const core = new THREE.Mesh(
                    new THREE.SphereGeometry(1.2, 32, 32),
                    new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 2,
                        metalness: 1,
                        roughness: 0
                    })
                );
                coreGroup.add(core);

                const halo = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 32, 32),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2 })
                );
                coreGroup.add(halo);
                activeGroup.add(coreGroup);

                // 6. ADAPTIVE WORLDLINE (GEODESIC FILAMENT)
                const wlPoints = [];
                const wlEchoes = new THREE.Group();
                wlEchoes.name = "temporal_echoes";
                for (let i = 0; i <= 50; i++) {
                    const ty = (i / 50) * h - h / 2;
                    const tx = Math.sin(ty * 0.1) * (h * 0.15) + Math.cos(ty * 0.05) * 5;
                    const tz = Math.cos(ty * 0.2) * 8;
                    const p = new THREE.Vector3(tx, ty, tz);
                    wlPoints.push(p);

                    if (i % 5 === 0) {
                        const echo = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({ color: 0xfeeb2c, transparent: true, opacity: 0.3 }));
                        echo.position.copy(p);
                        wlEchoes.add(echo);
                    }
                }
                activeGroup.add(wlEchoes);

                const curve = new THREE.CatmullRomCurve3(wlPoints);
                const wlGeo = new THREE.TubeGeometry(curve, 200, 0.15, 8, false);
                const wlMat = new THREE.MeshPhongMaterial({
                    color: 0xfeeb2c,
                    emissive: 0xfeeb2c,
                    emissiveIntensity: 2,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                const worldline = new THREE.Mesh(wlGeo, wlMat);
                worldline.name = "geodesic_worldline";
                activeGroup.add(worldline);

                // 7. LABELS & HUD TOPOLOGY
                const axes = new THREE.Group();
                const xLine = new THREE.Mesh(new THREE.BoxGeometry(h * 3, 0.02, 0.02), new THREE.MeshBasicMaterial({ color: 0x333333 }));
                const zLine = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, h * 3), new THREE.MeshBasicMaterial({ color: 0x333333 }));
                const tLine = new THREE.Mesh(new THREE.BoxGeometry(0.05, h * 2, 0.05), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 }));
                axes.add(xLine, zLine, tLine);
                activeGroup.add(axes);

                const labelData = [
                    { t: "ABSOLUTE FUTURE", p: [0, h * 0.75, 0], c: "#00ffff", w: 16, h: 4 },
                    { t: "ABSOLUTE PAST", p: [0, -h * 0.75, 0], c: "#ffaa00", w: 16, h: 4 },
                    { t: "HYPERBOLIC CAUSALITY", p: [h * 0.45, h * 0.45, 0], c: "#00ffff", w: 14, h: 3.5 },
                    { t: "ABSOLUTE ELSEWHERE", p: [h * 0.9, 0, 0], c: "#ffffff", w: 16, h: 4 }
                ];
                labelData.forEach(l => {
                    const lbl = createLabel(l.t, l.c);
                    lbl.position.set(...l.p);
                    lbl.scale.set(l.w, l.h, 1);
                    activeGroup.add(lbl);
                });

                document.getElementById('param1-label').innerText = "Coordinate Time Scrub";
            } else if (mode === 'block-universe') {
                // THE 4D CRYSTAL MANIFOLD (Refined Loaf)
                const crystalGroup = new THREE.Group();
                crystalGroup.name = "spacetime_crystal";

                // 1. The Core Manifold (Slender Crystalline structure)
                const crystalGeo = new THREE.IcosahedronGeometry(15, 2);
                const crystalMat = new THREE.MeshPhongMaterial({
                    color: 0xfeeb2c,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.1,
                    emissive: 0xfeeb2c,
                    emissiveIntensity: 0.1
                });
                const crystal = new THREE.Mesh(crystalGeo, crystalMat);
                // Extrude in time (Subtler layering)
                for (let i = 0; i < 8; i++) {
                    const layer = crystal.clone();
                    layer.position.z = (i - 3.5) * 10;
                    layer.rotation.z = i * 0.2;
                    layer.scale.setScalar(1 + Math.sin(i * 0.5) * 0.15);
                    crystalGroup.add(layer);
                }
                activeGroup.add(crystalGroup);

                // 2. The Consciousness Fronts (Refined Slices)
                const slicerGeo = new THREE.PlaneGeometry(60, 60);
                const slicerMat = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.3
                });
                const slicer = new THREE.Mesh(slicerGeo, slicerMat);
                slicer.name = "now_slicer";
                activeGroup.add(slicer);

                // 3. Selective World Line Filaments
                const lineGroup = new THREE.Group();
                for (let i = 0; i < 8; i++) {
                    const pts = [];
                    const radius = 4 + Math.random() * 8;
                    for (let z = -60; z <= 60; z += 10) {
                        pts.push(new THREE.Vector3(
                            Math.sin(z * 0.08 + i) * radius,
                            Math.cos(z * 0.08 + i) * radius,
                            z
                        ));
                    }
                    const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 48, 0.1, 6, false);
                    const tubeMat = new THREE.MeshPhongMaterial({ color: 0xff00ff, transparent: true, opacity: 0.15 });
                    lineGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
                }
                activeGroup.add(lineGroup);

                const label = createLabel("THE ETERNAL NOW", "#ffffff");
                label.name = "now_label";
                activeGroup.add(label);

                document.getElementById('param1-label').innerText = "Slice Coordinate Time";
            } else if (mode === 'causal-net') {
                // TOPOLOGICAL NODE WEB
                const netGroup = new THREE.Group();
                const nodeCount = 60;
                const nodeGeo = new THREE.SphereGeometry(0.5, 12, 12);
                const nodeMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2 });

                const nodePos = [];
                for (let i = 0; i < nodeCount; i++) {
                    const node = new THREE.Mesh(nodeGeo, nodeMat);
                    node.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    netGroup.add(node);
                    nodePos.push(node.position);
                }

                // Connections
                const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
                const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2 });
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = i + 1; j < nodeCount; j++) {
                        if (nodePos[i].distanceTo(nodePos[j]) < 20) {
                            const line = new THREE.Line(lineGeo.clone(), lineMat);
                            line.geometry.setFromPoints([nodePos[i], nodePos[j]]);
                            netGroup.add(line);
                        }
                    }
                }
                netGroup.name = "causal_net";
                activeGroup.add(netGroup);
                document.getElementById('param1-label').innerText = "Signal Coherence";
            } else if (mode === 'event-horizon') {
                // GRAVITATIONAL SINGULARITY (Interstellar Style)
                const bhGroup = new THREE.Group();
                bhGroup.name = "singularity";

                // 1. The Event Horizon (Dark Core)
                const core = new THREE.Mesh(
                    new THREE.SphereGeometry(3, 64, 64),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                bhGroup.add(core);

                // 2. Gravitational Lensing Halo (The "Vertical" Ring)
                const halo = new THREE.Mesh(
                    new THREE.TorusGeometry(10, 0.4, 16, 100),
                    new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending })
                );
                halo.name = "lensing_halo";
                bhGroup.add(halo);

                // 2b. Photon Sphere (Inner Light Trapping)
                const photonSphere = new THREE.Mesh(
                    new THREE.TorusGeometry(5, 0.05, 16, 100),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending })
                );
                photonSphere.rotation.x = Math.PI / 2;
                photonSphere.name = "photon_sphere";
                bhGroup.add(photonSphere);

                // 3. Multi-Layer Accretion Disk (Horizontal)
                const diskGroup = new THREE.Group();
                diskGroup.name = "accretion_group";
                for (let i = 0; i < 4; i++) {
                    const disk = new THREE.Mesh(
                        new THREE.TorusGeometry(7 + i * 3, 0.4 - i * 0.08, 16, 100),
                        new THREE.MeshBasicMaterial({
                            color: i === 0 ? 0xffbb00 : 0xff3300,
                            transparent: true,
                            opacity: 0.7 - i * 0.15,
                            blending: THREE.AdditiveBlending
                        })
                    );
                    disk.rotation.x = Math.PI / 2;
                    disk.userData.speed = 3 - i * 0.6;
                    diskGroup.add(disk);
                }
                bhGroup.add(diskGroup);

                // 4. Polar Jets (Gamma Emission)
                const jetGeo = new THREE.CylinderGeometry(0.1, 2, 80, 16, 1, true);
                const jetMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
                const jet1 = new THREE.Mesh(jetGeo, jetMat);
                jet1.position.y = 40;
                const jet2 = jet1.clone();
                jet2.position.y = -40;
                jet2.rotation.z = Math.PI;
                bhGroup.add(jet1, jet2);

                // 5. Spiraling Infall Particles
                const pCount = 200;
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(pCount * 3);
                const pSpeeds = new Float32Array(pCount);
                for (let i = 0; i < pCount; i++) {
                    pSpeeds[i] = 0.5 + Math.random();
                }
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const pMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.3, transparent: true, blending: THREE.AdditiveBlending });
                const particles = new THREE.Points(pGeo, pMat);
                particles.name = "infall_particles";
                particles.userData.speeds = pSpeeds;
                bhGroup.add(particles);

                // 6. Curvature Grid
                const gridGroup = new THREE.Group();
                gridGroup.name = "warped_grid";
                const step = 4;
                for (let i = -40; i <= 40; i += step) {
                    const lineXPts = [];
                    const lineZPts = [];
                    for (let j = -40; j <= 40; j += 2) {
                        lineXPts.push(new THREE.Vector3(i, 0, j));
                        lineZPts.push(new THREE.Vector3(j, 0, i));
                    }
                    const lMat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.15 });
                    gridGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(lineXPts), lMat));
                    gridGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(lineZPts), lMat));
                }
                bhGroup.add(gridGroup);

                activeGroup.add(bhGroup);
                document.getElementById('param1-label').innerText = "Mass Density (M)";
            } else if (mode === 'gravity') {
                const gridRes = 30, range = 40;
                const points = [];
                for (let i = -gridRes; i <= gridRes; i++) {
                    for (let j = -gridRes; j <= gridRes; j++) {
                        const x = (i / gridRes) * range;
                        const z = (j / gridRes) * range;
                        const r = Math.sqrt(x * x + z * z);
                        const p = new THREE.Vector3(x, 0, z);
                        points.push(p);
                    }
                }
                const grid = new THREE.Group();
                grid.name = "gravity_grid";
                // Add internal meshes to represent the grid lines
                const mat = new THREE.LineBasicMaterial({ color: 0xfeeb2c, transparent: true, opacity: 0.3 });
                for (let i = -gridRes; i <= gridRes; i++) {
                    const ptsH = [], ptsV = [];
                    for (let j = -gridRes; j <= gridRes; j++) {
                        ptsH.push(new THREE.Vector3((j / gridRes) * range, 0, (i / gridRes) * range));
                        ptsV.push(new THREE.Vector3((i / gridRes) * range, 0, (j / gridRes) * range));
                    }
                    const lineH = new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsH), mat);
                    const lineV = new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsV), mat);
                    grid.add(lineH); grid.add(lineV);
                }
                activeGroup.add(grid);

                const star = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 32), new THREE.MeshPhongMaterial({ color: 0xffaa00, emissive: 0xff5500, emissiveIntensity: 1 }));
                star.position.y = -5;
                activeGroup.add(star);
                document.getElementById('param1-label').innerText = "Mass Density";
            } else if (mode === 'dilation' || mode === 'twin') {
                // Time axis
                const axisMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const pts = [new THREE.Vector3(0, -30, 0), new THREE.Vector3(0, 30, 0)];
                activeGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), axisMat));

                function createClock(name, color, x) {
                    const group = new THREE.Group();
                    group.name = name;
                    group.position.x = x;

                    // Clock Face (Atomic Shell)
                    const shell = new THREE.Mesh(
                        new THREE.TorusGeometry(5, 0.2, 16, 100),
                        new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 })
                    );
                    group.add(shell);

                    // Ticks
                    for (let i = 0; i < 12; i++) {
                        const tick = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1, 0.2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                        const angle = (i / 12) * Math.PI * 2;
                        tick.position.set(Math.cos(angle) * 4.5, Math.sin(angle) * 4.5, 0);
                        tick.rotation.z = angle;
                        group.add(tick);
                    }

                    // Pulse/Hand
                    const hand = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.2), new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffffff }));
                    hand.position.y = 2;
                    const handPivot = new THREE.Group();
                    handPivot.name = name + "_hand";
                    handPivot.add(hand);
                    group.add(handPivot);

                    // Labels
                    const lbl = createLabel(name.toUpperCase(), color);
                    lbl.position.y = 8;
                    group.add(lbl);

                    return group;
                }

                activeGroup.add(createClock("observer", "#00ffff", -15));
                activeGroup.add(createClock("traveller", "#feeb2c", 15));

                document.getElementById('param1-label').innerText = (mode === 'dilation') ? "Velocity (β)" : "Peak Velocity";
            } else if (mode === 'einstein-sr') {
                const grid = new THREE.GridHelper(40, 20, 0x00ffff, 0x444444);
                grid.rotation.x = Math.PI / 2;
                activeGroup.add(grid);

                const axisY = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 40), new THREE.MeshBasicMaterial({ color: 0xfeeb2c }));
                axisY.name = "boost_t";
                activeGroup.add(axisY);

                const axisX = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 40), new THREE.MeshBasicMaterial({ color: 0xfeeb2c }));
                axisX.rotation.z = Math.PI / 2;
                axisX.name = "boost_x";
                activeGroup.add(axisX);

                document.getElementById('param1-label').innerText = "Relative Velocity";
            } else if (mode === 'time-spiral') {
                const spiralGroup = new THREE.Group();
                spiralGroup.name = "spiral_root";

                const points = [];
                const count = 2000;
                for (let i = 0; i < count; i++) {
                    const t = (i / count) * 60; // 60 units high
                    const r = 10 + Math.sin(t * 0.1) * 2;
                    const x = Math.cos(t) * r;
                    const z = Math.sin(t) * r;
                    const y = t - 30; // Center at 0
                    points.push(new THREE.Vector3(x, y, z));
                }

                const curve = new THREE.CatmullRomCurve3(points);
                const geo = new THREE.TubeGeometry(curve, 200, 0.5, 8, false);
                const mat = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                const spiral = new THREE.Mesh(geo, mat);
                spiral.name = "time_helix";
                spiralGroup.add(spiral);

                // Add flowing particles
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(300 * 3);
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const pMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
                const pts = new THREE.Points(pGeo, pMat);
                pts.name = "spiral_particles";
                spiralGroup.add(pts);

                activeGroup.add(spiralGroup);
                document.getElementById('param1-label').innerText = "Spiral Tension";
            }

            if (window.globalDrag) {
                activeGroup.rotation.y = window.globalDrag.rotationY;
                activeGroup.rotation.x = window.globalDrag.rotationX;
            }

            scene.add(activeGroup);
            updateTheoryHeader(theories[mode].name, theories[mode].description);
            updateInfoPanel(theories[mode]);
            updateInfoModalContent(theories[mode]);
            updateParamDisplay();
        }

        function updateSim() {
            const dt = 0.01 * timeScale;
            time += dt;

            if (currentMode === 'block-universe') {
                const slicer = activeGroup.getObjectByName("now_slicer");
                const label = activeGroup.getObjectByName("now_label");
                const crystal = activeGroup.getObjectByName("spacetime_crystal");

                const zPos = (p1 - 0.5) * 150;

                if (slicer) {
                    slicer.position.z = zPos;
                    slicer.material.opacity = 0.15 + Math.sin(time * 3) * 0.05;
                }
                if (label) {
                    label.position.set(0, 50, zPos);
                }
                if (crystal) {
                    crystal.children.forEach((c, i) => {
                        c.rotation.z += 0.005;
                        c.material.opacity = 0.1 + Math.sin(time + i) * 0.05;
                    });
                }
            } else if (currentMode === 'causal-net') {
                const net = activeGroup.getObjectByName("causal_net");
                if (net) {
                    net.children.forEach((c, j) => {
                        if (c.type === "Mesh") {
                            c.position.y += Math.sin(time + j) * 0.05 * p1;
                            c.scale.setScalar(1 + Math.sin(time * 5 + j) * 0.2);
                        }
                    });
                    net.rotation.y += 0.002;
                }
            } else if (currentMode === 'event-horizon') {
                const singularity = activeGroup.getObjectByName("singularity");
                if (singularity) {
                    const mass = p1 * 50;
                    const disco = singularity.getObjectByName("accretion_group");
                    const halo = singularity.getObjectByName("lensing_halo");
                    const particles = singularity.getObjectByName("infall_particles");
                    const grid = singularity.getObjectByName("warped_grid");

                    if (disco) {
                        disco.children.forEach((layer, i) => {
                            layer.rotation.z += 0.02 * layer.userData.speed * (p1 + 0.5);
                            layer.scale.setScalar(1 + Math.sin(time * 2 + i) * 0.05);
                        });
                    }

                    if (halo) {
                        halo.rotation.y = time * 0.5;
                        halo.rotation.x = Math.sin(time * 0.3) * 0.2;
                        halo.scale.setScalar(1 + Math.cos(time) * 0.02);
                    }

                    if (particles) {
                        const pos = particles.geometry.attributes.position;
                        const speeds = particles.userData.speeds;
                        for (let i = 0; i < pos.count; i++) {
                            const angle = time * speeds[i] + i;
                            const r = 25 - ((time * 10 * speeds[i] + i * 5) % 22);
                            if (r < 3) { // Reset if too close to center
                                pos.setXYZ(i, 0, 0, 0);
                            } else {
                                pos.setXYZ(i, Math.cos(angle) * r, Math.sin(time * 0.1) * 2, Math.sin(angle) * r);
                            }
                        }
                        pos.needsUpdate = true;
                    }

                    if (grid) {
                        grid.children.forEach(line => {
                            const pos = line.geometry.attributes.position;
                            for (let i = 0; i < pos.count; i++) {
                                const x = pos.getX(i);
                                const z = pos.getZ(i);
                                const r = Math.sqrt(x * x + z * z);
                                const y = -mass / (r / 4 + 1.2);
                                pos.setY(i, y);
                            }
                            pos.needsUpdate = true;
                        });
                    }
                }
            } else if (currentMode === 'light-cone') {
                const h = 60;
                const lattice = activeGroup.getObjectByName("metric_lattice");
                const core = activeGroup.getObjectByName("now_core");
                const rayPoints = activeGroup.getObjectByName("null_stream");
                const pulses = activeGroup.getObjectByName("causality_pulses");

                const ty = (p1 - 0.5) * h * 2;
                if (lattice) lattice.position.y = ty;

                if (core) {
                    core.position.y = ty;
                    core.position.x = Math.sin(ty * 0.1) * (h * 0.15) + Math.cos(ty * 0.05) * 5;
                    core.position.z = Math.cos(ty * 0.2) * 8;
                    core.scale.setScalar(1 + Math.sin(time * 5) * 0.1);
                    core.children[0].material.emissiveIntensity = 2 + Math.sin(time * 10);
                }

                // Animate Null Stream (Particles screaming along c boundary)
                if (rayPoints) {
                    const pos = rayPoints.geometry.attributes.position.array;
                    const vels = rayPoints.userData.velocities;
                    for (let i = 0; i < vels.length; i++) {
                        vels[i] = (vels[i] + dt * 20) % h;
                        const dist = vels[i];
                        const angle = (i / vels.length) * Math.PI * 2;
                        pos[i * 3] = dist * Math.cos(angle + time * 0.1);
                        pos[i * 3 + 1] = dist; // Future flow
                        pos[i * 3 + 2] = dist * Math.sin(angle + time * 0.1);
                    }
                    rayPoints.geometry.attributes.position.needsUpdate = true;
                }

                // Animate Causality Ripples
                if (pulses) {
                    pulses.children.forEach((ring, i) => {
                        let y = (time * 12 + ring.userData.offset) % h;
                        ring.position.y = y;
                        ring.scale.setScalar(y);
                        ring.material.opacity = (1.0 - y / h) * 0.6;
                    });
                }

                // Horizon Pulsation
                for (let i = 0; i < 3; i++) {
                    const fut = activeGroup.getObjectByName("horizon_future_" + i);
                    if (fut) fut.material.opacity = (0.1 / (i + 1)) * (1 + Math.sin(time * 2 + i) * 0.5);
                }

            } else if (currentMode === 'time-spiral') {
                const spiral = activeGroup.getObjectByName("time_helix");
                const pts = activeGroup.getObjectByName("spiral_particles");
                if (spiral) {
                    spiral.rotation.y = time * 0.5;
                    const s = 1 + Math.sin(time * 0.5) * 0.1;
                    spiral.scale.set(s, 1, s);
                }
                if (pts) {
                    const pos = pts.geometry.attributes.position.array;
                    for (let i = 0; i < 300; i++) {
                        const tOffset = (i / 300) * 60 + time * 10;
                        const t = tOffset % 60;
                        const r = 10 + Math.sin(t * 0.1) * 2;
                        const noise = (Math.random() - 0.5) * 1.5;
                        pos[i * 3] = Math.cos(t) * (r + noise);
                        pos[i * 3 + 1] = t - 30;
                        pos[i * 3 + 2] = Math.sin(t) * (r + noise);
                    }
                    pts.geometry.attributes.position.needsUpdate = true;
                    pts.rotation.y = time * 0.5;
                }
            } else if (currentMode === 'gravity') {
                const grid = activeGroup.getObjectByName("gravity_grid");
                const mass = p1 * 15;
                if (grid) {
                    grid.children.forEach(line => {
                        const pos = line.geometry.attributes.position;
                        for (let i = 0; i < pos.count; i++) {
                            const x = pos.getX(i);
                            const z = pos.getZ(i);
                            const r = Math.sqrt(x * x + z * z);
                            const y = -mass / (r / 3 + 1);
                            pos.setY(i, y);
                        }
                        pos.needsUpdate = true;
                    });
                }
            } else if (currentMode === 'dilation') {
                const beta = p1;
                const gamma = 1 / Math.sqrt(Math.max(0.001, 1 - beta * beta));
                const cRest = activeGroup.getObjectByName("observer_hand");
                const cMov = activeGroup.getObjectByName("traveller_hand");
                const traveler = activeGroup.getObjectByName("traveller");

                if (cRest) cRest.rotation.z = -time * 2;
                if (cMov) cMov.rotation.z = -time * 2 / gamma;

                if (traveler) {
                    // Lorentz Contraction: Object shortens in the direction of motion (X-axis)
                    // We simulate travel on X, so it flattens.
                    const stretch = 1 / gamma;
                    traveler.scale.x = stretch;
                    // Oscillate on Z to show 'speed' presence
                    traveler.position.z = Math.sin(time * 10 * beta) * beta;
                }
            } else if (currentMode === 'twin') {
                const beta = p1;
                const gamma = 1 / Math.sqrt(Math.max(0.001, 1 - beta * beta));
                const cRest = activeGroup.getObjectByName("observer_hand");
                const cMov = activeGroup.getObjectByName("traveller_hand");
                const traveler = activeGroup.getObjectByName("traveller");
                const observer = activeGroup.getObjectByName("observer");

                if (cRest) {
                    cRest.rotation.z = -time * 2;
                }
                if (cMov) {
                    cMov.rotation.z = -time * 2 / gamma;
                }
                if (traveler && observer) {
                    const dist = 15;
                    const travel = Math.sin(time) * dist;
                    traveler.position.x = travel;
                    traveler.scale.x = (beta > 0) ? (1 / (1 + (beta * Math.abs(Math.cos(time))))) : 1;
                }
            } else if (currentMode === 'einstein-sr') {
                const beta = p1;
                const angle = Math.atan(beta);
                const tAxis = activeGroup.getObjectByName("boost_t");
                const xAxis = activeGroup.getObjectByName("boost_x");
                if (tAxis) tAxis.rotation.z = -angle;
                if (xAxis) xAxis.rotation.z = Math.PI / 2 + angle;
            }
        }

        function animate(drag, zoomControl) {
            requestAnimationFrame(() => animate(drag, zoomControl));
            updateSim();

            const stars = scene.getObjectByName("global_starfield");
            updateStarField(stars, time, drag);

            const targetZoom = zoomControl.zoom;
            smoothedZoom += (targetZoom - smoothedZoom) * 0.1;
            camera.position.z = 80 / smoothedZoom;

            const zSlider = document.getElementById('zoom-slider');
            if (zSlider && !zSlider.matches(':active')) zSlider.value = smoothedZoom * 100;
            document.getElementById('zoom-value').innerText = smoothedZoom.toFixed(1) + '×';

            if (activeGroup) {
                drag.update();
                activeGroup.rotation.y = drag.rotationY;
                activeGroup.rotation.x = drag.rotationX;
            }

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>