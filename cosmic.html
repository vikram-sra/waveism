<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="icons/icon-180.png">
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic | Spacetime Manifolds</title>
    <style>
        html,
        body {
            background: #000 !important;
        }
    </style>
    <link rel="stylesheet" href="components/shared.css">
    <script src="components/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: transparent;
        }

        .theory-tab.cosmic-tab {
            color: #0088ff;
        }

        .theory-tab.cosmic-tab.active {
            background: rgba(0, 136, 255, 0.1);
            color: #0088ff;
            box-shadow: inset 0 0 15px rgba(0, 136, 255, 0.2);
        }





        .manifold-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.03;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 136, 255, 0.05) 1px, rgba(0, 136, 255, 0.05) 2px);
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="three-container"></div>

    <div class="manifold-glitch"></div>



    <div id="nav-container"></div>

    <div class="theory-nav-header">
        <div class="theory-nav-title">EXPLORE MODES</div>
        <div class="theory-nav-desc">Choose a simulation mode below to change the visualization</div>
    </div>
    <div class="theory-tabs">
        <button class="theory-tab cosmic-tab active" data-theory="worldline">Helical Worldline</button>
        <button class="theory-tab" data-theory="emc2">E = mc² Core</button>
        <button class="theory-tab" data-theory="gravity">Metric Tensor</button>
        <button class="theory-tab" data-theory="funnel">Cosmic Funnel</button>
        <button class="theory-tab" data-theory="singularity">The Singularity</button>
    </div>

    <div class="params-panel">
        <div class="param-group">
            <div class="param-label" id="param1-label">Metric Warp</div>
            <div class="param-value" id="param1-value">1.0</div>
            <input type="range" class="param-slider" id="param1-slider" min="10" max="250" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Simulation Rate</div>
            <div class="param-value" id="speed-value">1.0×</div>
            <input type="range" class="param-slider" id="speed-slider" min="0" max="300" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Metric Zoom</div>
            <div class="param-value" id="zoom-value">1.0×</div>
            <input type="range" class="param-slider" id="zoom-slider" min="30" max="400" value="100">
        </div>
    </div>

    <div class="info-panel">
        <div class="theory-name" id="theory-name">Helical Worldlines</div>
        <div class="theory-year" id="theory-year">Minkowski Spacetime (1908)</div>
        <div class="equation-box">
            <div class="equation-label">The Invariant Interval</div>
            <div class="equation" id="equation">ds² = -c²dt² + dx² + dy² + dz²</div>
        </div>
        <div class="theory-facts" id="theory-facts"></div>
    </div>

    <button class="info-btn" id="info-btn">ⓘ</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header">
            <span class="info-modal-title">Cosmic Spacetime Protocol</span>
            <button class="info-modal-close" id="info-close">×</button>
        </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Axiomatic Description</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Metric Invariants</div>
                <ul id="info-concepts"></ul>
            </div>
            <div class="info-section">
                <div class="info-section-title">Mathematical Backbone</div>
                <p id="info-equation-explanation"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Waveism Interconnect</div>
                <p id="info-physics"></p>
            </div>
        </div>
    </div>

    <script>
        // ============ CORE SETUP ============
        document.getElementById('nav-container').innerHTML = renderMainNav('cosmic');

        let scene, camera, renderer, currentMode = 'worldline';
        let activeGroup;
        let p1 = 100, timeScale = 1.0, time = 0;
        let smoothedZoom = 1.0;

        const theories = {
            'worldline': {
                name: 'Helical Worldlines', year: 'Hermann Minkowski, 1908',
                equation: 'x(τ) = (R cos ωτ, R sin ωτ, vτ)',
                equationExpl: 'The parametric equation of a helical worldline. It describes an object orbiting in space while moving linearly through the vertical temporal dimension.',
                facts: [{ text: 'Proper Time', status: 'yes' }, { text: '4D Cylinder', status: 'yes' }],
                description: 'The geometric interpretation of orbits. In 3D space, a planet circles a sun. In 4D spacetime, the same planet traces a helical "worldline" through the vertical temporal dimension. All objects move through spacetime at the constant speed of light c.',
                concepts: [
                    { term: 'Simultaneity Slices', definition: 'Horizontal planes representing a single moment of "Now" for a given observer.' },
                    { term: 'Proper Time (τ)', definition: 'The time experienced by an object traveling along its worldline.' },
                    { term: 'Invariant Interval', definition: 'The "distance" in spacetime that remains constant regardless of the observer\'s frame.' }
                ],
                physics: 'In Waveism, a worldline is the "Phase-Trace" of a signal. Every object is a wave-packet moving through the substrate; its path is the coherent history of its constructive interference.'
            },
            'emc2': {
                name: 'Mass-Energy Symmetry', year: 'Wave-Knot Protocol',
                equation: 'E² = (pc)² + (m₀c²)²',
                equationExpl: 'The full relativistic energy-momentum relation. It shows that energy is a combination of mass-energy (m₀c²) and the kinetic energy of momentum (pc).',
                facts: [{ text: 'Trapped Energy', status: 'yes' }, { text: 'Exchange', status: 'yes' }],
                description: 'Mass as energy trapped in localized resonance. Mass-energy symmetry allows conversion between radiant flux and localized states.',
                concepts: [
                    { term: 'Rest Mass', definition: 'The invariant energy of a static system.' },
                    { term: 'Wave-Knot', definition: 'Localization of free waves into standing resonant structures.' }
                ],
                physics: 'Waveism: E=mc² is the conversion factor between free propagation and localized standing waves.'
            },
            'gravity': {
                name: 'Metric Warping', year: 'Einstein Manifold',
                equation: 'G_μν = 8πT_μν',
                equationExpl: 'The Einstein Field Equation states that the geometry of spacetime (G) is curved by the presence of all mass, energy, and momentum (T).',
                facts: [{ text: 'Dynamic Stage', status: 'yes' }, { text: 'Geodesic Flow', status: 'yes' }],
                description: 'Gravity as curvature. Massive objects deform the metric, dictating the "straightest" paths for all system agents.',
                concepts: [
                    { term: 'Energy Flux', definition: 'The flow of momentum density through the manifold.' },
                    { term: 'Ricci Curvature', definition: 'The geometric measure of local volume distortion.' }
                ],
                physics: 'Waveism: Gravity is the refractive index of the cosmic substrate.'
            },
            'funnel': {
                name: 'Cosmic Funnel', year: 'Expansion Era',
                equation: 'ȧ/a = H(t)',
                equationExpl: "The Hubble expansion rate. It measures the relative growth of the universe's scale factor (a) over time, describing its cosmic history.",
                facts: [{ text: 'Metric Stretch', status: 'yes' }, { text: 'Scalar Field', status: 'yes' }],
                description: 'Holographic history of the manifold. Expansion from high-energy singularity to the era of dark energy acceleration.',
                concepts: [
                    { term: 'Hubble Flow', definition: 'Metric stretching of space between clusters.' },
                    { term: 'Phase Shift', definition: 'The global transition from coherent node to multi-frequency field.' }
                ],
                physics: 'Waveism: The Big Bang was a global phase-shift in the vacuum state.'
            },
            'singularity': {
                name: 'Event Horizon', year: 'Schwarzschild Limit',
                equation: 'R_s = 2GM/c²',
                equationExpl: 'The Schwarzschild radius defines the point of no return where the escape velocity exactly equals the speed of light.',
                facts: [{ text: 'Infinite Curve', status: 'yes' }, { text: 'Time Freeze', status: 'yes' }],
                description: 'The ultimate cosmic resonance. A region where curvature is so extreme that the metric field effectively disconnects from the surrounding worldlines.',
                concepts: [
                    { term: 'Spaghettification', definition: 'Extreme tidal forces stretching objects into worldline filaments.' },
                    { term: 'Lensing', definition: 'The bending of information-carrying waves around the gravitational well.' }
                ],
                physics: 'Waveism: A singularity is a point of destructive interference in the metric field where all phase-information is localized and lost.'
            }
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2500);
            camera.position.set(0, 0, 250);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('three-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x444444, 2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x0088ff, 2, 500);
            pointLight.position.set(50, 50, 50);
            scene.add(pointLight);

            setupGraphics();
            createStarField(scene); // Add global starfield

            initParamSlider('param1-slider', 'param1-value', {
                onChange: v => { p1 = v; updateParamDisplay(); },
                formatter: v => v
            });
            initParamSlider('speed-slider', 'speed-value', {
                onChange: v => timeScale = v / 100,
                formatter: v => (v / 100).toFixed(1) + '×'
            });
            initParamSlider('zoom-slider', 'zoom-value', {
                onChange: v => { if (window.zoomControl) window.zoomControl.zoom = v / 100; },
                formatter: v => (v / 100).toFixed(1) + '×'
            });

            const drag = initDragRotation(renderer.domElement, { initialRotationX: 0.2 });
            window.globalDrag = drag;
            const zoomControl = initZoomHandler(renderer.domElement, { initialZoom: 1.0 });
            window.zoomControl = zoomControl;

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (window.clickPrevented) { window.clickPrevented = false; return; }
                drag.autoRotate = !drag.autoRotate;
            });

            initTheoryTabs(mode => switchMode(mode));
            initInfoModal();
            switchMode('worldline');
            animate(drag, zoomControl);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupGraphics() { }

        function updateParamDisplay() {
            const valEl = document.getElementById('param1-value');
            valEl.innerText = p1;
        }

        function createLabel(text, yPos, size = 36) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 128;
            ctx.fillStyle = '#00ddff'; // Cyan
            ctx.font = 'bold ' + size + 'px "JetBrains Mono"';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#00ddff';
            ctx.shadowBlur = 10;
            ctx.fillText(text, 256, 70);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.9, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(60, 15, 1);
            sprite.position.y = yPos;
            return sprite;
        }

        function switchMode(mode) {
            currentMode = mode;
            scene.children.forEach(c => { if (c.type === "Group") scene.remove(c); });

            activeGroup = new THREE.Group();
            activeGroup.position.y = 10;

            if (mode === 'worldline') {
                const geo = new THREE.CylinderGeometry(50, 50, 300, 32, 1, true);
                const mat = new THREE.MeshPhongMaterial({ color: 0x0088ff, wireframe: true, transparent: true, opacity: 0.1 });
                const cylinder = new THREE.Mesh(geo, mat);
                activeGroup.add(cylinder);

                const curve = new THREE.CatmullRomCurve3([]);
                const helixGeo = new THREE.BufferGeometry().setFromPoints(new Array(200).fill(new THREE.Vector3()));
                const helix = new THREE.Line(helixGeo, new THREE.LineBasicMaterial({ color: 0x00ffff }));
                helix.name = "helix";
                activeGroup.add(helix);

                const nowLabel = new THREE.Mesh(new THREE.SphereGeometry(3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                nowLabel.name = "nowLabel";
                activeGroup.add(nowLabel);

                // LABELS
                activeGroup.add(createLabel("FUTURE CONE", 160));
                activeGroup.add(createLabel("PAST CONE", -160));
                activeGroup.add(createLabel("OBSERVER NOW", 0, 24));

            } else if (mode === 'emc2') {
                const geo = new THREE.SphereGeometry(20, 32, 32);
                const mat = new THREE.MeshPhongMaterial({ color: 0x0088ff, emissive: 0x004488 });
                const core = new THREE.Mesh(geo, mat);
                activeGroup.add(core);

                for (let i = 0; i < 3; i++) {
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(30 + i * 20, 0.5, 16, 100), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 }));
                    ring.rotation.x = Math.PI / 2;
                    ring.name = "ring_" + i;
                    activeGroup.add(ring);
                }
                activeGroup.add(createLabel("REST MASS m₀", 0));
                activeGroup.add(createLabel("BINDING FIELD", 90));

            } else if (mode === 'gravity') {
                const geo = new THREE.PlaneGeometry(300, 300, 40, 40);
                const mat = new THREE.MeshPhongMaterial({ color: 0x0088ff, wireframe: true, transparent: true, opacity: 0.4 });
                const grid = new THREE.Mesh(geo, mat);
                grid.rotation.x = -Math.PI / 2;
                grid.name = "grid";
                activeGroup.add(grid);

                const attractor = new THREE.Mesh(new THREE.SphereGeometry(10, 16, 16), new THREE.MeshPhongMaterial({ color: 0xffffff }));
                attractor.name = "attractor";
                activeGroup.add(attractor);

                activeGroup.add(createLabel("MASS M", 30));
                activeGroup.add(createLabel("METRIC DISTORTION", -50));

            } else if (mode === 'funnel') {
                const geo = new THREE.CylinderGeometry(150, 1, 300, 64, 1, true);
                const mat = new THREE.MeshPhongMaterial({ color: 0x0088ff, wireframe: true, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                const funnel = new THREE.Mesh(geo, mat);
                funnel.name = "funnel";
                activeGroup.add(funnel);

                // Starfield logic...
                const galaxiesGeo = new THREE.BufferGeometry();
                const pos = new Float32Array(500 * 3);
                for (let i = 0; i < 500; i++) {
                    const h = Math.random() * 300 - 150;
                    const r = (h + 150) * 0.5;
                    const a = Math.random() * Math.PI * 2;
                    pos[i * 3] = r * Math.cos(a);
                    pos[i * 3 + 1] = h;
                    pos[i * 3 + 2] = r * Math.sin(a);
                }
                galaxiesGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const galaxies = new THREE.Points(galaxiesGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 1.5 }));
                activeGroup.add(galaxies);

                activeGroup.add(createLabel("CURRENT ERA", 160));
                activeGroup.add(createLabel("BIG BANG", -160));
            } else if (mode === 'singularity') {
                // THE SINGULARITY (Interstellar Style)
                const core = new THREE.Mesh(
                    new THREE.SphereGeometry(20, 64, 64),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                activeGroup.add(core);

                // Accretion Disk Layers
                for (let i = 0; i < 4; i++) {
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(35 + i * 15, 0.5 - i * 0.1, 16, 100),
                        new THREE.MeshBasicMaterial({
                            color: i === 0 ? 0x00ffff : 0x0088ff,
                            transparent: true,
                            opacity: 0.6 - i * 0.1,
                            blending: THREE.AdditiveBlending
                        })
                    );
                    ring.rotation.x = Math.PI / 2;
                    ring.userData.speed = 4 - i * 0.8;
                    ring.name = "acc_disk_" + i;
                    activeGroup.add(ring);
                }

                // Vertical Lensing Ring
                const halo = new THREE.Mesh(
                    new THREE.TorusGeometry(60, 0.4, 16, 100),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending })
                );
                halo.name = "lensing_halo";
                activeGroup.add(halo);

                activeGroup.add(createLabel("EVENT HORIZON", 120));
                activeGroup.add(createLabel("GRAVITY WELL", -120));
            }

            if (window.globalDrag) {
                activeGroup.rotation.y = window.globalDrag.rotationY;
                activeGroup.rotation.x = window.globalDrag.rotationX;
            }

            scene.add(activeGroup);
            updateTheoryHeader(theories[mode].name, theories[mode].description);
            updateInfoPanel(theories[mode]);
            updateInfoModalContent(theories[mode]);
            updateParamDisplay();
        }

        function updateSim() {
            const dt = 0.01 * timeScale;
            time += dt;

            if (currentMode === 'worldline') {
                const helix = activeGroup.getObjectByName("helix");
                const nowLabel = activeGroup.getObjectByName("nowLabel");
                if (helix && nowLabel) {
                    const points = [];
                    const count = 200;
                    const r = p1 / 2;
                    for (let i = 0; i < count; i++) {
                        const h = (i / count) * 300 - 150;
                        const a = (i / 10) * Math.PI + time * 5;
                        points.push(new THREE.Vector3(r * Math.cos(a), h, r * Math.sin(a)));
                    }
                    helix.geometry.setFromPoints(points);
                    nowLabel.position.copy(points[100]); // Pick middle as "Now"
                }
            } else if (currentMode === 'emc2') {
                for (let i = 0; i < 3; i++) {
                    const ring = activeGroup.getObjectByName("ring_" + i);
                    if (ring) {
                        ring.scale.setScalar(1 + Math.sin(time * 2 + i) * 0.1);
                        ring.material.opacity = 0.3 + Math.sin(time * 3 + i) * 0.2;
                    }
                }
            } else if (currentMode === 'gravity') {
                const grid = activeGroup.getObjectByName("grid");
                const attr = activeGroup.getObjectByName("attractor");
                if (grid && attr) {
                    attr.position.y = Math.sin(time) * 20;
                    const pos = grid.geometry.attributes.position;
                    const mass = p1 / 50;
                    for (let i = 0; i < pos.count; i++) {
                        const px = pos.getX(i);
                        const pz = pos.getZ(i);
                        const d = Math.sqrt(px * px + pz * pz);
                        const h = - (mass * 50) / (d / 10 + 1);
                        pos.setY(i, h);
                    }
                    pos.needsUpdate = true;
                }
            } else if (currentMode === 'funnel') {
                const funnel = activeGroup.getObjectByName("funnel");
                if (funnel) {
                    const scale = 1 + (p1 / 100 - 1) * 0.5;
                    funnel.scale.set(scale, 1, scale);
                }
            } else if (currentMode === 'singularity') {
                activeGroup.children.forEach(c => {
                    if (c.name && c.name.startsWith("acc_disk_")) {
                        c.rotation.z += 0.01 * c.userData.speed * (p1 / 100 + 0.5);
                        c.scale.setScalar(1 + Math.sin(time * 2) * 0.03);
                    }
                });
                const halo = activeGroup.getObjectByName("lensing_halo");
                if (halo) {
                    halo.rotation.y = time * 0.5;
                    halo.rotation.x = Math.sin(time * 0.3) * 0.2;
                }
            }
        }

        function animate(drag, zoomControl) {
            requestAnimationFrame(() => animate(drag, zoomControl));
            updateSim();

            const stars = scene.getObjectByName("global_starfield");
            updateStarField(stars, time, drag);

            const targetZoom = zoomControl.zoom;
            smoothedZoom += (targetZoom - smoothedZoom) * 0.1;
            camera.position.z = 400 / smoothedZoom;

            const zSlider = document.getElementById('zoom-slider');
            if (zSlider && !zSlider.matches(':active')) zSlider.value = smoothedZoom * 100;
            document.getElementById('zoom-value').innerText = smoothedZoom.toFixed(1) + '×';

            if (activeGroup) {
                drag.update();
                activeGroup.rotation.y = drag.rotationY;
                activeGroup.rotation.x = drag.rotationX;
            }

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>