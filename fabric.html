<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="icons/icon-180.png">
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Fabric of Cosmos | Eternalism & Block Time</title>
    <link rel="stylesheet" href="components/shared.css">
    <script src="components/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: transparent;
        }

        .theory-tab.logic {
            color: #ffaa00;
        }

        .theory-tab.logic.active {
            background: rgba(255, 170, 0, 0.15);
            color: #ffaa00;
            box-shadow: inset 0 0 15px rgba(255, 170, 0, 0.2);
        }

        .manifold-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.03;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 255, 255, 0.05) 1px, rgba(0, 255, 255, 0.05) 2px);
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="three-container"></div>

    <div class="manifold-glitch"></div>
    <div id="nav-container"></div>

    <div class="theory-nav-header">
        <div class="theory-nav-title">EXPLORE MODES</div>
        <div class="theory-nav-desc">Choose a simulation mode below to change the visualization</div>
    </div>
    <div class="theory-tabs">
        <button class="theory-tab logic active" data-theory="loaf">The 4D Loaf</button>
        <button class="theory-tab" data-theory="river">The River</button>
        <button class="theory-tab" data-theory="entropy">Entropy Arrow</button>
        <button class="theory-tab" data-theory="expansion">Metric Expansion</button>
    </div>

    <div class="params-panel">
        <div class="param-group">
            <div class="param-label" id="param1-label">Lorentz Boost</div>
            <div class="param-value" id="param1-value">0.0c</div>
            <input type="range" class="param-slider" id="param1-slider" min="-90" max="90" value="0">
        </div>
        <div class="param-group">
            <div class="param-label">Simulation Speed</div>
            <div class="param-value" id="speed-value">1.0×</div>
            <input type="range" class="param-slider" id="speed-slider" min="0" max="300" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Simulated Depth</div>
            <div class="param-value" id="zoom-value">1.0×</div>
            <input type="range" class="param-slider" id="zoom-slider" min="30" max="300" value="100">
        </div>
    </div>

    <div class="info-panel">
        <div class="theory-name" id="theory-name">Eternalist Block Universe</div>
        <div class="theory-year" id="theory-year">Minkowski Space-Time</div>
        <div class="equation-box">
            <div class="equation-label">World-Line Metric</div>
            <div class="equation" id="equation">ds² = -c²dt² + dx² + dy² + dz²</div>
        </div>
        <div class="theory-facts" id="theory-facts"></div>
    </div>

    <button class="info-btn" id="info-btn">ⓘ</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header">
            <span class="info-modal-title">Temporal Ontology Protocol</span>
            <button class="info-modal-close" id="info-close">×</button>
        </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Axiomatic Description</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Lorentz Invariants</div>
                <ul id="info-concepts"></ul>
            </div>
            <div class="info-section">
                <div class="info-section-title">Mathematical Backbone</div>
                <p id="info-equation-explanation"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Deep Field Physics</div>
                <p id="info-physics"></p>
            </div>
        </div>
    </div>

    <script>
        // ============ CORE SETUP ============
        document.getElementById('nav-container').innerHTML = renderMainNav('fabric');

        let scene, camera, renderer, currentMode = 'loaf';
        let loafGroup, riverGroup, entropyGroup, expansionGroup;
        let p1 = 0, zoom = 1.0, time = 0, timeScale = 1.0;
        let targetZoom = 1.0, smoothedZoom = 1.0;

        const theories = {
            'loaf': {
                name: 'The 4D Loaf', year: 'Special Relativity',
                equation: 'ds² = -c²dt² + dx²',
                equationExpl: 'The 1D+1D Minkowski metric. Similar to a slice of bread in a loaf, your velocity determines the angle of your Now in the 4D spacetime continuum.',
                facts: [{ text: 'Sliceable', status: 'yes' }, { text: 'Relative Now', status: 'yes' }],
                description: 'Brian Greene\'s "Bread Loaf" analogy. The universe exists as a static block. Your velocity determines the angle at which you slice this block to define "Now." Movement through space is literally a rotation of your temporal axis.',
                concepts: [
                    { term: 'Simultaneity', definition: 'The "Now" slice shifts based on orientation in the block.' },
                    { term: 'Eternalism', definition: 'All parts of the loaf are equally real at all times.' }
                ],
                physics: 'Lorentz transformations physically rotate your "plane of simultaneity" within the 4D manifold. There is no universal clock. This proves reality is a static geometric object, the perfect substrate for resonant waveforms.'
            },
            'river': {
                name: 'The Frozen River', year: 'Static Manifold',
                equation: '∇·J = 0 (Static Flux)',
                equationExpl: 'The continuity equation for static flux. It represents the "Frozen River" view where the timeline is a pre-existing vector field with no dynamic flow.',
                facts: [{ text: 'Flow = Illusion', status: 'yes' }, { text: 'Immutable', status: 'yes' }],
                description: 'Critique of the "Flow" metaphor. If time flows, it must flow *with respect* to something else (hypertime?), leading to infinite regress. The "Frozen River" model posits that spacetime is a static, pre-existing manifold.',
                concepts: [
                    { term: 'Worldline', definition: 'The fixed path of an object through the manifold.' },
                    { term: 'Cursor of Now', definition: 'The narrow window of experience sliding along the worldline.' }
                ],
                physics: 'General Relativity treats spacetime as a field equation solution. This static field is the non-local medium through which Waveism propagates.'
            },
            'entropy': {
                name: 'The Entropy Arrow', year: 'Second Law',
                equation: 'S = k_B ln Ω',
                equationExpl: 'The Boltzmann entropy formula. It links the macroscopic state of a system to the number of microstates (Ω), explaining why order naturally decays.',
                facts: [{ text: 'Irreversible', status: 'yes' }, { text: 'Axiomatic Heat', status: 'yes' }],
                description: 'Order decays into noise. The "future" is simply the direction of statistically higher entropy. Time\'s arrow is the dissipation of initial low-entropy tension into the vacuum.',
                concepts: [
                    { term: 'Phase Space', definition: 'The map of all possible configurations of the system.' },
                    { term: 'Degradation', definition: 'The irreversible transition from order to statistical chaos.' }
                ],
                physics: 'Entropy is the decoherence of wave-functions. Time is the measurement of this phase-drift from order to noise.'
            },
            'expansion': {
                name: 'Metric Expansion', year: 'Hubble-Lemaître',
                equation: 'a(t) ∝ t^(2/3)',
                equationExpl: 'The scale factor evolution for a matter-dominated universe. It describes how the physical distance between non-interacting points grows over time.',
                facts: [{ text: 'Fabric Stretching', status: 'yes' }, { text: 'Non-Local', status: 'yes' }],
                description: 'Galaxies aren\'t moving *through* space; space itself is stretching between them. Hubble\'s Law quantifies the expansion of the metric field itself.',
                concepts: [
                    { term: 'Hubble Flow', definition: 'The rate at which volume increases between distant points.' },
                    { term: 'Metric Scaling', definition: 'The scaling factor a(t) that describes the size of the universe.' }
                ],
                physics: 'Expansion is the literal "tuning" of the universal cavity. As the metric grows, the fundamental resonant frequencies of the cosmos shift.'
            }
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5); // Centered
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('three-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x00ffff, 2, 100);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            createStarField(scene); // Add global starfield

            setupGraphics();

            // Input handlers
            initParamSlider('param1-slider', 'param1-value', {
                onChange: v => { p1 = v / 100; updateParamDisplay(); },
                formatter: v => v
            });
            initParamSlider('speed-slider', 'speed-value', {
                onChange: v => timeScale = v / 100,
                formatter: v => (v / 100).toFixed(1) + '×'
            });
            initParamSlider('zoom-slider', 'zoom-value', {
                onChange: v => { if (zoomControl) zoomControl.zoom = v / 100; },
                formatter: v => (v / 100).toFixed(1) + '×'
            });

            // Interactive Handlers
            const drag = initDragRotation(renderer.domElement, {
                initialRotationX: 0.4
            });
            window.globalDrag = drag;
            const zoomControl = initZoomHandler(renderer.domElement, { initialZoom: 1.0 });

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (window.clickPrevented) { window.clickPrevented = false; return; }
                drag.autoRotate = !drag.autoRotate;
            });

            initTheoryTabs(mode => switchMode(mode));
            initInfoModal();
            switchMode('loaf');
            animate(drag, zoomControl);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updateParamDisplay() {
            const valEl = document.getElementById('param1-value');
            if (currentMode === 'loaf') valEl.innerText = (p1 * 90).toFixed(0) + '°';
            else if (currentMode === 'river') valEl.innerText = (p1 * 100).toFixed(0) + '%';
            else if (currentMode === 'entropy') valEl.innerText = (p1 * 100).toFixed(0) + '%';
            else if (currentMode === 'expansion') valEl.innerText = (1 + p1 * 5).toFixed(1) + '×';
        }

        function setupGraphics() {
            // mode: LOAF (Refined)
            loafGroup = new THREE.Group();
            const sliceGeo = new THREE.BoxGeometry(2.5, 1.5, 0.02);
            for (let i = 0; i < 10; i++) {
                const isNow = i === 5;
                const mat = new THREE.MeshPhongMaterial({
                    color: isNow ? 0x00ffff : 0x004466,
                    transparent: true,
                    opacity: isNow ? 0.35 : 0.05,
                    wireframe: !isNow,
                    emissive: isNow ? 0x00ffff : 0x000000,
                    emissiveIntensity: isNow ? 0.5 : 0
                });
                const slice = new THREE.Mesh(sliceGeo, mat);
                slice.position.z = (i - 5) * 0.3;
                if (isNow) slice.name = "nowSlice";
                loafGroup.add(slice);
            }

            // mode: RIVER
            riverGroup = new THREE.Group();
            riverGroup.position.y = 0.5; // Added this line
            const riverGrid = new THREE.GridHelper(20, 40, 0x00ffff, 0x222222);
            riverGrid.rotation.x = Math.PI / 2;
            riverGroup.add(riverGrid);
            const cursor = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            cursor.name = "cursor";
            riverGroup.add(cursor);

            // mode: ENTROPY
            entropyGroup = new THREE.Group();
            const pCount = 2000;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(pCount * 3);
            const pOriginals = new Float32Array(pCount * 3);
            for (let i = 0; i < pCount * 3; i++) {
                const val = (Math.random() - 0.5) * 1.5;
                pPos[i] = val;
                pOriginals[i] = val;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.015, transparent: true, opacity: 0.8 });
            const points = new THREE.Points(pGeo, pMat);
            points.name = "entropyPoints";
            points.userData.originals = pOriginals;
            entropyGroup.add(points);

            // mode: EXPANSION
            expansionGroup = new THREE.Group();
            const mainSphere = new THREE.Mesh(
                new THREE.SphereGeometry(1, 32, 24),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.15 })
            );
            expansionGroup.add(mainSphere);
            for (let i = 0; i < 60; i++) {
                const gal = new THREE.Mesh(new THREE.SphereGeometry(0.04), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                gal.userData.pos = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                );
                gal.position.copy(gal.userData.pos);
                expansionGroup.add(gal);
            }
        }

        function switchMode(mode) {
            currentMode = mode;
            scene.children.forEach(c => { if (c.type === "Group") scene.remove(c); });

            let activeGroup;
            if (currentMode === 'loaf') activeGroup = loafGroup;
            else if (currentMode === 'river') activeGroup = riverGroup;
            else if (currentMode === 'entropy') activeGroup = entropyGroup;
            else if (currentMode === 'expansion') activeGroup = expansionGroup;

            if (activeGroup) {
                activeGroup.position.y = 0.8;
                if (window.globalDrag) {
                    activeGroup.rotation.y = window.globalDrag.rotationY;
                    activeGroup.rotation.x = window.globalDrag.rotationX;
                }
                scene.add(activeGroup);
            }
            updateTheoryHeader(theories[mode].name, theories[mode].description);
            updateInfoPanel(theories[mode]);
            updateInfoModalContent(theories[mode]);
            updateParamDisplay();
        }

        function animate(drag, zoomControl) {
            requestAnimationFrame(() => animate(drag, zoomControl));
            time += 0.01 * timeScale;

            const stars = scene.getObjectByName("global_starfield");
            updateStarField(stars, time, drag);

            // Interaction State
            targetZoom = zoomControl.zoom;
            smoothedZoom += (targetZoom - smoothedZoom) * 0.1;
            camera.position.z = 5 / smoothedZoom;

            // Sync Slider
            const zSlider = document.getElementById('zoom-slider');
            if (zSlider && !zSlider.matches(':active')) zSlider.value = smoothedZoom * 100;
            document.getElementById('zoom-value').innerText = smoothedZoom.toFixed(1) + '×';

            const activeGroup = scene.children.find(c => c.type === "Group");

            if (activeGroup) {
                drag.update();
                activeGroup.rotation.y = drag.rotationY;
                activeGroup.rotation.x = drag.rotationX;

                if (currentMode === 'loaf') {
                    const now = activeGroup.getObjectByName("nowSlice");
                    if (now) {
                        now.rotation.y = p1 * 1.6; // Tilt
                        now.position.z = Math.sin(time) * 1.5; // Flow
                    }
                } else if (currentMode === 'river') {
                    const cursor = activeGroup.getObjectByName("cursor");
                    if (cursor) {
                        cursor.position.z = (p1 - 0.5) * 8;
                        cursor.position.y = Math.sin(time * 3) * 0.1;
                    }
                } else if (currentMode === 'entropy') {
                    const points = activeGroup.getObjectByName("entropyPoints");
                    if (points) {
                        const pos = points.geometry.attributes.position.array;
                        const orig = points.userData.originals;
                        const decay = p1 * 5;
                        for (let i = 0; i < pos.length; i++) {
                            pos[i] = orig[i] + (Math.random() - 0.5) * decay;
                        }
                        points.geometry.attributes.position.needsUpdate = true;
                    }
                } else if (currentMode === 'expansion') {
                    const scale = 1 + p1 * 5;
                    activeGroup.children.forEach(child => {
                        if (child.userData.pos) {
                            child.position.copy(child.userData.pos).multiplyScalar(scale);
                            child.scale.set(1 / scale, 1 / scale, 1 / scale);
                        } else {
                            child.scale.set(scale, scale, scale);
                        }
                    });
                }
            }

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>