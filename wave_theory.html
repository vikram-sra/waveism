<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="icons/icon-180.png">
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Epistemic Topology | The Unified Field</title>

    <link rel="stylesheet" href="components/shared.css">
    <script src="components/shared.js"></script>
    <script src="components/hamiltonian_physics.js"></script>
    <script src="components/physics_ontology.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Epistemic Specific Overrides */
        body {
            overflow: hidden;
        }

        #wave-canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 5;
            cursor: grab;
            background: transparent !important;
        }

        #epistemic-card {
            position: fixed;
            top: 140px;
            right: 20px;
            width: 280px;
            max-width: 320px;
            background: rgba(5, 8, 12, 0.75);
            border: 1px solid rgba(100, 150, 200, 0.2);
            border-left: 2px solid rgba(150, 180, 220, 0.5);
            padding: 12px 16px;
            color: #c0d0e0;
            font-family: 'Inter', sans-serif;
            z-index: 50;
            display: none;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            border-radius: 4px;
        }

        #epistemic-card h2 {
            font-family: 'JetBrains Mono';
            color: rgba(180, 200, 230, 0.9);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 6px;
            border-bottom: 1px solid rgba(100, 150, 200, 0.15);
            padding-bottom: 4px;
            font-weight: 500;
        }

        #epistemic-card p {
            font-size: 0.7rem;
            line-height: 1.5;
            color: rgba(140, 160, 180, 0.85);
            margin-bottom: 0;
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>

    <canvas id="wave-canvas"></canvas>

    <div id="nav-container"></div>

    <div class="theory-tabs">
        <button class="theory-tab substrate active" data-theory="map">Epistemic Map</button>
        <button class="theory-tab" data-theory="qft">QFT Foundation</button>
        <button class="theory-tab" data-theory="pilot">Pilot Wave</button>
        <button class="theory-tab" data-theory="neural">Neural Synchrony</button>
        <button class="theory-tab" data-theory="social">Social Resonance</button>
        <button class="theory-tab" data-theory="reality">Reality Perception</button>
    </div>

    <!-- CHRONOS CONTROL DECK (Top Left) -->
    <div class="params-panel">
        <div class="param-group">
            <div class="param-label">CHRONOS</div>
            <input type="range" class="param-slider time-travel" id="time-slider" min="-60" max="60" value="0"
                step="0.1">
            <div class="param-value" id="time-val">NOW</div>
        </div>

        <div class="param-group" id="eq-group">
            <div class="param-label" id="eq-name">GRAVITY</div>
            <input type="range" class="param-slider" id="eq-slider" min="0" max="100" value="50">
            <div class="param-value" id="eq-val">50%</div>
        </div>

        <div class="param-group">
            <div class="param-label">MAGNIFY</div>
            <input type="range" class="param-slider" id="zoom-slider" min="10" max="400" value="100">
            <div class="param-value" id="zoom-value">1.0×</div>
        </div>
    </div>

    <div class="info-panel">
        <div id="mini-physics-monitor"
            style="display: flex; gap: 15px; font-family: 'JetBrains Mono'; font-size: 0.55rem; color: rgba(0, 255, 255, 0.6); margin-bottom: 8px; letter-spacing: 0.1em; text-transform: uppercase;">
            <div style="display: none;" id="monitor-active-indicator">PHYSICS: ACTIVE</div>
            <span>KE: <span id="kinetic-energy" style="color: #fff;">0.00</span></span>
            <span>PE: <span id="potential-energy" style="color: #fff;">0.00</span></span>
            <span>TOTAL: <span id="total-energy" style="color: #fff;">0.00</span></span>
            <span>DRIFT: <span id="energy-drift" style="color: #00ff00;">0.00%</span></span>
        </div>
        <div class="theory-name" id="theory-name">Epistemic Topology</div>
        <div class="theory-year" id="theory-year">Unified Field Ontology</div>
        <div class="equation-box">
            <div class="equation-label">Formalism</div>
            <div class="equation" id="equation">G = (V, E, Φ)</div>
        </div>
    </div>

    <button class="info-btn" id="info-btn">ⓘ</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header"> <span class="info-modal-title">Ontological Report</span> <button
                class="info-modal-close" id="info-close">×</button> </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Abstract</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Governing Physics</div>
                <p id="info-physics" style="font-family:'JetBrains Mono'; font-size:0.75rem; color:#00ffff;"></p>
            </div>
            <div id="info-quote-section" class="info-section"></div>
            <div class="info-section">
                <div class="info-section-title">Key Concepts</div>
                <ul id="info-concepts"></ul>
            </div>
        </div>
    </div>

    <div id="epistemic-card">
        <h2 id="card-title"></h2>
        <p id="card-body"></p>
    </div>

    <!-- Energy Monitor Panel (Removed original bulky popup) -->

    <script>
        document.getElementById('nav-container').innerHTML = renderMainNav('wave_theory');

        let currentMode = 'map';
        let zoomLevel = 0.5;
        let simTime = 0;
        let timeOffset = 0;
        let eqParam = 0.5;
        const modeParams = { map: 0.5, qft: 0.5, pilot: 0.5, neural: 0.5, social: 0.5 };

        initGlobalStarField('background-stars');

        let map3DState = null;
        let canvas,
            ctx,
            width,
            height,
            visualCenterY;
        let zoomHandler,
            rotationHandler;
        let mouseX = 0,
            mouseY = 0;
        let hoveredNode = null;

        // Interaction State
        let isDraggingNode = false;
        let isPanning = false;
        let draggedNode = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let panOffset = { x: 0, y: 0 };

        let dragStartPos = {
            x: 0, y: 0
        }

            ;

        let nodeDragOffset = {
            x: 0, y: 0, z: 0
        }

            ;

        // Debug visualization toggles (press F for force vectors, V for velocity, H for influence field)
        let showForceVectors = false;
        let showVelocityField = false;
        let showInfluenceField = false;

        // Physics-based ontology loaded from physics_ontology.js
        const ontology = initializeLayeredPositions(PHYSICS_ONTOLOGY);

        // Set radius for all nodes BEFORE Hamiltonian system creation
        ontology.nodes.forEach(node => {
            if (!node.r) node.r = 18; // Default radius for visibility
        });

        const theories = {
            'map': {
                name: 'Epistemic Topology',
                param: 'GRAVITY',
                equation: 'G = (E, I, S)',
                physics: 'Scale-Invariant Ontology',
                description: 'Causal mapping of first principles. What we perceive as "physical form" is a scale-dependent reconstruction of the underlying substrate. At the human scale (10^0m), we see solid objects due to electromagnetic repulsion; at the Planck scale (10^-35m), these dissolve into topological fluctuations. Reality is a multi-layered manifold where different physics emerge at different scales.',
                quote: { text: "The universe is not only stranger than we imagine, it is stranger than we can imagine. What we see as a solid world is only the residue of a deeper wave interference.", author: "Werner Heisenberg" },
                concepts: [
                    { term: 'Scale Dependency', definition: 'Physical laws (General Relativity vs. QFT) are effective theories valid only within specific magnitude ranges.' },
                    { term: 'Emergent Form', definition: 'Solidity is an emergent property of phase-locked wave functions, not an intrinsic quality of matter.' },
                    { term: 'The Substrate', definition: 'The non-local foundation from which space, time, and causality emerge via quantum decoherence.' }
                ]
            }

            ,
            'qft': {

                name: 'Quantum Field',
                param: 'EXCITATION',
                equation: 'ℒ = ½(∂φ)² - V(φ)',
                physics: 'Electrodynamics Protocol',
                description: 'Energy density field where particles are localized wave-packet excitations. The "Grid" represents the vacuum lattice.',
                quote: { text: "The field is the only reality.", author: "Albert Einstein" },
                concepts: [{
                    term: 'Zero-Point', definition: 'The non-zero energy state of the fundamental vacuum.'
                }

                    ,
                {
                    term: 'Excitations', definition: 'Localized peaks in field amplitude perceived as particles.'
                }

                ]
            }

            ,
            'pilot': {

                name: 'Pilot Wave',
                param: 'GUIDANCE',
                equation: 'v = ∇S/m',
                physics: 'Bohmian Fluid Dynamics',
                description: 'Particle guided by a physical pilot wave. The wave informs the particle of global conditions instantly.',
                quote: { text: "No cat has ever been both dead and alive.", author: "John Bell" },
                concepts: [{
                    term: 'Non-Locality', definition: 'Instantaneous wave-particle information exchange.'
                }

                    ,
                {
                    term: 'Equilibrium', definition: 'State where particle distribution matches field intensity.'
                }

                ]
            }

            ,
            'neural': {

                name: 'Neural Sync',
                param: 'COHERENCE',
                equation: 'Δw = η·pre·post',
                physics: 'Oscillatory Binding',
                description: 'Consciousness as 3D phase-locked resonance. 40Hz temporal binding across cerebral regions.',
                quote: { text: "What we call 'I' is just a door to the universe.", author: "Alan Watts" },
                concepts: [{
                    term: 'Binding', definition: 'Unified perception from spatial-temporal synchrony.'
                }

                    ,
                {
                    term: 'Coherence', definition: 'The degree of phase-locking between neural nodes.'
                }

                ]
            }

            ,
            'social': {

                name: 'Social Resonance',
                param: 'INFLUENCE',
                equation: 'R0 > 1',
                physics: 'Network Contagion',
                description: 'Spherical influence fields spreading memetic information through the social manifold.',
                quote: { text: "We are caught in an inescapable network of mutuality.", author: "Martin Luther King Jr." },
                concepts: [{
                    term: 'Influence', definition: 'The reach of a memetic signal within the network.'
                }

                    ,
                {
                    term: 'Contagion', definition: 'The phase-driven spread of information via resonance.'
                }

                ]
            }

            ,
            'reality': {

                name: 'Perception Filter', param: 'COGNITION', equation: 'I(X; Y) ≥ Min', physics: 'Interface Theory',
                description: 'Our senses provide a simplified "desktop interface" optimized for survival, not truth. We perceive a fitness reconstruction of the substrate.',
                quote: { text: "If the doors of perception were cleansed every thing would appear to man as it is, Infinite.", author: "William Blake" },
                concepts: [{
                    term: 'Interface', definition: 'The simplified perceptual model of the complex substrate.'
                }

                    ,
                {
                    term: 'Fitness Payoff', definition: 'Optimization for survival rather than objective accuracy.'
                }

                ]
            }
        }

            ;

        function init() {
            initOrbUI();
            initInfoModal();
            initTheoryTabs(switchMode);
            canvas = document.getElementById('wave-canvas');
            ctx = canvas.getContext('2d');

            // Low-resolution canvas for MAXIMUM SPEED
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            width = rect.width;
            height = rect.height;
            visualCenterY = height / 2;

            initCanvasResize(canvas, (w, h) => {
                canvas.width = w;
                canvas.height = h;
                width = w; height = h; visualCenterY = h / 2;
            });

            zoomHandler = initZoomHandler(canvas, {
                initialZoom: 0.5, minZoom: 0.1, maxZoom: 10.0
            });

            rotationHandler = initDragRotation(canvas, {
                initialRotationX: 0.6, initialRotationY: 0.5, autoRotate: false
            });

            // Mouse tracking for hover detection and node dragging
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;

                const dx = mouseX - lastMouseX;
                const dy = mouseY - lastMouseY;

                // Handle "Elastic Drag" (Pulling the network)
                if (isDraggingNode && draggedNode && map3DState) {
                    e.preventDefault();

                    const effectiveScale = (draggedNode.scale || 0.5) * zoomLevel;
                    const moveScale = Math.min(5.0, effectiveScale > 0.01 ? 1.0 / effectiveScale : 1.0);

                    const ry = rotationHandler ? rotationHandler.rotationY : 0;
                    const cosY = Math.cos(ry);
                    const sinY = Math.sin(ry);

                    const moveX = dx * moveScale;
                    const moveY = dy * moveScale;

                    if (!isNaN(moveX) && !isNaN(moveY)) {
                        draggedNode.position.x += moveX * cosY;
                        draggedNode.position.z -= moveX * sinY;
                        draggedNode.position.y -= moveY;

                        // Range clamping to prevent "Infinite Drift"
                        draggedNode.position.x = Math.max(-2000, Math.min(2000, draggedNode.position.x));
                        draggedNode.position.y = Math.max(-2000, Math.min(2000, draggedNode.position.y));
                        draggedNode.position.z = Math.max(-2000, Math.min(2000, draggedNode.position.z));
                    }

                    draggedNode.velocity = { x: 0, y: 0, z: 0 };
                }
                else if (isPanning) {
                    if (!isNaN(dx) && !isNaN(dy) && Math.abs(dx) < 500 && Math.abs(dy) < 500) {
                        panOffset.x += dx;
                        panOffset.y += dy;
                    }
                }

                lastMouseX = mouseX;
                lastMouseY = mouseY;
            });

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                lastMouseX = e.clientX - rect.left;
                lastMouseY = e.clientY - rect.top;

                // Manual Drag and Pan removed from Epistemic Map per request
                // Drag Rotation still active via rotationHandler
            });

            // Node drag end
            canvas.addEventListener('mouseup', (e) => {
                if (isDraggingNode) {
                    if (draggedNode) draggedNode.isFixed = false;
                    isDraggingNode = false;
                    draggedNode = null;
                }
                isPanning = false;
                canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
            });

            const tSlider = document.getElementById('time-slider');
            const tVal = document.getElementById('time-val');
            const eSlider = document.getElementById('eq-slider');
            const eVal = document.getElementById('eq-val');
            const zSlider = document.getElementById('zoom-slider');
            const zVal = document.getElementById('zoom-value');

            tSlider.addEventListener('input', e => {
                timeOffset = parseFloat(e.target.value);

                if (Math.abs(timeOffset) < 0.5) {
                    tVal.innerText = 'NOW'; tVal.style.color = '#fff';
                } else if (timeOffset < 0) {
                    tVal.innerText = `T${timeOffset.toFixed(1)}s`; tVal.style.color = '#ff4466';
                } else {
                    tVal.innerText = `T+${timeOffset.toFixed(1)}s`; tVal.style.color = '#00ffff';
                }
            });

            eSlider.addEventListener('input', e => {
                eqParam = e.target.value / 100;
                modeParams[currentMode] = eqParam;
                eVal.innerText = Math.round(eqParam * 100) + '%';
            });

            zSlider.addEventListener('input', e => {
                zoomLevel = e.target.value / 100;
                if (zoomHandler) zoomHandler.zoom = zoomLevel;
                zVal.innerText = zoomLevel.toFixed(1) + '×';
            });

            // Debug visualization keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'f') {
                    showForceVectors = !showForceVectors;
                    console.log('Force vectors:', showForceVectors ? 'ON' : 'OFF');
                }

                if (e.key.toLowerCase() === 'v') {
                    showVelocityField = !showVelocityField;
                    console.log('Velocity field:', showVelocityField ? 'ON' : 'OFF');
                }

                if (e.key.toLowerCase() === 'h') {
                    showInfluenceField = !showInfluenceField;
                    console.log('Influence field:', showInfluenceField ? 'ON' : 'OFF');
                }
            });

            switchMode('map');
            animate();
        }

        function switchMode(mode) {
            modeParams[currentMode] = eqParam;
            currentMode = mode;
            eqParam = modeParams[mode];
            document.getElementById('eq-slider').value = eqParam * 100;
            document.getElementById('eq-val').innerText = Math.round(eqParam * 100) + '%';

            if (mode !== 'map') {
                zoomLevel = (mode === 'qft') ? 0.5 : 0.5; // Global 0.5x standard
                if (zoomHandler) zoomHandler.zoom = zoomLevel;
                document.getElementById('zoom-slider').value = zoomLevel * 100;
                document.getElementById('zoom-value').innerText = zoomLevel.toFixed(1) + "×";
            }

            const t = theories[mode] || {
                name: mode, param: 'PARAM'
            }

                ;
            updateInfoPanel(t);
            updateInfoModalContent(t);
            document.getElementById('eq-name').innerText = t.param || 'PARAM';

            if (mode === 'map') {
                canvas.style.opacity = '1';
                if (!map3DState) initMap3D();
            }

            else {
                canvas.style.opacity = '1';
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                // Reset unique states
                if (mode === 'pilot') pilotState3D.particles = [];
            }
        }

        // ============ 3D EPISTEMIC MAP INITIALIZATION (HAMILTONIAN) ============
        function initMap3D() {

            // Create Hamiltonian system
            const hamiltonianSystem = new HamiltonianSystem({
                k_coulomb: 1500,
                k_spring: 0.1,
                k_damping: 0.03
            });

            // Add all nodes from ontology
            ontology.nodes.forEach(node => {
                hamiltonianSystem.addNode(node);
            });

            // Add all links
            ontology.links.forEach(link => {
                hamiltonianSystem.addLink(link.source, link.target, {
                    label: link.label,
                    type: link.type,
                    restLength: link.restLength || 120,
                    stiffness: link.stiffness || 0.1,
                    informationFlow: link.informationFlow || 0,
                    channelCapacity: link.channelCapacity || 1.0
                });
            });

            map3DState = {

                hamiltonian: hamiltonianSystem,
                nodes: hamiltonianSystem.nodes,
                links: hamiltonianSystem.links,
                initialized: true,
                energyDisplay: {
                    visible: false
                }
            }

                ;

            // Set radius for all nodes (needed for rendering spheres)
            map3DState.nodes.forEach(node => {
                if (!node.r) node.r = 18; // Default radius for visibility
            });
        }

        // ============ 3D GRAPH PHYSICS UPDATE (HAMILTONIAN) ============
        function updateMap3D(deltaTime) {
            if (!map3DState || !map3DState.hamiltonian) return;

            const dt = Math.min(deltaTime, 0.016); // Cap at 60fps

            // Update Hamiltonian system with gravity parameter
            map3DState.hamiltonian.update(dt, {
                gravityStrength: eqParam * 0.05,
                enableDamping: true
            });
        }

        // ============ 3D GRAPH RENDERING (ENHANCED) ============
        function drawMap3D(t, rx, ry) {
            if (!map3DState) return;

            // Project all nodes to screen space using Hamiltonian node positions
            map3DState.nodes.forEach(node => {
                // Projection now independent of pan (pan applied via ctx.translate)
                const p = project3D(node.position.x, node.position.y, node.position.z, rx, ry, 0, 0, zoomLevel);
                node.px = isNaN(p.x) ? 0 : p.x;
                node.py = isNaN(p.y) ? 0 : p.y;
                node.pz = isNaN(p.z) ? 0 : p.z;
                node.scale = isNaN(p.scale) ? 1 : Math.max(0, p.scale);
            });

            // Sort nodes by depth (back to front for proper occlusion)
            const sortedNodes = [...map3DState.nodes].sort((a, b) => a.pz - b.pz);

            // Check for hover with smooth transition - increased radius
            let newHoveredNode = null;
            const hoverRadius = 70; // Much larger for easier interaction

            for (let i = sortedNodes.length - 1; i >= 0; i--) {
                const node = sortedNodes[i];
                // Mouse distance check accounts for both visual center AND pan offset
                const dx = mouseX - (node.px + width / 2 + panOffset.x);
                const dy = mouseY - (node.py + visualCenterY + panOffset.y);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < node.r * node.scale + hoverRadius) {
                    newHoveredNode = node;
                    break;
                }
            }

            // Smooth hover transition
            if (newHoveredNode !== hoveredNode) {
                hoveredNode = newHoveredNode;

                // Update cursor for drag affordance
                if (!isDraggingNode) {
                    canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
                }

                // Update info card
                const card = document.getElementById('epistemic-card');

                if (hoveredNode) {
                    document.getElementById('card-title').innerText = hoveredNode.label;
                    document.getElementById('card-body').innerText = hoveredNode.desc;
                    card.style.display = 'block';
                    setTimeout(() => card.style.opacity = '1', 10);
                } else {
                    card.style.opacity = '0';
                    setTimeout(() => {
                        if (!hoveredNode) card.style.display = 'none';
                    }, 300);
                }
            }

            // Render links first
            map3DState.links.forEach(link => {
                const isHighlighted = hoveredNode && (link.source === hoveredNode || link.target === hoveredNode);
                const avgZ = (link.source.pz + link.target.pz) / 2;
                const depthAlpha = Math.max(0.2, Math.min(0.8, (avgZ + 400) / 800));

                // GLOWING LINES
                const baseColor = isHighlighted ? '0, 255, 255' : '0, 255, 255';
                const alpha = isHighlighted ? 0.9 : depthAlpha;

                // Core Line
                ctx.lineWidth = isHighlighted ? 3 : 1.5;
                ctx.strokeStyle = `rgba(${baseColor}, ${alpha})`;
                ctx.globalCompositeOperation = 'lighter'; // Additive blending for glow

                ctx.beginPath();
                ctx.moveTo(link.source.px, link.source.py);
                ctx.lineTo(link.target.px, link.target.py);
                ctx.stroke();

                // Outer Glow (fainter, wider)
                if (isHighlighted || depthAlpha > 0.5) {
                    ctx.lineWidth = isHighlighted ? 8 : 4;
                    ctx.strokeStyle = `rgba(${baseColor}, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.moveTo(link.source.px, link.source.py);
                    ctx.lineTo(link.target.px, link.target.py);
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = 'source-over'; // Reset blending
            });

            // Enhanced information flow particles with directionality
            map3DState.links.forEach((link, linkIndex) => {
                const isHighlighted = hoveredNode && (link.source === hoveredNode || link.target === hoveredNode);
                const infoFlow = link.informationFlow || 0.5;
                const showParticles = isHighlighted || infoFlow > 0.3;

                if (showParticles) {
                    // Speed based on information flow rate
                    const speed = 0.3 + infoFlow * 0.7;
                    const flowProgress = (t * speed + linkIndex * 0.3) % 1;
                    const px = link.source.px + (link.target.px - link.source.px) * flowProgress;
                    const py = link.source.py + (link.target.py - link.source.py) * flowProgress;
                    const pz = link.source.pz + (link.target.pz - link.source.pz) * flowProgress;
                    const particleDepth = Math.max(0.3, Math.min(1, (pz + 400) / 800));

                    // Particle size based on information flow
                    const particleSize = 3 + infoFlow * 4;

                    // Color based on information type
                    let color = infoFlow > 0.7 ? '#00ffff' : infoFlow > 0.4 ? '#44ff88' : '#8888ff';

                    // Proper hex to RGB conversion
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);

                    const grad = ctx.createRadialGradient(px, py, 0, px, py, particleSize);

                    grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${particleDepth * 0.9})`);
                    grad.addColorStop(1, 'transparent');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';

                    // Directional arrow for higher info flow
                    if (infoFlow > 0.5) {
                        const arrowSize = 6;
                        const dx = link.target.px - link.source.px;
                        const dy = link.target.py - link.source.py;
                        const angle = Math.atan2(dy, dx);

                        ctx.save();
                        ctx.translate(px, py);
                        ctx.rotate(angle);

                        ctx.fillStyle = `rgba(255, 255, 255, ${particleDepth * 0.6})`;
                        ctx.beginPath();
                        ctx.moveTo(arrowSize, 0);
                        ctx.lineTo(-arrowSize / 2, -arrowSize / 2);
                        ctx.lineTo(-arrowSize / 2, arrowSize / 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                }
            });

            // Render nodes with enhanced effects
            sortedNodes.forEach(node => {
                const isHovered = node === hoveredNode;
                const x = node.px;
                const y = node.py;

                // MESH SPHERE RENDERING
                drawMeshSphere(ctx, x, y, node.r * node.scale, isHovered, node.color, t, rx, ry);

                // LABEL RENDERING
                if (node.scale > 0.4 || isHovered) {
                    let alphaValue = (node.scale - 0.4) * 2 + (isHovered ? 0.5 : 0);
                    if (isNaN(alphaValue)) alphaValue = 0;
                    ctx.globalAlpha = Math.max(0, Math.min(1, alphaValue));
                    ctx.font = `${isHovered ? 700 : 400} ${Math.max(10, 10 * node.scale)}px "JetBrains Mono", monospace`;
                    ctx.fillStyle = isHovered ? '#ffffff' : `rgba(0, 255, 255, 0.8)`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.label, x, y + node.r * node.scale + 15 * node.scale);
                    ctx.globalAlpha = 1.0;
                }
            });

            // ============ DEBUG VISUALIZATIONS ============
            // (Restored debug visualizations if needed, currently omitted for cleaner code but structure is safe)
        }

        // Helper: Draw Clean Geometric Mesh Sphere
        function drawMeshSphere(ctx, x, y, radius, isHovered, colorHex = '#00ffff', t, rx, ry) {
            // EXTREME SAFETY: Skip if any critical value is NaN or radius is too small
            if (isNaN(radius) || radius <= 0.5 || isNaN(x) || isNaN(y)) return;

            const r = Math.max(1, radius);
            const steps = 4; // Sparse mesh (Lat/Long)

            ctx.save();
            ctx.translate(x, y);
            // Rotate the individual sphere slightly
            const rotation = isNaN(rx) ? 0 : (t * 0.2 + rx);
            ctx.rotate(rotation);

            const color = isHovered ? '#ffffff' : colorHex;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;

            // Draw Latitudes
            for (let i = 0; i < steps; i++) {
                const angle = (i / steps) * Math.PI;
                const ringR = Math.sin(angle) * r;
                if (isNaN(ringR) || ringR <= 0.5) continue;
                const yOff = Math.cos(angle) * r;

                ctx.beginPath();
                ctx.ellipse(0, yOff, ringR, Math.max(0.1, ringR * 0.3), 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw Longitudes
            for (let i = 0; i < steps; i++) {
                const rot = (i / steps) * Math.PI;
                ctx.beginPath();
                ctx.ellipse(0, 0, Math.max(0.1, r * 0.4), r, rot, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Outer Rim
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }




        // ============ ENERGY VISUALIZATION ============
        function updateEnergyDisplay() {
            if (!map3DState || !map3DState.hamiltonian) return;

            const ham = map3DState.hamiltonian;
            const panel = document.getElementById('mini-physics-monitor');
            if (!panel) return;

            if (currentMode !== 'map') {
                panel.style.display = 'none';
                return;
            }
            panel.style.display = 'flex';

            // Update numerical values
            document.getElementById('kinetic-energy').textContent = ham.kineticEnergy.toFixed(2);
            document.getElementById('potential-energy').textContent = ham.potentialEnergy.toFixed(2);
            document.getElementById('total-energy').textContent = ham.totalEnergy.toFixed(2);
            const drift = (ham.getEnergyDrift() * 100).toFixed(3);
            const driftElement = document.getElementById('energy-drift');
            driftElement.textContent = drift + '%';
            driftElement.style.color = parseFloat(drift) > 1 ? '#ff4466' : '#00ff00';

            // Trace graph removed for non-intrusive look
        }

        // ============ 3D ENGINE ============
        function animate() {
            requestAnimationFrame(animate);

            if (rotationHandler) {
                rotationHandler.update();
            }

            if (zoomHandler) {
                zoomLevel = zoomHandler.zoom;
                const slider = document.getElementById('zoom-slider');
                if (slider) slider.value = zoomLevel * 100;
                const val = document.getElementById('zoom-value');
                if (val) val.innerText = zoomLevel.toFixed(1) + '×';
            }

            width = canvas.width;
            height = canvas.height;
            visualCenterY = height / 2;

            if (isNaN(simTime)) simTime = 0;
            simTime += 0.01;
            const t = simTime + timeOffset;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;

            // Get rotation values FIRST before using them
            const rx = rotationHandler ? rotationHandler.rotationX : 0;
            const ry = rotationHandler ? rotationHandler.rotationY : 0;

            // Draw rotating starfield background
            ctx.clearRect(0, 0, width, height);

            // Sync background stars with 3D rotation
            if (rotationHandler) {
                updateStarField(null, null, {
                    rotationX: rotationHandler.rotationX,
                    rotationY: rotationHandler.rotationY
                });
            }

            // NEON GLOW & ADDITIVE BLENDING
            ctx.globalCompositeOperation = 'lighter';

            ctx.translate(width / 2 + panOffset.x, visualCenterY + panOffset.y);

            if (currentMode === 'map') {
                // Update physics at 30fps for better performance, render at 60fps  
                if (!window.lastPhysicsUpdate) window.lastPhysicsUpdate = 0;
                const now = performance.now();

                if (now - window.lastPhysicsUpdate > 33) {
                    updateMap3D(0.033);
                    window.lastPhysicsUpdate = now;
                }

                drawMap3D(t, rx, ry);
                updateEnergyDisplay();
            }

            else {
                if (currentMode === 'qft') drawQFT3D(t, rx, ry);
                if (currentMode === 'pilot') drawPilot3D(t, rx, ry);
                if (currentMode === 'neural') drawNeural3D(t, rx, ry);
                if (currentMode === 'social') drawSocial3D(t, rx, ry);
                if (currentMode === 'reality') drawReality3D(t, rx, ry);
            }
        }

        // IMPROVED QFT: FIELD OF INTERACTING ENERGY EXCITATIONS
        const qftParticles = [{
            x: 0, y: 0, z: 0, vx: 2, vz: 1
        }

            ,
        {
            x: -100, y: 0, z: 50, vx: -1.5, vz: -2
        }

        ];

        function drawQFT3D(t, rx, ry) {
            const size = 600;
            const res = 14;
            const step = size / res;

            // Update "Particle" excitations in the field
            qftParticles.forEach(p => {
                p.x += p.vx; p.z += p.vz;
                if (Math.abs(p.x) > size / 2) p.vx *= -1;
                if (Math.abs(p.z) > size / 2) p.vz *= -1;
            });

            // Draw field lattice
            ctx.lineWidth = 1;

            for (let z = -size / 2; z <= size / 2; z += step) {
                ctx.beginPath();

                for (let x = -size / 2; x <= size / 2; x += 15) {
                    let y = 0;

                    // Sum contributions from particle excitations (Local Excitations)
                    qftParticles.forEach(p => {
                        const d = Math.sqrt((x - p.x) ** 2 + (z - p.z) ** 2);
                        y += Math.sin(d * 0.04 - t * 6) * 45 * Math.exp(-d * 0.01) * eqParam;
                    });

                    // Add background vacuum fluctuations (The "Sea")
                    y += Math.sin(x * 0.02 + t * 2) * Math.cos(z * 0.02 + t * 2) * 10 * eqParam;

                    // OBSERVER EFFECT: Superposition Drift
                    const drift = rotationHandler ? (rotationHandler.inactivityFactor * 50) : 0;
                    const dx = (Math.random() - 0.5) * drift;
                    const dy = (Math.random() - 0.5) * drift;
                    const dz = (Math.random() - 0.5) * drift;

                    // Project with drift
                    const p = project3D(x + dx, y + dy, z + dz, rx, ry, 0, 0, zoomLevel);

                    // Draw Point (Neon Glow)
                    if (p.z > -300) {
                        const pointAlpha = (p.scale * 0.8 * (1 - Math.abs(z) / 400));
                        ctx.fillStyle = ColorUtils.hsl(280 + (y * 2), 100, 70, pointAlpha);
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.scale * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Intensity based on amplitude
                    const alpha = 0.1 + Math.abs(y) / 100;

                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;

                    if (x === -size / 2) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }

                ctx.stroke();
            }

            // Draw cross-lattice for 3D volume feel
            for (let x = -size / 2; x <= size / 2; x += step) {
                ctx.beginPath();

                for (let z = -size / 2; z <= size / 2; z += 15) {
                    let y = 0;

                    qftParticles.forEach(p => {
                        const d = Math.sqrt((x - p.x) ** 2 + (z - p.z) ** 2);
                        y += Math.sin(d * 0.04 - t * 6) * 45 * Math.exp(-d * 0.01) * eqParam;
                    });
                    y += Math.sin(x * 0.02 + t * 2) * Math.cos(z * 0.02 + t * 2) * 10 * eqParam;
                    const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);
                    if (z === -size / 2) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }

                ctx.stroke();
            }
        }


        // REDESIGNED PILOT WAVE: Beautiful Quantum Interference & Trajectories
        const pilotState3D = {

            particles: [],
            barrier: {
                x: 0, width: 20, slitWidth: 60, slitSeparation: 200
            }
        }

            ;

        // Initialize multiple particles
        function initPilotParticles() {
            if (pilotState3D.particles.length === 0) {
                const numParticles = 8;

                for (let i = 0; i < numParticles; i++) {
                    pilotState3D.particles.push({
                        x: -600,
                        y: 0,
                        z: (Math.random() - 0.5) * 300,
                        trail: [],
                        phase: Math.random() * Math.PI * 2,
                        speed: 3.5 + Math.random() * 1.5
                    });
                }
            }
        }

        function drawPilot3D(t, rx, ry) {
            initPilotParticles();

            const slitGap = 80 + (eqParam * 160);
            const barrier = pilotState3D.barrier;

            const slit1 = {
                x: barrier.x, z: -barrier.slitSeparation / 2
            }

                ;

            const slit2 = {
                x: barrier.x, z: barrier.slitSeparation / 2
            }

                ;

            // ========== 1. DRAW BEAUTIFUL WAVE FIELD ==========
            const gridSize = 700;
            const gridRes = 20;

            // Function to calculate wave amplitude at any point
            const getWaveAmplitude = (x, z, time) => {
                let amplitude = 0;
                const wavelength = slitGap;

                // Interference from both slits
                const d1 = Math.hypot(x - slit1.x, z - slit1.z);
                const d2 = Math.hypot(x - slit2.x, z - slit2.z);

                // Wave contribution from each slit with proper phase
                amplitude += Math.sin((d1 / wavelength) * 2 * Math.PI - time * 4) * Math.exp(-d1 * 0.001);
                amplitude += Math.sin((d2 / wavelength) * 2 * Math.PI - time * 4) * Math.exp(-d2 * 0.001);

                // Add source wave from left
                if (x < barrier.x - 50) {
                    const sourcePhase = (x * 0.015 - time * 4);
                    amplitude += Math.sin(sourcePhase) * 0.5 * Math.exp((x + 600) * 0.002);
                }

                return amplitude;
            }

                ;

            // Draw wave field as a beautiful 3D surface with color-coded amplitude
            for (let z = -gridSize; z <= gridSize; z += gridSize / gridRes) {
                ctx.beginPath();
                let prevAlpha = 0;

                for (let x = -gridSize; x <= gridSize; x += 25) {
                    const amplitude = getWaveAmplitude(x, z, t);
                    const y = amplitude * 40;

                    const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);

                    // Color based on amplitude (blue for negative, cyan for positive)
                    const normalizedAmp = (amplitude + 2) / 4; // Normalize to 0-1
                    const hue = 180 + normalizedAmp * 60; // Blue to cyan
                    const alpha = Math.max(0.1, Math.min(0.6, Math.abs(amplitude) * 0.3));

                    ctx.strokeStyle = `hsla($ {
                                hue
                            }

                                , 80 %, 60 %, $ {
                                alpha
                            })`;

                    if (x === -gridSize) {
                        ctx.moveTo(p.x, p.y);
                    }

                    else {
                        ctx.lineTo(p.x, p.y);
                    }

                    prevAlpha = alpha;
                }

                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            // Cross-grid for depth
            for (let x = -gridSize; x <= gridSize; x += gridSize / gridRes) {
                ctx.beginPath();

                for (let z = -gridSize; z <= gridSize; z += 25) {
                    const amplitude = getWaveAmplitude(x, z, t);
                    const y = amplitude * 40;
                    const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);

                    if (z === -gridSize) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }

                const sampleAmp = getWaveAmplitude(x, 0, t);
                const normalizedAmp = (sampleAmp + 2) / 4;
                const hue = 180 + normalizedAmp * 60;
                const alpha = Math.max(0.05, Math.min(0.4, Math.abs(sampleAmp) * 0.2));

                ctx.strokeStyle = `hsla($ {
                                hue
                            }

                                , 80 %, 60 %, $ {
                                alpha
                            })`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // ========== 2. DRAW BARRIER WITH SLITS ==========
            const barrierHeight = 150;

            // Draw barrier segments (avoiding slits)
            const drawBarrierSegment = (zStart, zEnd) => {
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                const p1 = project3D(barrier.x, -barrierHeight, zStart, rx, ry, 0, 0, zoomLevel);
                const p2 = project3D(barrier.x, barrierHeight, zStart, rx, ry, 0, 0, zoomLevel);
                const p3 = project3D(barrier.x, barrierHeight, zEnd, rx, ry, 0, 0, zoomLevel);
                const p4 = project3D(barrier.x, -barrierHeight, zEnd, rx, ry, 0, 0, zoomLevel);
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.closePath();
                ctx.stroke();

                // Fill with gradient
                const grad = ctx.createLinearGradient(p1.x, p1.y, p3.x, p3.y);
                grad.addColorStop(0, 'rgba(255, 80, 80, 0.3)');
                grad.addColorStop(1, 'rgba(255, 120, 120, 0.1)');
                ctx.fillStyle = grad;
                ctx.fill();
            }

                ;

            // Top barrier segment
            drawBarrierSegment(slit2.z + barrier.slitWidth / 2, 400);
            // Middle barrier segment
            drawBarrierSegment(slit1.z + barrier.slitWidth / 2, slit2.z - barrier.slitWidth / 2);
            // Bottom barrier segment
            drawBarrierSegment(-400, slit1.z - barrier.slitWidth / 2);

            // Highlight slits with glow
            [slit1,
                slit2].forEach(slit => {
                    const p1 = project3D(slit.x, -barrierHeight, slit.z - barrier.slitWidth / 2, rx, ry, 0, 0, zoomLevel);
                    const p2 = project3D(slit.x, barrierHeight, slit.z - barrier.slitWidth / 2, rx, ry, 0, 0, zoomLevel);
                    const p3 = project3D(slit.x, barrierHeight, slit.z + barrier.slitWidth / 2, rx, ry, 0, 0, zoomLevel);
                    const p4 = project3D(slit.x, -barrierHeight, slit.z + barrier.slitWidth / 2, rx, ry, 0, 0, zoomLevel);

                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.moveTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.stroke();
                });

            // ========== 3. UPDATE AND DRAW PARTICLES ==========
            pilotState3D.particles.forEach((particle, idx) => {
                // Calculate wave gradient for guidance
                const px = particle.x;
                const pz = particle.z;
                const gradZ = (getWaveAmplitude(px, pz + 3, t) - getWaveAmplitude(px, pz - 3, t)) * 15;
                const gradX = (getWaveAmplitude(px + 3, pz, t) - getWaveAmplitude(px - 3, pz, t)) * 2;

                // Update position based on wave guidance
                particle.x += particle.speed + gradX * 0.15;
                particle.z += gradZ * 0.6;
                particle.y = getWaveAmplitude(px, pz, t) * 40;

                // Reset if particle goes too far
                if (particle.x > 700) {
                    particle.x = -600;
                    particle.z = (Math.random() - 0.5) * 300;
                    particle.trail = [];
                    particle.phase = Math.random() * Math.PI * 2;
                }

                // Add to trail
                particle.trail.push({
                    x: particle.x, y: particle.y, z: particle.z
                });
                if (particle.trail.length > 150) particle.trail.shift();

                // Draw trail with fade effect
                if (particle.trail.length > 1) {
                    for (let i = 1; i < particle.trail.length; i++) {
                        const prev = particle.trail[i - 1];
                        const curr = particle.trail[i];
                        const alpha = (i / particle.trail.length) * 0.8;

                        const p1 = project3D(prev.x, prev.y, prev.z, rx, ry, 0, 0, zoomLevel);
                        const p2 = project3D(curr.x, curr.y, curr.z, rx, ry, 0, 0, zoomLevel);

                        // Color based on particle index for variety
                        const hue = 160 + (idx * 30) % 80;

                        ctx.strokeStyle = `hsla($ {
                                hue
                            }

                                , 90 %, 70 %, $ {
                                alpha
                            })`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }

                // Draw particle with glow
                const pPos = project3D(particle.x, particle.y, particle.z, rx, ry, 0, 0, zoomLevel);
                const particleSize = 5 * pPos.scale;
                const hue = 160 + (idx * 30) % 80;

                // Outer glow
                const glowGrad = ctx.createRadialGradient(pPos.x, pPos.y, 0, pPos.x, pPos.y, particleSize * 3);

                glowGrad.addColorStop(0, `hsla($ {
                                hue
                            }

                                , 100 %, 70 %, 0.6)`);
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(pPos.x, pPos.y, particleSize * 3, 0, Math.PI * 2);
                ctx.fill();

                // Core particle
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 15;

                ctx.shadowColor = `hsla($ {
                                    hue
                                }

                                    , 100 %, 70 %, 0.9)`;
                ctx.beginPath();
                ctx.arc(pPos.x, pPos.y, particleSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // ========== 4. DRAW WAVE INTENSITY VISUALIZATION ==========
            // Show interference pattern on detection screen (right side)
            const screenX = 500;
            const screenSamples = 40;

            for (let i = 0; i < screenSamples; i++) {
                const z = -300 + (i / screenSamples) * 600;
                const amplitude = getWaveAmplitude(screenX, z, t);
                const intensity = Math.abs(amplitude);

                const p1 = project3D(screenX, 0, z, rx, ry, 0, 0, zoomLevel);
                const p2 = project3D(screenX + intensity * 50, 0, z, rx, ry, 0, 0, zoomLevel);

                const alpha = Math.min(0.8, intensity * 0.5);

                ctx.strokeStyle = `rgba(255, 200, 100, $ {
                                        alpha
                                    })`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                // Dot at end
                ctx.fillStyle = `rgba(255, 220, 150, $ {
                                        alpha
                                    })`;
                ctx.beginPath();
                ctx.arc(p2.x, p2.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawNeural3D(t, rx, ry) {
            const count = 15 + Math.floor(eqParam * 50);
            const r = 200;

            for (let i = 0; i < count; i++) {
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi + t;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                const pulse = (Math.sin(t * 8 - i) + 1) / 2;
                const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);
                const center = project3D(0, 0, 0, rx, ry, 0, 0, zoomLevel);

                ctx.strokeStyle = `rgba(0, 255, 255, $ {
                                        0.1 + pulse * 0.5
                                    })`;
                ctx.lineWidth = p.scale;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(center.x, center.y);
                ctx.stroke();

                ctx.fillStyle = `rgba(0, 255, 255, $ {
                                        0.3 + pulse * 0.7
                                    })`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5 * p.scale, 0, 6.28);
                ctx.fill();
            }

            const core = project3D(0, 0, 0, rx, ry, 0, 0, zoomLevel);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(core.x, core.y, 10 * core.scale, 0, 6.28);
            ctx.fill();
        }

        // SOCIAL RESONANCE: Holographic Tensor Network
        function drawSocial3D(t, rx, ry) {
            const radius = 300;
            const nodeCount = 20;
            // Seeded random for consistency
            const seed = 12345;
            const pseudoRandom = (i) => Math.sin(seed + i * 43758.5453) * 0.5 + 0.5;

            ctx.globalCompositeOperation = 'lighter';

            const nodes = [];
            // Generate nodes on sphere
            for (let i = 0; i < nodeCount; i++) {
                const phi = Math.acos(-1 + (2 * i) / nodeCount);
                const theta = Math.sqrt(nodeCount * Math.PI) * phi;
                const x = radius * Math.cos(theta) * Math.sin(phi);
                const y = radius * Math.sin(theta) * Math.sin(phi);
                const z = radius * Math.cos(phi);

                // Drift with time (Brownian motion simulation)
                const drift = Math.sin(t * 0.5 + i) * 20 * eqParam;

                // Project
                nodes.push(project3D(x + drift, y + drift, z + drift, rx, ry, 0, 0, zoomLevel));
            }

            // Draw Vibrating Tensor Strings (Connections)
            ctx.lineWidth = 1.5;
            for (let i = 0; i < nodeCount; i++) {
                for (let j = i + 1; j < nodeCount; j++) {
                    // Only connect near neighbors to avoid mess
                    const d2 = (nodes[i].x - nodes[j].x) ** 2 + (nodes[i].y - nodes[j].y) ** 2;
                    if (d2 > 25000 * zoomLevel) continue; // Distance threshold

                    const tension = (Math.sin(t * 2 + i * j) * 0.5 + 0.5); // 0 to 1

                    // Tensor String: Cyan/Magenta/Orange based on "alignment"
                    const hue = (i * j) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${0.3 + tension * 0.4})`;

                    ctx.beginPath();
                    // Draw curve (sine wave on string)
                    const steps = 10;
                    const p1 = nodes[i];
                    const p2 = nodes[j];

                    ctx.moveTo(p1.x, p1.y);
                    for (let k = 1; k <= steps; k++) {
                        const prog = k / steps;
                        const lx = p1.x + (p2.x - p1.x) * prog;
                        const ly = p1.y + (p2.y - p1.y) * prog;

                        // Vibrate perpendicular to the line
                        const perpX = -(p2.y - p1.y);
                        const perpY = (p2.x - p1.x);
                        // Normalize
                        const len = Math.sqrt(perpX ** 2 + perpY ** 2) || 1;

                        const amp = Math.sin(t * 10 + i + j) * 5 * eqParam * Math.sin(prog * Math.PI); // Max amplitude in middle

                        ctx.lineTo(lx + (perpX / len) * amp, ly + (perpY / len) * amp);
                    }
                    ctx.stroke();
                }
            }

            // Draw Holographic Nodes
            nodes.forEach((p, i) => {
                const pulse = Math.sin(t * 3 + i) * 0.3 + 1; // 0.7 to 1.3
                const size = 6 * p.scale * pulse;

                const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.4, `hsla(${(i * 20) % 360}, 100%, 60%, 0.8)`);
                grad.addColorStop(1, 'transparent');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // REALITY PERCEPTION: Interface vs Substrate
        function drawReality3D(t, rx, ry) {
            const gridSize = 400;
            const spacing = 60;

            // "The Substrate" - the underlying truth (wavy grid)
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
            ctx.lineWidth = 1.5;

            for (let x = -gridSize; x <= gridSize; x += spacing) {
                ctx.beginPath();

                for (let z = -gridSize; z <= gridSize; z += 20) {
                    const y = Math.sin(x * 0.02 + t) * 40 + Math.cos(z * 0.02 + t) * 40;
                    const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);
                    if (z === -gridSize) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }

                ctx.stroke();
            }

            for (let z = -gridSize; z <= gridSize; z += spacing) {
                ctx.beginPath();

                for (let x = -gridSize; x <= gridSize; x += 20) {
                    const y = Math.sin(x * 0.02 + t) * 40 + Math.cos(z * 0.02 + t) * 40;
                    const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);
                    if (x === -gridSize) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }

                ctx.stroke();
            }

            // "The Interface" - simplified perception layer (flat grid above)
            const interfaceHeight = 100 + eqParam * 120;
            ctx.strokeStyle = 'rgba(0, 255, 200, 0.8)';
            ctx.lineWidth = 2.5;

            for (let x = -gridSize; x <= gridSize; x += spacing) {
                ctx.beginPath();

                for (let z = -gridSize; z <= gridSize; z += 20) {
                    const y = interfaceHeight;
                    const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);
                    if (z === -gridSize) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }

                ctx.stroke();
            }

            for (let z = -gridSize; z <= gridSize; z += spacing) {
                ctx.beginPath();

                for (let x = -gridSize; x <= gridSize; x += 20) {
                    const y = interfaceHeight;
                    const p = project3D(x, y, z, rx, ry, 0, 0, zoomLevel);
                    if (x === -gridSize) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }

                ctx.stroke();
            }

            // Connection points showing fitness payoff
            const samplePoints = 6;

            for (let i = 0; i < samplePoints; i++) {
                for (let j = 0; j < samplePoints; j++) {
                    const x = -gridSize + (i / (samplePoints - 1)) * gridSize * 2;
                    const z = -gridSize + (j / (samplePoints - 1)) * gridSize * 2;
                    const ySubstrate = Math.sin(x * 0.02 + t) * 40 + Math.cos(z * 0.02 + t) * 40;
                    const yInterface = interfaceHeight;

                    const p1 = project3D(x, ySubstrate, z, rx, ry, 0, 0, zoomLevel);
                    const p2 = project3D(x, yInterface, z, rx, ry, 0, 0, zoomLevel);

                    // Dashed connection line
                    ctx.strokeStyle = 'rgba(255, 255, 100, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Marker dots - brighter
                    ctx.fillStyle = 'rgba(100, 255, 200, 0.9)';
                    ctx.beginPath();
                    ctx.arc(p2.x, p2.y, 5 * p2.scale, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'rgba(100, 100, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(p1.x, p1.y, 5 * p1.scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        window.onload = init;
    </script>
</body>

</html>