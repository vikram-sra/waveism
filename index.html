<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <!-- PWA / iOS Capabilities -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Waveism">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-180.png">
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- Aggressive Anti-Cache -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <meta name="description"
        content="Explore the unified field theory of waves - from quantum mechanics to cosmic expansion. An interactive physics visualization experience.">
    <title>Waveism | Epistemic Interface</title>

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://waveism.app/">
    <meta property="og:title" content="Waveism | Unified Field Theory Dashboard">
    <meta property="og:description"
        content="Explore the unified field theory of waves - from quantum mechanics to cosmic expansion. An interactive physics visualization experience.">
    <meta property="og:image" content="https://waveism.app/assets/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Waveism | Unified Field Theory Dashboard">
    <meta name="twitter:description"
        content="Explore the unified field theory of waves - from quantum mechanics to cosmic expansion.">
    <meta name="twitter:image" content="https://waveism.app/assets/og-image.png">

    <script>
        // Register Service Worker for Offline PWA Support
        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('[Waveism] Service Worker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.warn('[Waveism] Service Worker registration failed:', error);
                    });
            });

            // Reload page on new SW activation
            let refreshing = false;
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                if (!refreshing) {
                    window.location.reload();
                    refreshing = true;
                }
            });
        } else if (window.location.protocol === 'file:') {
            console.log('[Waveism] Service Worker skipped: running on file:// protocol');
        }
    </script>

    <style>
        html,
        body {
            background: #000 !important;
            font-display: block;
        }
    </style>
    <link rel="stylesheet" href="components/shared.css?v=2">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="components/shared.js?v=2"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&family=JetBrains+Mono:wght@300;400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg: #000508;
            --accent: #00ddff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            color: #fff;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            /* iOS Safe Area */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* Glitch Overlay */
        .scanlines {
            position: fixed;
            inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0.15;
            user-select: none;
        }

        /* CONTAINER (The Reel) */
        #reel {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            height: 100%;
            /* Relative to safe body */
            width: 100vw;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE/Edge */
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            /* Momentum Scroll */
        }

        /* SEAMLESS FULLSCREEN LAYOUT */
        .section {
            position: relative;
            flex: 0 0 100vw;
            height: 100%;
            scroll-snap-align: center;
            scroll-snap-stop: always;
            overflow: hidden;
            background: transparent;
        }

        /* CANVAS (Sky + Persona) */
        .viz-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 1;
            /* Fully visible */
            filter: contrast(1.2) brightness(1.2);
            /* Enhance pop */
        }

        /* CONTENT (Locked to Bottom) */
        .content {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(40px);
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 25px;
            /* Improved vertical spacing */
        }

        .section.active .content {
            opacity: 1;
            transform: translateX(-50%);
            transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .phase-meta {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--accent);
            letter-spacing: 0.4em;
            text-transform: uppercase;
            margin-bottom: 5px;
            opacity: 0.8;
            text-shadow: 0 0 10px var(--accent);
        }

        /* CYBER TITLE LINK */
        .phase-link {
            pointer-events: auto;
            text-decoration: none;
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .phase-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 5rem;
            font-weight: 700;
            letter-spacing: -0.04em;
            color: #fff;
            margin: 0;
            text-transform: uppercase;
            text-shadow: 2px 0 var(--accent), -2px 0 rgba(255, 0, 255, 0.5);
            background: linear-gradient(180deg, #fff 0%, #aaa 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .section.active .phase-title {
            animation: titlePulse 4s infinite ease-in-out, titleGlitch 10s infinite;
        }

        @keyframes titlePulse {

            0%,
            100% {
                filter: brightness(1) drop-shadow(0 0 0px var(--accent));
            }

            50% {
                filter: brightness(1.2) drop-shadow(0 0 15px var(--accent));
            }
        }

        @keyframes titleGlitch {

            0%,
            95%,
            100% {
                transform: translate(0);
            }

            96% {
                transform: translate(2px, -1px);
            }

            97% {
                transform: translate(-2px, 1px);
            }

            98% {
                transform: translate(1px, 2px);
            }

            99% {
                transform: translate(-1px, -2px);
            }
        }

        .phase-link:hover .phase-title {
            text-shadow: 4px 0 var(--accent), -4px 0 rgba(255, 0, 255, 0.7);
            letter-spacing: 0.05em;
            transform: scale(1.02);
            -webkit-text-fill-color: #fff;
        }

        .phase-desc {
            display: block;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
            max-width: 500px;
            line-height: 1.6;
            background: rgba(5, 10, 15, 0.8);
            border: 1px solid rgba(0, 221, 255, 0.2);
            padding: 16px 28px;
            border-radius: 2px;
            backdrop-filter: blur(20px);
            text-align: center;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .phase-desc::before,
        .phase-desc::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            border-color: var(--accent);
            border-style: solid;
            opacity: 0.5;
        }

        .phase-desc::before {
            top: -1px;
            left: -1px;
            border-width: 1px 0 0 1px;
        }

        .phase-desc::after {
            bottom: -1px;
            right: -1px;
            border-width: 0 1px 1px 0;
        }

        .phase-question {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--accent);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 4px;
            opacity: 0.9;
        }

        .enter-btn {
            display: none;
        }

        /* Removed */

        .enter-btn:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            box-shadow: 0 0 30px var(--accent);
        }

        /* Remove old UI clutter */
        .horizon-line,
        .floor-grid {
            display: none;
        }

        /* HEADER & HUD */


        .hud-pager {
            position: fixed;
            bottom: 30px;
            right: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
            z-index: 100;
        }

        /* Nav Arrows - Explicit Affordance */
        .nav-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 50;
            color: rgba(255, 255, 255, 0.15);
            font-size: 1.2rem;
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            user-select: none;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            -webkit-tap-highlight-color: transparent;
            backdrop-filter: blur(5px);
        }

        .nav-arrow:hover {
            color: var(--accent);
            background: rgba(0, 221, 255, 0.05);
            border-color: rgba(0, 221, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 221, 255, 0.1);
        }

        .nav-arrow.left {
            left: 20px;
        }

        .nav-arrow.right {
            right: 20px;
        }

        /* PROGRESS BAR */
        .progress-track {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(90deg,
                    transparent,
                    transparent var(--freq, 10px),
                    rgba(255, 255, 255, 0.3) var(--freq, 10px),
                    rgba(255, 255, 255, 0.3) calc(var(--freq, 10px) + 1px));
            animation: moveFreq 2s infinite linear;
        }

        @keyframes moveFreq {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 40px 0;
            }
        }

        .wavelength-label {
            position: fixed;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--accent);
            letter-spacing: 0.2em;
            opacity: 0.8;
            pointer-events: none;
            z-index: 100;
            text-transform: uppercase;
        }

        .wavelength-label span {
            color: rgba(255, 255, 255, 0.4);
            margin-right: 8px;
        }

        @media (max-width: 600px) {
            .phase-title {
                font-size: 2.2rem;
            }

            .content {
                bottom: max(40px, env(safe-area-inset-bottom) + 20px);
                padding: 15px;
                gap: 15px;
            }

            .phase-desc {
                font-size: 0.75rem;
                max-width: 85%;
            }
        }

        #reel .section[data-id="create_wave"] {
            background: #000 !important;
        }

        #reel .section[data-id="create_wave"] .create-wave-hint {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.3em;
            pointer-events: none;
            z-index: 5;
            text-align: center;
            text-transform: uppercase;
        }

        @keyframes pulseHint {

            0%,
            100% {
                opacity: 0.1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .content.hidden {
            display: none !important;
        }

        #reel .section[data-id="create_wave"] .create-wave-hint {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.3em;
            pointer-events: none;
            z-index: 5;
            text-align: center;
        }

        #reel .section[data-id="create_wave"] .back-arrow-hint {
            position: absolute;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.2);
            animation: slideBack 2s infinite ease-in-out;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes slideBack {

            0%,
            100% {
                transform: translate(0, -50%);
                opacity: 0.1;
            }

            50% {
                transform: translate(-15px, -50%);
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="nav-container"></div>
    <div class="scanlines"></div>



    <!-- Native Scroll Container -->
    <div id="reel">
        <!-- Rendered by JS -->
    </div>

    <!-- HUD Elements -->
    <div class="nav-arrow left" id="nav-l">❮</div>
    <div class="nav-arrow right" id="nav-r">❯</div>

    <!-- HUD -->
    <div class="hud-pager" id="pager">-- / --</div>
    <div class="wavelength-label" id="wavelength"><span>λ</span> --</div>
    <div class="progress-track">
        <div class="progress-bar" id="progress"></div>
    </div>

    <script>
        const phases = [
            { id: 'quantum', title: 'QUANTUM', question: 'Can you be in two places?', desc: 'Non-local field superposition and wave function collapse.', color: '#00ffaa', scale: '10⁻³⁵m' },
            { id: 'uncertainty', title: 'UNCERTAINTY', question: 'Is reality fundamentally blurry?', desc: 'The fundamental limit of precision in the vacuum.', color: '#9d4edd', scale: '10⁻³⁰m' },
            { id: 'wave_theory', title: 'WAVEISM', question: 'Is everything just a vibration?', desc: 'Unified framework of oscillatory reality.', color: '#7b2cbf', scale: '10⁻¹⁵m' },
            { id: 'resonance', title: 'RESONANCE', question: 'Why does energy amplify?', desc: 'Coherent interference and entrainment protocols.', color: '#ff0055', scale: '10⁻⁶m' },
            { id: 'chaos', title: 'CHAOS', question: 'Can a butterfly cause a storm?', desc: 'Non-linear dynamics and strange attractors.', color: '#ff4d6d', scale: '10⁰m' },
            { id: 'arrow', title: 'ARROW', question: 'Why can\'t we reverse time?', desc: 'Entropy drift and the thermodynamic direction.', color: '#ff5500', scale: '10⁵m' },
            { id: 'fabric', title: 'FABRIC', question: 'What is empty space made of?', desc: 'The metric tensor substrate of reality.', color: '#00ddff', scale: '10¹⁰m' },
            { id: 'wormhole', title: 'WORMHOLE', question: 'Are there shortcuts in space?', desc: 'Topological bridges through the manifold.', color: '#4cc9f0', scale: '10¹⁵m' },
            { id: 'spacetime', title: 'SPACETIME', question: 'Is the future already written?', desc: 'The 4D continuum of light cones and worldlines.', color: '#ff6b9d', scale: '10¹⁸m' },
            { id: 'blackhole', title: 'BLACK HOLE', question: 'What happens if you fall in?', desc: 'Infinite curvature and causal singularities.', color: '#ffaa00', scale: '10²¹m' },
            { id: 'expansion', title: 'EXPANSION', question: 'Where is the universe going?', desc: 'Metric acceleration of the cosmic substrate.', color: '#b5179e', scale: '10²⁴m' },
            { id: 'cosmic', title: 'COSMIC', question: 'What does the universe look like?', desc: 'Large-scale structure of galactic filaments.', color: '#0088ff', scale: '10²⁶m' },
            { id: 'create_wave', title: 'CREATE A WAVE', question: 'Can you trigger a ripple?', desc: 'Manual interaction with the cosmic medium.', color: '#ffffff', scale: '∞' }
        ];

        const reel = document.getElementById('reel');
        let time = 0;
        const W = window.innerWidth;

        document.getElementById('nav-container').innerHTML = renderMainNav('index');

        // Prepare Infinite List: [Last, ...Originals, First]
        const displayPhases = [phases[phases.length - 1], ...phases, phases[0]];

        // Build DOM
        displayPhases.forEach((p, i) => {
            const sec = document.createElement('section');
            sec.className = 'section';
            sec.dataset.id = p.id;
            sec.style.background = 'transparent';
            sec.id = 'sec-' + i;

            // Map to real index (0-11) for HUD/Logic
            // 0 -> Clone(11), 1 -> 0, ... 12 -> 11, 13 -> Clone(0)
            const realIndex = (i - 1 + phases.length) % phases.length;
            sec.dataset.realIndex = realIndex;

            // NEW: Dual-Layer Architecture for Create Wave to prevent Context Conflict
            // Layer 0: WebGL Substrate (Background)
            if (p.id === 'create_wave') {
                const glCanvas = document.createElement('canvas');
                glCanvas.className = 'viz-canvas';
                glCanvas.id = `viz-webgl-${i}`;
                glCanvas.style.zIndex = 1; // Behind UI
                glCanvas.style.pointerEvents = 'none'; // Pass-through
                sec.appendChild(glCanvas);
            }

            // Layer 1: 2D UI & Interaction (Foreground)
            const canvas = document.createElement('canvas');
            canvas.className = 'viz-canvas';
            canvas.id = `viz-${i}`;
            canvas.dataset.vizId = p.id;
            canvas.style.zIndex = 2; // On top
            canvas.style.cursor = 'pointer';

            // Advanced Multi-Device Interaction (Trackpads, Phones, Mouse)
            const updateInteraction = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = 1 - (e.clientY - rect.top) / rect.height;
                canvas.dataset.mx = x;
                canvas.dataset.my = y;

                // Pressure Detection: Pointer Events or fallback
                let p = (e.pressure !== undefined && e.pressure > 0) ? e.pressure : 0;
                if (p === 0 && e.buttons > 0) p = 0.5; // Mouse fallback
                canvas.dataset.pressure = p;
            };

            canvas.onpointerdown = (e) => {
                if (p.id === 'create_wave') {
                    canvas.setPointerCapture(e.pointerId);
                    updateInteraction(e);
                    if (navigator.vibrate) navigator.vibrate(15);
                }
            };
            canvas.onpointermove = (e) => {
                if (p.id === 'create_wave') {
                    updateInteraction(e);
                }
            };
            canvas.onpointerup = canvas.onpointerleave = (e) => {
                if (p.id === 'create_wave') {
                    canvas.dataset.pressure = 0;
                }
            };
            canvas.onclick = () => {
                if (p.id !== 'create_wave') window.location.href = 'modules/' + p.id + '.html';
            };
            sec.appendChild(canvas);

            const content = document.createElement('div');
            content.className = 'content' + (p.id === 'create_wave' ? ' hidden' : '');
            content.innerHTML = `
                <div class="phase-question">${p.question}</div>
                <a href="modules/${p.id}.html" class="phase-link"><h1 class="phase-title">${p.title}</h1></a>
                <div class="phase-desc">${p.desc}</div>
            `;
            sec.appendChild(content);
            if (p.id === 'create_wave') {
                const hint = document.createElement('div');
                hint.className = 'create-wave-hint';
                hint.innerHTML = 'ENGAGE RESONANCE<br><span style="font-size: 0.5rem; opacity: 0.5; letter-spacing: 0.1em;">(DRAG OR PRESS TO DEFORM)</span>';
                sec.appendChild(hint);

                const backHint = document.createElement('div');
                backHint.className = 'back-arrow-hint';
                backHint.style.pointerEvents = 'auto';
                backHint.style.cursor = 'pointer';
                backHint.innerText = '❮';
                backHint.onclick = (e) => {
                    e.stopPropagation();
                    scrollPrev();
                };
                sec.appendChild(backHint);
            }

            reel.appendChild(sec);
        });

        // Initial Position (Skip first clone)
        if ('scrollRestoration' in history) history.scrollRestoration = 'manual';

        // Robust Initial Scroll Logic to Start at WAVEISM (Index 1)
        function initReelPosition() {
            isTeleporting = true;
            reel.style.scrollBehavior = 'auto';

            const startPos = window.innerWidth;
            reel.scrollLeft = startPos;
            reel.scrollTo(startPos, 0);

            // Immediate HUD sync for Waveism
            updateHUD(0);

            setTimeout(() => {
                isTeleporting = false;
                reel.style.overflowX = 'auto';
            }, 100);
        }

        if (document.readyState !== 'loading') {
            initReelPosition();
        } else {
            document.addEventListener('DOMContentLoaded', initReelPosition);
        }

        const indexStars = initGlobalStarField('background-stars');

        // Infinite Scroll Teleport
        let isTeleporting = false;
        reel.addEventListener('scroll', () => {
            if (isTeleporting) return;

            const totalW = displayPhases.length * W;
            // Left Edge (Clone Last) -> Jump to Real Last
            if (reel.scrollLeft < 10) {
                isTeleporting = true;
                reel.scrollLeft = (displayPhases.length - 2) * W;
                setTimeout(() => isTeleporting = false, 50);
            }
            // Right Edge (Clone First) -> Jump to Real First
            else if (reel.scrollLeft > (displayPhases.length - 1) * W - 10) {
                isTeleporting = true;
                reel.scrollLeft = W;
                setTimeout(() => isTeleporting = false, 50);
            }

            // Sync Stars with Scroll
            if (indexStars) {
                indexStars.targetOffsetX = (reel.scrollLeft / reel.scrollWidth) * window.innerWidth * 0.5;
            }
        });

        // Vertical Wheel -> Page Turn (Throttled)
        let lastWheel = 0;
        window.addEventListener('wheel', (e) => {
            // High threshold for touchpads doing momentum
            if (Date.now() - lastWheel < 100) return;

            if (e.deltaY !== 0) {
                if (Math.abs(e.deltaY) > 20) {
                    lastWheel = Date.now();
                    if (e.deltaY > 0) scrollNext();
                    else scrollPrev();
                }
                e.preventDefault();
            }
        }, { passive: false });

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(e => {
                if (e.isIntersecting) {
                    e.target.classList.add('active');
                    // Update HUD only when significantly visible
                    if (e.intersectionRatio > 0.5) {
                        const realIdx = parseInt(e.target.dataset.realIndex);
                        updateHUD(realIdx);
                        lastActiveSectionId = e.target.id;
                    }
                } else {
                    // Slight buffer before removing active state
                    if (e.intersectionRatio < 0.1) {
                        e.target.classList.remove('active');
                    }
                }
            });
        }, { threshold: [0, 0.1, 0.5, 0.9, 1.0] });
        let lastActiveSectionId = null;
        document.querySelectorAll('.section').forEach(s => observer.observe(s));
        document.querySelectorAll('.section').forEach(s => observer.observe(s));

        function updateHUD(idx) {
            const phase = phases[idx];
            document.getElementById('pager').innerText = `${String(idx + 1).padStart(2, '0')} / ${phases.length}`;
            document.getElementById('wavelength').innerHTML = `<span>λ</span> ${phase.scale}`;

            const pct = ((idx + 1) / phases.length) * 100;
            const progress = document.getElementById('progress');
            progress.style.width = pct + '%';
            progress.style.backgroundColor = phase.color;

            // Frequency indication: Higher scales (smaller wavelengths) = Denser bars
            // Rank from 0 (Quantum) to 12 (Cosmic)
            const freq = 5 + (idx * 3);
            progress.style.setProperty('--freq', freq + 'px');

            document.documentElement.style.setProperty('--accent', phase.color);
        }

        // Nav Helpers
        function scrollNext() { reel.scrollBy({ left: W, behavior: 'smooth' }); }
        function scrollPrev() { reel.scrollBy({ left: -W, behavior: 'smooth' }); }

        document.getElementById('nav-l').onclick = scrollPrev;
        document.getElementById('nav-r').onclick = scrollNext;

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') scrollPrev();
            if (e.key === 'ArrowRight') scrollNext();
            if (e.key === 'Enter') {
                const centerIdx = Math.round(reel.scrollLeft / W);
                const p = displayPhases[centerIdx];
                if (p) window.location.href = 'modules/' + p.id + '.html';
            }
        });

        // VIZ ANIMATION
        const visFns = getVizFns();

        function loop() {
            time += 0.002; // Slower, more majestic (approx 1 second pulses)

            document.querySelectorAll('.section.active canvas:not([id^="viz-webgl"])').forEach(c => {
                const vizId = c.dataset.vizId;
                const phase = phases.find(p => p.id === vizId);

                // Find the index of the current phase to scale 't'
                const phaseIndex = phases.findIndex(p => p.id === vizId);
                const ranking = (phaseIndex !== -1 ? phaseIndex + 1 : 1) * 0.5; // Speed factor based on rank, default to 0.5 if not found
                const scaledT = time * ranking;

                // Resize check
                if (c.width !== W || c.height !== window.innerHeight) {
                    c.width = W; c.height = window.innerHeight;
                }
                const ctx = c.getContext('2d');
                const w = c.width;
                const h = c.height;

                ctx.clearRect(0, 0, w, h);

                // Draw subtle horizon glow for depth (no wave)
                const hLine = h * 0.62;
                const grad = ctx.createLinearGradient(0, hLine - 100, 0, hLine + 100);
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(0.5, phase ? phase.color + '22' : 'rgba(255,255,255,0.05)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, hLine - 100, w, 200);

                // Draw Viz
                if (visFns[vizId]) {
                    visFns[vizId](ctx, w, h, scaledT);
                }

                // Draw Totem
                drawTotem(ctx, w, h, scaledT, vizId, phase ? phase.color : '#fff');
            });
            requestAnimationFrame(loop);
        }
        loop();

        // PROCEDURAL SEA
        function drawSea(c, w, h, t, color) {
            const hLine = h * 0.5; // Dead Center Horizon

            // Layered Depth (Multiple Wave Planes)
            const layers = [
                { offset: 0, speed: 1.0, opacity: 1, depth: 0, color: '#010105' },
                { offset: 10, speed: 0.7, opacity: 0.3, depth: 40, color: color + '22' },
                { offset: -5, speed: 1.3, opacity: 0.2, depth: -30, color: color + '11' }
            ];

            layers.forEach((layer, idx) => {
                c.fillStyle = layer.color;
                c.beginPath();
                c.moveTo(0, h);
                c.lineTo(0, hLine + layer.depth);

                for (let x = 0; x <= w; x += 15) {
                    const y = hLine + layer.depth +
                        Math.sin(x * 0.004 + t * layer.speed) * 15 +
                        Math.cos(x * 0.015 - t * 0.4 * layer.speed) * 8;
                    c.lineTo(x, y);
                }

                c.lineTo(w, h);
                c.fill();

                if (idx === 0) { // Primary Neon Edge
                    c.strokeStyle = color;
                    c.lineWidth = 2;
                    c.shadowBlur = 20; c.shadowColor = color;
                    c.beginPath();
                    for (let x = 0; x <= w; x += 15) {
                        const y = hLine + Math.sin(x * 0.004 + t) * 15 + Math.cos(x * 0.015 - t * 0.4) * 8;
                        x === 0 ? c.moveTo(x, y) : c.lineTo(x, y);
                    }
                    c.stroke();
                    c.shadowBlur = 0;
                }
            });
        }

        // TOTEM ARTIFACTS
        function drawTotem(c, w, h, t, id, color) {
            const cx = w / 2;
            const hLine = h * 0.5 + Math.sin(cx * 0.004 + t) * 15 + Math.cos(cx * 0.015 - t * 0.4) * 8;
            const size = h * 0.15;

            c.save();
            c.translate(cx, hLine - size * 1.0);

            // 1. Symbol Particle Aura
            c.globalCompositeOperation = 'screen';
            for (let i = 0; i < 12; i++) {
                const ang = (i / 12) * Math.PI * 2 + t;
                const dist = size * (0.8 + Math.sin(t * 2 + i) * 0.1);
                const px = Math.cos(ang) * dist;
                const py = Math.sin(ang) * dist;
                c.fillStyle = color;
                c.globalAlpha = 0.2 + Math.sin(t * 3 + i) * 0.1;
                c.beginPath();
                c.arc(px, py, 1.5, 0, Math.PI * 2);
                c.fill();
            }
            c.globalCompositeOperation = 'source-over';
            c.globalAlpha = 1.0;

            // 2. Reflection on Sea
            c.save();
            c.scale(1, -0.4);
            c.translate(0, -size * 1.8);
            c.globalAlpha = 0.15;
            c.filter = 'blur(12px)';
            drawSymbol(c, t, id, color, size);
            c.restore();

            // 3. Main Artifact
            c.shadowBlur = 50; c.shadowColor = color;
            drawSymbol(c, t, id, color, size);
            c.shadowBlur = 0;

            // 4. Labelling & HUD Data
            c.fillStyle = 'white';
            c.font = '600 12px "JetBrains Mono"';
            c.textAlign = 'center';
            c.letterSpacing = '3px';
            c.globalAlpha = 0.9;
            c.fillText(id.toUpperCase().replace('_', ' '), 0, size * 0.9);

            // Underline
            c.strokeStyle = color;
            c.lineWidth = 1;
            c.beginPath();
            c.moveTo(-20, size * 0.9 + 5);
            c.lineTo(20, size * 0.9 + 5);
            c.stroke();

            // Tech Data HUD
            c.fillStyle = color;
            c.font = '300 10px "JetBrains Mono"';
            c.letterSpacing = '1px';
            c.globalAlpha = 0.6;

            const techData = {
                fabric: "METRIC TENSOR G\u1D6D\u1D78 [DIM:11]",
                spacetime: "MINKOWSKI METRIC [DS\u00B2]",
                blackhole: "EVENT HORIZON [RS:2GM/C\u00B2]",
                quantum: "WAVE FUNCTION \u03A8 [H\u03A8=E\u03A8]",
                resonance: "EIGENFREQUENCY \u03BB [H\u2080]",
                wormhole: "EINSTEIN-ROSEN BRIDGE",
                chaos: "STRANGE ATTRACTOR [LYAPUNOV]",
                expansion: "HUBBLE PARAM [KM/S/MPC]",
                uncertainty: "\u0394x\u0394p \u2265 \u210F/2 [BOHR]",
                wave_theory: "SUPERPOSITION PRINCIPLE",
                arrow: "ENTROPY S = k log W",
                cosmic: "LARGE STRUCTURE FILAMENTS",
                create_wave: "HAPTIC RIPPLE \u03A3 [OSC]"
            };

            c.fillText(techData[id] || "ANALYZING...", 0, size * 0.9 + 20);
            c.restore();
        }

        function drawSymbol(c, t, id, color, s) {
            c.strokeStyle = color;
            c.fillStyle = 'rgba(0,0,0,0.5)';
            c.lineWidth = 2.5;
            c.lineCap = 'round';
            c.lineJoin = 'round';

            switch (id) {
                case 'wave_theory':
                    for (let i = -2; i <= 2; i++) {
                        c.beginPath();
                        c.setLineDash(i % 2 === 0 ? [] : [5, 5]);
                        for (let y = -s; y <= s; y += 5) {
                            c.lineTo(i * (s * 0.25) + Math.sin(y * 0.1 - t * 4) * (s * 0.15), y);
                        }
                        c.stroke();
                    }
                    c.setLineDash([]);
                    break;

                case 'fabric':
                    c.save();
                    c.rotate(t * 0.5);
                    c.shadowBlur = 10; c.shadowColor = color;
                    c.beginPath(); c.rect(-s * 0.4, -s * 0.4, s * 0.8, s * 0.8); c.stroke();
                    c.shadowBlur = 0;
                    c.rotate(-t * 0.8);
                    c.beginPath(); c.rect(-s * 0.7, -s * 0.7, s * 1.4, s * 1.4); c.stroke();
                    c.beginPath();
                    c.setLineDash([2, 4]);
                    c.moveTo(-s * 0.4, -s * 0.4); c.lineTo(-s * 0.7, -s * 0.7);
                    c.moveTo(s * 0.4, -s * 0.4); c.lineTo(s * 0.7, -s * 0.7);
                    c.moveTo(s * 0.4, s * 0.4); c.lineTo(s * 0.7, s * 0.7);
                    c.moveTo(-s * 0.4, s * 0.4); c.lineTo(-s * 0.7, s * 0.7);
                    c.stroke();
                    c.setLineDash([]);
                    c.restore();
                    break;

                case 'chaos':
                    c.beginPath();
                    c.setLineDash([1, 2]);
                    for (let i = 0; i < 120; i++) {
                        const ang = t * 0.5 + i * 0.08;
                        const r = s * Math.cos(3 * ang) * (0.8 + Math.sin(t) * 0.2);
                        c.lineTo(r * Math.cos(ang), r * Math.sin(ang));
                    }
                    c.stroke();
                    c.setLineDash([]);
                    c.beginPath(); c.arc(0, 0, 4, 0, 7); c.fillStyle = color; c.fill();
                    break;

                case 'spacetime':
                    c.beginPath();
                    c.moveTo(-s * 0.6, -s * 0.8); c.lineTo(s * 0.6, -s * 0.8);
                    c.lineTo(0, 0); c.lineTo(s * 0.6, s * 0.8);
                    c.lineTo(-s * 0.6, s * 0.8); c.lineTo(0, 0); c.closePath();
                    c.stroke();
                    const sPos = (Math.sin(t * 2) * 0.5 + 0.5) * s * 1.6 - s * 0.8;
                    c.beginPath();
                    c.moveTo(-s * 0.3, sPos); c.lineTo(s * 0.3, sPos);
                    c.strokeStyle = 'white'; c.lineWidth = 1; c.stroke();
                    c.strokeStyle = color; c.lineWidth = 2.5;
                    break;

                case 'blackhole':
                    c.save();
                    c.shadowBlur = 20; c.shadowColor = color;
                    c.fillStyle = '#000'; c.beginPath(); c.arc(0, 0, s * 0.5, 0, 7); c.fill(); c.stroke();
                    c.shadowBlur = 0;
                    for (let i = 0; i < 3; i++) {
                        c.beginPath();
                        const phase = t * 3 + i * 2;
                        c.ellipse(0, 0, s * (1 + Math.sin(phase) * 0.1), s * 0.2, phase, 0, 7);
                        c.stroke();
                    }
                    c.restore();
                    break;

                case 'expansion':
                    c.save(); c.rotate(t * 0.5);
                    for (let i = 0; i < 12; i++) {
                        c.rotate(Math.PI / 6);
                        const len = s * (0.6 + Math.sin(t * 4 + i) * 0.2);
                        c.beginPath(); c.moveTo(0, 0); c.lineTo(0, -len); c.stroke();
                        c.beginPath(); c.arc(0, -len, 2, 0, 7); c.fillStyle = color; c.fill();
                    }
                    c.restore();
                    c.beginPath(); c.arc(0, 0, s * 0.3 + Math.sin(t * 8) * 5, 0, 7); c.stroke();
                    break;

                case 'wormhole':
                    for (let i = 0; i < 6; i++) {
                        c.beginPath();
                        c.globalAlpha = 1 - (i / 6);
                        const rot = t * (i % 2 ? 1 : -1) * (1 + i * 0.2);
                        c.ellipse(0, 0, s * (0.15 + i * 0.15), s * (0.05 + i * 0.05), rot, 0, 7);
                        c.stroke();
                    }
                    c.globalAlpha = 1;
                    break;

                case 'quantum':
                    c.save();
                    c.shadowBlur = 15; c.shadowColor = color;
                    c.beginPath(); c.arc(0, 0, 8, 0, 7); c.fillStyle = color; c.fill();
                    c.shadowBlur = 0;
                    for (let i = 0; i < 3; i++) {
                        c.beginPath();
                        c.ellipse(0, 0, s * 0.9, s * 0.3, t * 2.5 + i * (Math.PI / 1.5), 0, 7);
                        c.stroke();
                    }
                    c.restore();
                    break;

                case 'uncertainty':
                    c.save();
                    const glitch = Math.random() > 0.90;
                    if (glitch) c.translate((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
                    c.beginPath(); c.rect(-s * 0.6, -s * 0.6, s * 1.2, s * 1.2); c.stroke();
                    c.setLineDash([4, 4]);
                    c.beginPath(); c.moveTo(-s * 0.6, -s * 0.6); c.lineTo(s * 0.6, s * 0.6); c.stroke();
                    c.beginPath(); c.moveTo(s * 0.6, -s * 0.6); c.lineTo(-s * 0.6, s * 0.6); c.stroke();
                    c.setLineDash([]);
                    c.restore();
                    break;

                case 'resonance':
                    c.beginPath();
                    for (let i = 0; i < 360; i += 5) {
                        const rad = (i * Math.PI) / 180;
                        const r = s * 0.7 + Math.sin(rad * 12 + t * 6) * (s * 0.15);
                        c.lineTo(Math.cos(rad) * r, Math.sin(rad) * r);
                    }
                    c.closePath(); c.stroke();
                    c.beginPath(); c.arc(0, 0, s * 0.4, 0, 7); c.setLineDash([2, 5]); c.stroke(); c.setLineDash([]);
                    break;

                case 'arrow':
                    c.beginPath();
                    for (let i = 0; i < 40; i++) {
                        const ang = (i / 40) * Math.PI * 2 + t * 0.5;
                        const len = s * (0.5 + Math.random() * 0.5);
                        c.moveTo(Math.cos(ang) * (len * 0.8), Math.sin(ang) * (len * 0.8));
                        c.lineTo(Math.cos(ang) * len, Math.sin(ang) * len);
                    }
                    c.stroke();
                    c.beginPath(); c.moveTo(-s * 0.5, 0); c.lineTo(s * 0.5, 0); c.stroke();
                    c.lineTo(s * 0.4, -5); c.moveTo(s * 0.5, 0); c.lineTo(s * 0.4, 5); c.stroke();
                    break;

                case 'cosmic':
                    c.save();
                    for (let i = 0; i < 6; i++) {
                        c.rotate(Math.PI / 3);
                        c.beginPath();
                        c.moveTo(0, 0);
                        c.bezierCurveTo(s * 0.4, s * 0.3, s * 0.7, -s * 0.3, s, 0);
                        c.stroke();
                    }
                    c.beginPath(); c.arc(0, 0, s * 0.25, 0, 7); c.fillStyle = 'rgba(255,255,255,0.1)'; c.fill(); c.stroke();
                    c.restore();
                    break;

                case 'create_wave':
                    const pressure = parseFloat(c.canvas.dataset.pressure || 0);
                    for (let i = 1; i <= 5; i++) {
                        const phase = t * 1.5 + i * 0.8;
                        const r = s * (0.1 + (i / 5.0) * 0.8 + Math.sin(phase) * 0.04) * (1 + pressure * 0.5);
                        c.globalAlpha = Math.max(0, 0.7 * (1.0 - r / (s * 1.5)));
                        c.beginPath();
                        c.arc(0, 0, r, 0, Math.PI * 2);
                        c.stroke();
                        if (i === 1) {
                            c.globalAlpha = 0.05 + pressure * 0.15;
                            c.fill();
                        }
                    }
                    c.globalAlpha = 1.0;
                    break;
            }
        }

        // GRAND VIZ FUNCTIONS (Epic Scale)
        function getVizFns() {
            return {
                fabric: (c, w, h, t) => {
                    const hLine = h * 0.5;
                    c.strokeStyle = 'rgba(0,221,255,0.1)'; c.lineWidth = 1;

                    // 1. Digital Substrate Grid
                    c.beginPath();
                    for (let i = -w * 0.5; i <= w * 1.5; i += 50) {
                        c.moveTo(i, h);
                        c.lineTo(w / 2 + (i - w / 2) * 0.05, hLine);
                    }
                    const gridOffset = (t * 60) % 60;
                    for (let y = h; y > hLine; y -= 5 + (y - hLine) * 0.1) {
                        const yPos = y + gridOffset * ((y - hLine) / h);
                        if (yPos < h) {
                            c.moveTo(0, yPos); c.lineTo(w, yPos);
                        }
                    }
                    c.stroke();

                    // 2. Scanning Neon Pulse
                    const scanY = hLine + ((t * 0.5) % 1.0) * (h - hLine);
                    const grad = c.createLinearGradient(0, scanY - 30, 0, scanY + 30);
                    grad.addColorStop(0, 'rgba(0,221,255,0)');
                    grad.addColorStop(0.5, 'rgba(0,221,255,0.2)');
                    grad.addColorStop(1, 'rgba(0,221,255,0)');
                    c.fillStyle = grad;
                    c.fillRect(0, scanY - 30, w, 60);

                    // 3. Data Flow Particles
                    c.fillStyle = 'rgba(0,221,255,0.4)';
                    for (let i = 0; i < 200; i++) {
                        const seed = (i * 1234.5);
                        const x = (seed % w);
                        const y = (seed * t * 0.01) % hLine;
                        c.fillRect(x, y, 1, 1);
                    }
                },
                spacetime: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.lineCap = 'round';
                    c.lineJoin = 'round';
                    const color = '#ff6b9d';

                    // 1. The 4D Loaf (Temporal Z-Slices)
                    const sliceCount = 14;
                    for (let i = 0; i < sliceCount; i++) {
                        const depth = (t * 0.8 + i * 1.2) % (sliceCount * 1.2);
                        const z = depth / (sliceCount * 1.2); // 0 (near) to 1 (far)
                        const scale = 0.3 + (1.0 - z) * 1.8;
                        const alpha = Math.pow(1.0 - z, 1.5) * 0.4;

                        if (alpha <= 0.01) continue;

                        const sw = 450 * scale;
                        const sh = 280 * scale;

                        c.strokeStyle = color;
                        c.globalAlpha = alpha;
                        c.lineWidth = 1.2 * (1.0 - z);

                        // Main Frame
                        c.strokeRect(cx - sw / 2, cy - sh / 2, sw, sh);

                        // Corner Micro-Details
                        const ds = 12 * scale;
                        c.lineWidth = 2.5 * (1.0 - z);
                        // TL
                        c.beginPath(); c.moveTo(cx - sw / 2, cy - sh / 2 + ds); c.lineTo(cx - sw / 2, cy - sh / 2); c.lineTo(cx - sw / 2 + ds, cy - sh / 2); c.stroke();
                        // BR
                        c.beginPath(); c.moveTo(cx + sw / 2, cy + sh / 2 - ds); c.lineTo(cx + sw / 2, cy + sh / 2); c.lineTo(cx + sw / 2 - ds, cy + sh / 2); c.stroke();
                    }

                    // 2. Worldlines (Connecting the manifold)
                    c.globalAlpha = 0.1;
                    c.lineWidth = 0.5;
                    const worldlineCount = 16;
                    for (let i = 0; i < worldlineCount; i++) {
                        const angle = (i / worldlineCount) * Math.PI * 2;
                        const rx = Math.cos(angle);
                        const ry = Math.sin(angle);

                        c.beginPath();
                        const zStart = 0.05, zEnd = 0.95;
                        const sS = 0.3 + (1.0 - zStart) * 1.8;
                        const sE = 0.3 + (1.0 - zEnd) * 1.8;

                        c.moveTo(cx + rx * 225 * sS, cy + ry * 140 * sS);
                        c.lineTo(cx + rx * 225 * sE, cy + ry * 140 * sE);
                        c.stroke();
                    }

                    // 3. Temporal Jitter / Particles
                    for (let i = 0; i < 40; i++) {
                        const ang = i * 13.7 + t;
                        const dist = (i * 17.3 + t * 100) % 800;
                        const x = cx + Math.cos(ang) * dist;
                        const y = cy + Math.sin(ang) * (dist * 0.6);
                        c.fillStyle = color;
                        c.globalAlpha = 0.15 * (1.0 - dist / 800);
                        c.fillRect(x, y, 1.5, 1.5);
                    }
                    c.globalAlpha = 1.0;
                },
                blackhole: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.globalCompositeOperation = 'screen';

                    // 1. Accretion Swirls
                    for (let i = 0; i < 30; i++) {
                        c.beginPath();
                        c.ellipse(cx, cy, 350 - i * 8, 100 - i * 2, t * 0.4 + i * 0.1, 0, 7);
                        c.strokeStyle = `hsla(${20 + i}, 100%, 50%, 0.15)`;
                        c.lineWidth = 1.5;
                        c.stroke();
                    }

                    // 2. Gravitational Lensing Halo
                    const haloSize = 120 + Math.sin(t * 2) * 10;
                    const hGrad = c.createRadialGradient(cx, cy, 50, cx, cy, haloSize);
                    hGrad.addColorStop(0, 'rgba(0,0,0,1)');
                    hGrad.addColorStop(0.5, 'rgba(255,170,0,0.15)');
                    hGrad.addColorStop(1, 'rgba(0,0,0,0)');
                    c.fillStyle = hGrad;
                    c.beginPath(); c.arc(cx, cy, haloSize, 0, 7); c.fill();

                    c.globalCompositeOperation = 'source-over';
                    c.fillStyle = '#000';
                    c.beginPath(); c.arc(cx, cy, 55, 0, 7); c.fill();
                },
                expansion: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.fillStyle = 'rgba(255,100,50,0.8)';
                    const count = 1200;
                    for (let i = 0; i < count; i++) {
                        const seed = i * 137.5;
                        const ang = seed;
                        const speed = 1 + (seed % 3);
                        const dist = (t * 150 * speed + seed) % (Math.max(w, h) * 0.8);

                        const x = cx + Math.cos(ang) * dist;
                        const y = cy + Math.sin(ang) * dist;
                        const alpha = (1 - dist / (Math.max(w, h) * 0.8)) * 0.6;
                        c.globalAlpha = alpha;
                        c.fillRect(x, y, 1.5, 1.5);
                    }
                    c.globalAlpha = 1;
                },
                quantum: (c, w, h, t) => {
                    const rows = 12;
                    for (let j = 0; j < rows; j++) {
                        const rowY = h * 0.35 + (j / rows) * h * 0.3;
                        const alpha = (1 - Math.abs(j - rows / 2) / (rows / 2)) * 0.25;
                        c.strokeStyle = `rgba(0, 255, 170, ${alpha})`;
                        c.beginPath();
                        for (let x = 0; x <= w; x += 20) {
                            const phase = x * 0.008 + t * 2.5 + j * 0.6;
                            const amp = Math.sin(phase) * Math.cos(phase * 0.7) * 50;
                            const glitch = (Math.sin(x * 0.1 - t * 10) > 0.98) ? (Math.random() - 0.5) * 40 : 0;
                            c.lineTo(x, rowY + amp + glitch);
                        }
                        c.stroke();
                    }
                    // Animated Probability Points
                    c.fillStyle = 'rgba(0, 255, 170, 0.4)';
                    for (let i = 0; i < 40; i++) {
                        const x = (t * 100 + i * 200) % w;
                        const y = h * 0.5 + Math.sin(t + i) * 100;
                        c.beginPath(); c.arc(x, y, 1, 0, 7); c.fill();
                    }
                },
                resonance: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    const count = 20;
                    for (let i = 0; i < count; i++) {
                        const r = i * 30 + (t * 50) % 30;
                        const alpha = (1 - r / (w * 0.6)) * 0.2;
                        if (alpha <= 0) continue;

                        c.strokeStyle = `rgba(255, 0, 85, ${alpha})`;
                        c.beginPath();
                        for (let a = 0; a < Math.PI * 2; a += 0.2) {
                            const mod = Math.sin(a * 8 + t * 3) * 15;
                            const dr = r + mod;
                            c.lineTo(cx + Math.cos(a) * dr, cy + Math.sin(a) * dr * 0.5);
                        }
                        c.closePath(); c.stroke();

                        c.strokeStyle = `rgba(0, 221, 255, ${alpha * 0.8})`;
                        c.beginPath();
                        for (let a = 0; a < Math.PI * 2; a += 0.2) {
                            const mod = Math.sin(a * 8 + t * 3.1) * 12;
                            const dr = r + mod + 5;
                            c.lineTo(cx + Math.cos(a) * dr, cy + Math.sin(a) * dr * 0.5);
                        }
                        c.closePath(); c.stroke();
                    }
                },
                chaos: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.strokeStyle = 'rgba(255,80,80,0.2)';
                    for (let k = 0; k < 6; k++) {
                        c.beginPath();
                        for (let i = 0; i < 80; i++) {
                            const ang = t * 2 + i * 0.1 + k;
                            const r = (150 + Math.sin(t + i * 0.05) * 100) * (0.5 + k * 0.1);
                            c.lineTo(cx + Math.cos(ang) * r, cy + Math.sin(ang * 0.5) * r * 0.6);
                        }
                        c.stroke();
                    }
                },
                wormhole: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    for (let i = 0; i < 80; i++) {
                        const dist = 600 - (t * 300 + i * 25) % 600;
                        const scale = 600 / Math.max(1, dist);
                        const alpha = (dist / 600) * 0.4;
                        c.strokeStyle = `rgba(100,255,255,${alpha})`;
                        c.lineWidth = scale;
                        c.beginPath();
                        c.ellipse(cx, cy, 120 * scale, 60 * scale, t + dist * 0.01, 0, 7);
                        c.stroke();
                    }
                },
                uncertainty: (c, w, h, t) => {
                    c.fillStyle = 'rgba(255,255,255,0.03)';
                    for (let i = 0; i < 30; i++) {
                        const x = Math.random() * w;
                        const y = Math.random() * h;
                        const bw = Math.random() * 200;
                        const bh = 1 + Math.random() * 5;
                        if (Math.random() > 0.8) c.fillRect(x, y, bw, bh);
                    }
                },
                wave_theory: (c, w, h, t) => {
                    c.strokeStyle = 'rgba(255,255,255,0.15)';
                    for (let i = 0; i < 40; i++) {
                        c.beginPath();
                        for (let x = 0; x <= w; x += 30) {
                            const y = h * 0.5 + Math.sin(x * 0.005 + t + i * 0.3) * 60 + (i - 20) * 12;
                            c.lineTo(x, y);
                        }
                        c.stroke();
                    }
                },
                arrow: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.fillStyle = 'rgba(255,80,0,0.5)';
                    for (let i = 0; i < 1000; i++) {
                        const x = (t * 300 + i * 7) % (w + 400) - 200;
                        const chaos = Math.max(0, (x - w * 0.2) / (w * 0.8));
                        const dev = Math.pow(chaos, 2.5) * h * 0.6;
                        const y = cy + (Math.random() - 0.5) * dev;
                        c.globalAlpha = Math.max(0, 0.8 - chaos);
                        c.fillRect(x, y, 1.5, 1.5);
                    }
                    c.globalAlpha = 1;
                },
                cosmic: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.strokeStyle = 'rgba(0,100,255,0.1)';
                    for (let i = 0; i < 60; i++) {
                        const seed = i * 137.5;
                        const x = cx + Math.cos(seed + t * 0.05) * 300 * Math.sin(t * 0.1 + seed);
                        const y = cy + Math.sin(seed + t * 0.05) * 300;
                        for (let j = 1; j < 3; j++) {
                            const seed2 = (i + j) * 137.5;
                            const x2 = cx + Math.cos(seed2 + t * 0.05) * 300 * Math.sin(t * 0.1 + seed2);
                            const y2 = cy + Math.sin(seed2 + t * 0.05) * 300;
                            const d = Math.hypot(x - x2, y - y2);
                            if (d < 180) {
                                c.lineWidth = 1 - d / 180;
                                c.beginPath(); c.moveTo(x, y); c.lineTo(x2, y2); c.stroke();
                            }
                        }
                    }
                },
                create_wave: (c, w, h, t) => {
                    const topCanvas = c.canvas;
                    if (!topCanvas.parentElement) return;
                    const glCanvas = topCanvas.parentElement.querySelector('canvas[id^="viz-webgl-"]');
                    if (!glCanvas) return;
                    if (!glCanvas.fiveInitialized) {
                        initCreateWaveWebGL(glCanvas);
                        glCanvas.fiveInitialized = true;
                    }
                    if (glCanvas.width !== w || glCanvas.height !== h) {
                        glCanvas.width = w; glCanvas.height = h;
                    }
                    if (glCanvas.waveUniforms) {
                        glCanvas.waveUniforms.uTime.value = t;

                        // Interpolate mouse and pressure for smoothness
                        const targetX = parseFloat(topCanvas.dataset.mx || 0.5);
                        const targetY = parseFloat(topCanvas.dataset.my || 0.5);
                        const targetP = parseFloat(topCanvas.dataset.pressure || 0);

                        glCanvas.waveUniforms.uMouse.value.x += (targetX - glCanvas.waveUniforms.uMouse.value.x) * 0.15;
                        glCanvas.waveUniforms.uMouse.value.y += (targetY - glCanvas.waveUniforms.uMouse.value.y) * 0.15;
                        glCanvas.waveUniforms.uPressure.value += (targetP - glCanvas.waveUniforms.uPressure.value) * 0.15;
                    }
                }
            };
        }

        /**
         * WebGL Substrate for Haptic Interaction
         * Replaces the 2D ripple with a 3D deformed manifold
         */
        function initCreateWaveWebGL(canvas) {
            if (!window.THREE) return;

            const w = canvas.width;
            const h = canvas.height;
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(w, h);
            renderer.setPixelRatio(window.devicePixelRatio);

            const scene = new THREE.Scene();
            // Flat Layout for "Natural" Feel
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
            const geometry = new THREE.PlaneGeometry(2, 2);

            const uniforms = {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                uPressure: { value: 0 },
                uColor: { value: new THREE.Color(0x00ddff) }
            };
            canvas.waveUniforms = uniforms;

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                transparent: true,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec2 uMouse;
                    uniform float uPressure;
                    uniform vec3 uColor;
                    varying vec2 vUv;

                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
                    }

                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        vec2 u = f*f*(3.0-2.0*f);
                        return mix(mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), u.x),
                                   mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), u.x), u.y);
                    }

                    void main() {
                        vec2 uv = vUv;
                        float d = distance(uv, uMouse);
                        
                        // Layered Natural Waves
                        float n = noise(uv * 4.0 + uTime * 0.3) * 0.1;
                        n += noise(uv * 8.0 - uTime * 0.5) * 0.05;
                        
                        // Dynamic Ripple based on Pressure
                        float ripple = sin(d * 50.0 - uTime * 10.0) * 0.5 + 0.5;
                        ripple *= exp(-d * 4.0);
                        
                        float intensity = 0.1 + uPressure * 2.5;
                        float field = n + ripple * intensity;
                        
                        vec3 color = mix(vec3(0.0, 0.05, 0.1), uColor, field);
                        color += vec3(0.5, 0.0, 1.0) * pow(field, 4.0); // Spectral peaks
                        
                        float alpha = clamp(field * 1.2, 0.0, 0.85);
                        gl_FragColor = vec4(color, alpha);
                    }
                `
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            function animate() {
                if (!canvas.parentElement) return;
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
                if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }
            animate();
        }
    </script>
</body>

</html>