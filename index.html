<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <!-- PWA / iOS Capabilities -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Waveism">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-180.png">
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- Aggressive Anti-Cache -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <meta name="description"
        content="Explore the unified field theory of waves - from quantum mechanics to cosmic expansion. An interactive physics visualization experience.">
    <title>Waveism | Epistemic Interface</title>

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://waveism.app/">
    <meta property="og:title" content="Waveism | Unified Field Theory Dashboard">
    <meta property="og:description"
        content="Explore the unified field theory of waves - from quantum mechanics to cosmic expansion. An interactive physics visualization experience.">
    <meta property="og:image" content="https://waveism.app/assets/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Waveism | Unified Field Theory Dashboard">
    <meta name="twitter:description"
        content="Explore the unified field theory of waves - from quantum mechanics to cosmic expansion.">
    <meta name="twitter:image" content="https://waveism.app/assets/og-image.png">

    <script>
        // Register Service Worker for Offline PWA Support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('[Waveism] Service Worker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.warn('[Waveism] Service Worker registration failed:', error);
                    });
            });
        }
    </script>

    <style>
        html,
        body {
            background: #000 !important;
            font-display: block;
        }
    </style>
    <link rel="stylesheet" href="components/shared.css?v=2">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="components/shared.js?v=2"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&family=JetBrains+Mono:wght@300;400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg: #000508;
            --accent: #00ddff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            color: #fff;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            /* iOS Safe Area */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* Glitch Overlay */
        .scanlines {
            position: fixed;
            inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0.15;
            user-select: none;
        }

        /* CONTAINER (The Reel) */
        #reel {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            height: 100%;
            /* Relative to safe body */
            width: 100vw;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE/Edge */
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            /* Momentum Scroll */
        }

        /* SEAMLESS FULLSCREEN LAYOUT */
        .section {
            position: relative;
            flex: 0 0 100vw;
            height: 100%;
            scroll-snap-align: center;
            scroll-snap-stop: always;
            overflow: hidden;
            background: transparent;
        }

        /* CANVAS (Sky + Persona) */
        .viz-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 1;
            /* Fully visible */
            filter: contrast(1.2) brightness(1.2);
            /* Enhance pop */
        }

        /* CONTENT (Locked to Bottom) */
        .content {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(40px);
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 25px;
            /* Improved vertical spacing */
        }

        .section.active .content {
            opacity: 1;
            transform: translateX(-50%);
            transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .phase-meta {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--accent);
            letter-spacing: 0.4em;
            text-transform: uppercase;
            margin-bottom: 5px;
            opacity: 0.8;
            text-shadow: 0 0 10px var(--accent);
        }

        /* CYBER TITLE LINK */
        .phase-link {
            pointer-events: auto;
            text-decoration: none;
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .phase-title {
            font-family: 'JetBrains Mono', monospace;
            /* Cyber Mono */
            font-size: 5rem;
            font-weight: 700;
            letter-spacing: -0.04em;
            color: #fff;
            margin: 0;
            text-transform: uppercase;
            /* Glitchy Text Shadow */
            text-shadow: 2px 0 var(--accent), -2px 0 rgba(255, 0, 255, 0.5);
            background: linear-gradient(180deg, #fff 0%, #ccc 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            transition: all 0.3s ease;
        }

        .phase-link:hover .phase-title {
            text-shadow: 4px 0 var(--accent), -4px 0 rgba(255, 0, 255, 0.7);
            letter-spacing: 0.05em;
            transform: scale(1.02);
            -webkit-text-fill-color: #fff;
        }

        .phase-desc {
            display: block;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            margin: 0;
            max-width: 600px;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px 24px;
            border-radius: 4px;
            backdrop-filter: blur(12px);
            text-align: center;
        }

        .phase-question {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--accent);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 4px;
            opacity: 0.9;
        }

        .enter-btn {
            display: none;
        }

        /* Removed */

        .enter-btn:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            box-shadow: 0 0 30px var(--accent);
        }

        /* Remove old UI clutter */
        .horizon-line,
        .floor-grid {
            display: none;
        }

        /* HEADER & HUD */
        header {
            position: fixed;
            top: 40px;
            left: 40px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            letter-spacing: 0.3em;
            color: #fff;
            z-index: 100;
        }

        .hud-pager {
            position: fixed;
            bottom: 30px;
            right: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
            z-index: 100;
        }

        /* Nav Arrows - Explicit Affordance */
        .nav-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 80px;
            /* Larger Touch Target */
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 50;
            color: rgba(255, 255, 255, 0.2);
            font-size: 2rem;
            transition: all 0.3s;
            user-select: none;
            background: rgba(0, 0, 0, 0.01);
            /* Hitbox fill */
            border-radius: 50%;
            -webkit-tap-highlight-color: transparent;
        }

        .nav-arrow:active {
            color: var(--accent);
            transform: translateY(-50%) scale(0.9);
            background: rgba(0, 221, 255, 0.1);
        }

        .nav-arrow:hover {
            color: var(--accent);
        }

        .nav-arrow.left {
            left: 20px;
        }

        .nav-arrow.right {
            right: 20px;
        }

        /* PROGRESS BAR */
        .progress-track {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 600px) {
            .phase-title {
                font-size: 2.2rem;
            }

            .content {
                bottom: max(40px, env(safe-area-inset-bottom) + 20px);
                padding: 15px;
                gap: 15px;
            }

            .phase-desc {
                font-size: 0.75rem;
                max-width: 85%;
            }
        }

        #reel .section[data-id="create_wave"] {
            background: #000 !important;
        }

        #reel .section[data-id="create_wave"] .create-wave-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 0.5em;
            pointer-events: none;
            z-index: 5;
            text-align: center;
            animation: pulseHint 3s infinite ease-in-out;
        }

        @keyframes pulseHint {

            0%,
            100% {
                opacity: 0.1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .content.hidden {
            display: none !important;
        }

        #reel .section[data-id="create_wave"] .create-wave-hint {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.3em;
            pointer-events: none;
            z-index: 5;
            text-align: center;
        }

        #reel .section[data-id="create_wave"] .back-arrow-hint {
            position: absolute;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.2);
            animation: slideBack 2s infinite ease-in-out;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes slideBack {

            0%,
            100% {
                transform: translate(0, -50%);
                opacity: 0.1;
            }

            50% {
                transform: translate(-15px, -50%);
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="nav-container"></div>
    <div class="scanlines"></div>

    <header>WAVEISM // MANIFOLD</header>

    <!-- Native Scroll Container -->
    <div id="reel">
        <!-- Rendered by JS -->
    </div>

    <!-- HUD Elements -->
    <div class="nav-arrow left" id="nav-l">❮</div>
    <div class="nav-arrow right" id="nav-r">❯</div>

    <script>
        const phases = [
            { id: 'quantum', title: 'QUANTUM', question: 'Can you be in two places?', desc: 'Non-local field superposition and wave function collapse.', color: '#00ffaa' },
            { id: 'uncertainty', title: 'UNCERTAINTY', question: 'Is reality fundamentally blurry?', desc: 'The fundamental limit of precision in the vacuum.', color: '#9d4edd' },
            { id: 'wave_theory', title: 'WAVEISM', question: 'Is everything just a vibration?', desc: 'Unified framework of oscillatory reality.', color: '#7b2cbf' },
            { id: 'resonance', title: 'RESONANCE', question: 'Why does energy amplify?', desc: 'Coherent interference and entrainment protocols.', color: '#ff0055' },
            { id: 'chaos', title: 'CHAOS', question: 'Can a butterfly cause a storm?', desc: 'Non-linear dynamics and strange attractors.', color: '#ff4d6d' },
            { id: 'arrow', title: 'ARROW', question: 'Why can\'t we reverse time?', desc: 'Entropy drift and the thermodynamic direction.', color: '#ff5500' },
            { id: 'fabric', title: 'FABRIC', question: 'What is empty space made of?', desc: 'The metric tensor substrate of reality.', color: '#00ddff' },
            { id: 'wormhole', title: 'WORMHOLE', question: 'Are there shortcuts in space?', desc: 'Topological bridges through the manifold.', color: '#4cc9f0' },
            { id: 'spacetime', title: 'SPACETIME', question: 'Is the future already written?', desc: 'The 4D continuum of light cones and worldlines.', color: '#ff6b9d' },
            { id: 'blackhole', title: 'BLACK HOLE', question: 'What happens if you fall in?', desc: 'Infinite curvature and causal singularities.', color: '#ffaa00' },
            { id: 'expansion', title: 'EXPANSION', question: 'Where is the universe going?', desc: 'Metric acceleration of the cosmic substrate.', color: '#b5179e' },
            { id: 'cosmic', title: 'COSMIC', question: 'What does the universe look like?', desc: 'Large-scale structure of galactic filaments.', color: '#0088ff' },
            { id: 'create_wave', title: 'CREATE A WAVE', question: 'Can you trigger a ripple?', desc: 'Manual interaction with the cosmic medium.', color: '#ffffff' }
        ];

        const reel = document.getElementById('reel');
        let time = 0;
        const W = window.innerWidth;

        document.getElementById('nav-container').innerHTML = renderMainNav('index');

        // Prepare Infinite List: [Last, ...Originals, First]
        const displayPhases = [phases[phases.length - 1], ...phases, phases[0]];

        // Build DOM
        displayPhases.forEach((p, i) => {
            const sec = document.createElement('section');
            sec.className = 'section';
            sec.dataset.id = p.id;
            sec.style.background = 'transparent';
            sec.id = 'sec-' + i;

            // Map to real index (0-11) for HUD/Logic
            // 0 -> Clone(11), 1 -> 0, ... 12 -> 11, 13 -> Clone(0)
            const realIndex = (i - 1 + phases.length) % phases.length;
            sec.dataset.realIndex = realIndex;

            // NEW: Dual-Layer Architecture for Create Wave to prevent Context Conflict
            // Layer 0: WebGL Substrate (Background)
            if (p.id === 'create_wave') {
                const glCanvas = document.createElement('canvas');
                glCanvas.className = 'viz-canvas';
                glCanvas.id = `viz-webgl-${i}`;
                glCanvas.style.zIndex = 1; // Behind UI
                glCanvas.style.pointerEvents = 'none'; // Pass-through
                sec.appendChild(glCanvas);
            }

            // Layer 1: 2D UI & Interaction (Foreground)
            const canvas = document.createElement('canvas');
            canvas.className = 'viz-canvas';
            canvas.id = `viz-${i}`;
            canvas.dataset.vizId = p.id;
            canvas.style.zIndex = 2; // On top
            canvas.style.cursor = 'pointer';

            let currentForce = 0;
            let forceTimeout = null;

            canvas.onpointerdown = (e) => {
                if (p.id === 'create_wave') {
                    if (navigator.vibrate) navigator.vibrate(20);
                    // Click simulation: Boost intensity immediately
                    currentForce = 0.5;
                    canvas.dataset.intensity = currentForce;

                    // Shake effect trigger in shader via intensity
                    if (forceTimeout) clearTimeout(forceTimeout);
                }
            };
            canvas.onpointermove = (e) => {
                if (p.id === 'create_wave' && e.buttons > 0) {
                    currentForce = e.webkitForce || 0.6;
                    canvas.dataset.intensity = currentForce;
                    if (navigator.vibrate) navigator.vibrate(5);
                }
            };
            canvas.onpointerup = canvas.onpointerleave = (e) => {
                if (p.id === 'create_wave') {
                    // Gradual fade out for the 'click' pulse
                    forceTimeout = setInterval(() => {
                        currentForce *= 0.9;
                        canvas.dataset.intensity = currentForce;
                        if (currentForce < 0.01) {
                            currentForce = 0;
                            canvas.dataset.intensity = 0;
                            clearInterval(forceTimeout);
                        }
                    }, 16);
                }
            };
            canvas.addEventListener('webkitmouseforcechanged', (e) => {
                if (p.id === 'create_wave') {
                    canvas.dataset.intensity = e.webkitForce;
                }
            });

            canvas.onclick = () => {
                if (p.id !== 'create_wave') window.location.href = p.id + '.html';
            };
            sec.appendChild(canvas);

            const content = document.createElement('div');
            content.className = 'content' + (p.id === 'create_wave' ? ' hidden' : '');
            content.innerHTML = `
                <div class="phase-question">${p.question}</div>
                <a href="${p.id}.html" class="phase-link"><h1 class="phase-title">${p.title}</h1></a>
                <div class="phase-desc">${p.desc}</div>
            `;
            sec.appendChild(content);
            if (p.id === 'create_wave') {
                const hint = document.createElement('div');
                hint.className = 'create-wave-hint';
                hint.innerHTML = 'ENGAGE FORCE FEEDBACK<br><span style="font-size: 0.5rem; opacity: 0.5; letter-spacing: 0.1em;">(DRAG TO DEFORM SUBSTRATE)</span>';
                sec.appendChild(hint);

                const backHint = document.createElement('div');
                backHint.className = 'back-arrow-hint';
                backHint.style.pointerEvents = 'auto';
                backHint.style.cursor = 'pointer';
                backHint.innerText = '❮';
                backHint.onclick = (e) => {
                    e.stopPropagation();
                    scrollPrev();
                };
                sec.appendChild(backHint);
            }

            reel.appendChild(sec);
        });

        // Initial Position (Skip first clone)
        if ('scrollRestoration' in history) history.scrollRestoration = 'manual';

        // Robust Initial Scroll Logic to Start at WAVEISM (Index 1)
        window.addEventListener('load', () => {
            isTeleporting = true;
            reel.style.scrollBehavior = 'auto';

            const startPos = window.innerWidth;
            reel.scrollLeft = startPos;
            reel.scrollTo(startPos, 0);

            // Immediate HUD sync for Waveism
            updateHUD(0);

            setTimeout(() => {
                isTeleporting = false;
                reel.style.overflowX = 'auto';
            }, 100);
        });

        const indexStars = initGlobalStarField('background-stars');

        // Infinite Scroll Teleport
        let isTeleporting = false;
        reel.addEventListener('scroll', () => {
            if (isTeleporting) return;

            const totalW = displayPhases.length * W;
            // Left Edge (Clone Last) -> Jump to Real Last
            if (reel.scrollLeft < 10) {
                isTeleporting = true;
                reel.scrollLeft = (displayPhases.length - 2) * W;
                setTimeout(() => isTeleporting = false, 50);
            }
            // Right Edge (Clone First) -> Jump to Real First
            else if (reel.scrollLeft > (displayPhases.length - 1) * W - 10) {
                isTeleporting = true;
                reel.scrollLeft = W;
                setTimeout(() => isTeleporting = false, 50);
            }

            // Sync Stars with Scroll
            if (indexStars) {
                indexStars.targetOffsetX = (reel.scrollLeft / reel.scrollWidth) * window.innerWidth * 0.5;
            }
        });

        // Vertical Wheel -> Page Turn (Throttled)
        let lastWheel = 0;
        window.addEventListener('wheel', (e) => {
            // High threshold for touchpads doing momentum
            if (Date.now() - lastWheel < 100) return;

            if (e.deltaY !== 0) {
                if (Math.abs(e.deltaY) > 20) {
                    lastWheel = Date.now();
                    if (e.deltaY > 0) scrollNext();
                    else scrollPrev();
                }
                e.preventDefault();
            }
        }, { passive: false });

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(e => {
                if (e.isIntersecting) {
                    e.target.classList.add('active');
                    // Update HUD only when significantly visible
                    if (e.intersectionRatio > 0.5) {
                        const realIdx = parseInt(e.target.dataset.realIndex);
                        updateHUD(realIdx);
                        lastActiveSectionId = e.target.id;
                    }
                } else {
                    // Slight buffer before removing active state
                    if (e.intersectionRatio < 0.1) {
                        e.target.classList.remove('active');
                    }
                }
            });
        }, { threshold: [0, 0.1, 0.5, 0.9, 1.0] });
        let lastActiveSectionId = null;
        document.querySelectorAll('.section').forEach(s => observer.observe(s));
        document.querySelectorAll('.section').forEach(s => observer.observe(s));

        function updateHUD(idx) {
            document.getElementById('pager').innerText = `${String(idx + 1).padStart(2, '0')} / ${phases.length}`;
            const pct = ((idx + 1) / phases.length) * 100;
            document.getElementById('progress').style.width = pct + '%';
            document.getElementById('progress').style.backgroundColor = phases[idx].color;
            document.documentElement.style.setProperty('--accent', phases[idx].color);
        }

        // Nav Helpers
        function scrollNext() { reel.scrollBy({ left: W, behavior: 'smooth' }); }
        function scrollPrev() { reel.scrollBy({ left: -W, behavior: 'smooth' }); }

        document.getElementById('nav-l').onclick = scrollPrev;
        document.getElementById('nav-r').onclick = scrollNext;

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') scrollPrev();
            if (e.key === 'ArrowRight') scrollNext();
            if (e.key === 'Enter') {
                const centerIdx = Math.round(reel.scrollLeft / W);
                const p = displayPhases[centerIdx];
                if (p) window.location.href = p.id + '.html';
            }
        });

        // VIZ ANIMATION
        const visFns = getVizFns();

        function loop() {
            time += 0.002; // Slower, more majestic (approx 1 second pulses)

            document.querySelectorAll('.section.active canvas:not([id^="viz-webgl"])').forEach(c => {
                const vizId = c.dataset.vizId;
                const phase = phases.find(p => p.id === vizId);

                // Find the index of the current phase to scale 't'
                const phaseIndex = phases.findIndex(p => p.id === vizId);
                const ranking = (phaseIndex !== -1 ? phaseIndex + 1 : 1) * 0.5; // Speed factor based on rank, default to 0.5 if not found
                const scaledT = time * ranking;

                // Resize check
                if (c.width !== W || c.height !== window.innerHeight) {
                    c.width = W; c.height = window.innerHeight;
                }
                const ctx = c.getContext('2d');
                const w = c.width;
                const h = c.height;

                ctx.clearRect(0, 0, w, h);

                // Draw subtle horizon glow for depth (no wave)
                const hLine = h * 0.62;
                const grad = ctx.createLinearGradient(0, hLine - 100, 0, hLine + 100);
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(0.5, phase ? phase.color + '22' : 'rgba(255,255,255,0.05)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, hLine - 100, w, 200);

                // Draw Viz
                if (visFns[vizId]) {
                    visFns[vizId](ctx, w, h, scaledT);
                }

                // Draw Totem
                drawTotem(ctx, w, h, scaledT, vizId, phase ? phase.color : '#fff');
            });
            requestAnimationFrame(loop);
        }
        loop();

        // PROCEDURAL SEA
        function drawSea(c, w, h, t, color) {
            const hLine = h * 0.5; // Dead Center Horizon

            c.fillStyle = '#010105';
            c.beginPath();
            c.moveTo(0, h);
            c.lineTo(0, hLine);

            for (let x = 0; x <= w; x += 10) {
                const y = hLine + Math.sin(x * 0.005 + t) * 20 + Math.cos(x * 0.02 - t * 0.3) * 10;
                c.lineTo(x, y);
            }

            c.lineTo(w, h);
            c.fill();

            // Neon Edge
            c.strokeStyle = color;
            c.lineWidth = 2;
            c.shadowBlur = 30; c.shadowColor = color;
            c.beginPath();
            for (let x = 0; x <= w; x += 10) {
                const y = hLine + Math.sin(x * 0.005 + t) * 20 + Math.cos(x * 0.02 - t * 0.3) * 10;
                x === 0 ? c.moveTo(x, y) : c.lineTo(x, y);
            }
            c.stroke();
            c.shadowBlur = 0;
        }

        // TOTEM ARTIFACTS
        function drawTotem(c, w, h, t, id, color) {
            const cx = w / 2;
            // Stand on the waves (Centered)
            const hLine = h * 0.5 + Math.sin(cx * 0.005 + t) * 20 + Math.cos(cx * 0.02 - t * 0.3) * 10;
            const size = h * 0.15; // Slightly tighter scale for better fit

            c.save();
            c.translate(cx, hLine - size * 0.8);

            // Reflection
            c.save();
            c.scale(1, -0.5);
            c.translate(0, -size * 1.5);
            c.globalAlpha = 0.2;
            c.filter = 'blur(8px)';
            drawSymbol(c, t, id, color, size);
            c.restore();

            // The Artifact
            c.shadowBlur = 40; c.shadowColor = color;
            drawSymbol(c, t, id, color, size);

            // LABEL MAIN
            c.shadowBlur = 0;
            c.fillStyle = 'rgba(255,255,255,0.9)';
            c.font = '500 14px "JetBrains Mono"';
            c.textAlign = 'center';
            c.letterSpacing = '2px';
            c.fillText(id.toUpperCase().replace('_', ' '), 0, size * 0.8);

            // LABEL SUB (Tech Data)
            c.fillStyle = color;
            c.font = '300 11px "JetBrains Mono"';
            c.letterSpacing = '1px';

            const techData = {
                fabric: "METRIC TENSOR G\u1D6D\u1D78",
                spacetime: "MINKOWSKI METRIC",
                blackhole: "SCHWARZSCHILD RS",
                quantum: "WAVE FUNCTION \u03A8",
                resonance: "EIGENFREQUENCY \u03BB",
                wormhole: "EINSTEIN-ROSEN",
                chaos: "STRANGE ATTRACTOR",
                expansion: "HUBBLE PARAM H\u2080",
                uncertainty: "\u0394x\u0394p \u2265 \u210F/2",
                wave_theory: "SUPERPOSITION",
                arrow: "S = k log W",
                cosmic: "LARGE SCALE STRUCTURE",
                create_wave: "HAPTIC RIPPLE \u03A3"
            };

            c.fillText(techData[id] || "ANALYZING...", 0, size * 0.8 + 14);

            c.restore();
        }

        function drawSymbol(c, t, id, color, s) {
            c.strokeStyle = color;
            c.fillStyle = '#000';
            c.lineWidth = 3;

            switch (id) {
                case 'wave_theory': // OSCILLATOR COLUMN
                    for (let i = -2; i <= 2; i++) {
                        c.beginPath();
                        for (let y = -s; y <= s; y += 5) {
                            c.lineTo(i * 20 + Math.sin(y * 0.1 - t * 3) * 15, y);
                        }
                        c.stroke();
                    }
                    break;

                case 'fabric': // ROTATING TESSERACT CUBE
                    c.save();
                    c.rotate(t * 0.5);
                    c.beginPath(); c.rect(-s * 0.5, -s * 0.5, s, s); c.stroke(); // Inner
                    c.rotate(t * 0.2);
                    c.beginPath(); c.rect(-s * 0.8, -s * 0.8, s * 1.6, s * 1.6); c.stroke(); // Outer
                    // Connectors
                    c.moveTo(-s * 0.5, -s * 0.5); c.lineTo(-s * 0.8, -s * 0.8);
                    c.moveTo(s * 0.5, -s * 0.5); c.lineTo(s * 0.8, -s * 0.8);
                    c.moveTo(s * 0.5, s * 0.5); c.lineTo(s * 0.8, s * 0.8);
                    c.moveTo(-s * 0.5, s * 0.5); c.lineTo(-s * 0.8, s * 0.8);
                    c.stroke();
                    c.restore();
                    break;

                case 'chaos': // STRANGE ATTRACTOR KNOT
                    c.beginPath();
                    for (let i = 0; i < 100; i++) {
                        const ang = t + i * 0.1;
                        const r = s * Math.cos(2 * ang); // Rose curve
                        c.lineTo(r * Math.cos(ang), r * Math.sin(ang));
                    }
                    c.closePath(); c.stroke();
                    break;

                case 'spacetime': // HOURGLASS
                    c.beginPath();
                    c.moveTo(-s * 0.5, -s); c.lineTo(s * 0.5, -s); // Top
                    c.lineTo(0, 0); c.lineTo(s * 0.5, s); // Bottom
                    c.lineTo(-s * 0.5, s); c.lineTo(0, 0); c.closePath();
                    c.fill(); c.stroke();
                    // Sand
                    c.beginPath(); c.moveTo(0, 0); c.lineTo(0, s); c.stroke();
                    break;

                case 'blackhole': // SINGULARITY EYE
                    c.fillStyle = '#000'; c.beginPath(); c.arc(0, 0, s * 0.6, 0, 7); c.fill();
                    c.strokeStyle = color; c.lineWidth = 4;
                    c.beginPath(); c.arc(0, 0, s * 0.6, 0, 7); c.stroke();
                    c.lineWidth = 2;
                    c.beginPath(); c.ellipse(0, 0, s, s * 0.2, t * 2, 0, 7); c.stroke(); // Accretion
                    c.beginPath(); c.ellipse(0, 0, s, s * 0.2, -t * 2, 0, 7); c.stroke();
                    break;

                case 'expansion': // NOVA SPIKES
                    c.save(); c.rotate(t);
                    for (let i = 0; i < 8; i++) {
                        c.rotate(Math.PI / 4);
                        c.beginPath(); c.moveTo(0, 0); c.lineTo(0, -s); c.stroke();
                        c.beginPath(); c.arc(0, -s, 5, 0, 7); c.fill();
                    }
                    c.restore();
                    // Pulse core
                    c.beginPath(); c.arc(0, 0, s * 0.3 + Math.sin(t * 10) * 10, 0, 7); c.stroke();
                    break;

                case 'wormhole': // GATE RINGS
                    for (let i = 0; i < 5; i++) {
                        c.beginPath();
                        c.ellipse(0, 0, s * (0.2 + i * 0.2), s * (0.1 + i * 0.1), t * (i % 2 ? -1 : 1), 0, 7);
                        c.stroke();
                    }
                    break;

                case 'quantum': // ATOM
                    c.beginPath(); c.arc(0, 0, 10, 0, 7); c.fill(); c.stroke();
                    for (let i = 0; i < 3; i++) {
                        c.beginPath();
                        c.ellipse(0, 0, s, s * 0.3, t * 2 + i * (Math.PI / 1.5), 0, 7);
                        c.stroke();
                        // Electron
                        const ang = t * 5 + i * 100; // Fake pos
                        // c.beginPath(); c.arc(Math.cos(ang), Math.sin(ang), 5, 0, 7); c.fill();
                    }
                    break;

                case 'uncertainty': // GLITCH BOX
                    c.save();
                    if (Math.random() > 0.9) c.translate((Math.random() - 0.5) * 20, 0);
                    c.beginPath(); c.rect(-s * 0.5, -s * 0.5, s, s); c.stroke();
                    c.beginPath(); c.moveTo(-s * 0.5, -s * 0.5); c.lineTo(s * 0.5, s * 0.5); c.stroke();
                    c.restore();
                    break;

                case 'resonance': // CYMATIC MANDALA
                    c.beginPath();
                    for (let i = 0; i < 360; i += 10) {
                        const rad = (i * Math.PI) / 180;
                        const r = s * 0.5 + Math.sin(rad * 8 + t * 5) * 20;
                        c.lineTo(Math.cos(rad) * r, Math.sin(rad) * r);
                    }
                    c.closePath(); c.stroke();
                    break;

                case 'arrow': // DECAY
                    c.beginPath();
                    for (let i = 0; i < 50; i++) {
                        const ang = Math.random() * 7;
                        const rad = Math.random() * s;
                        c.moveTo(Math.cos(ang) * rad, Math.sin(ang) * rad);
                        c.lineTo(Math.cos(ang) * (rad + 5), Math.sin(ang) * (rad + 5));
                    }
                    c.stroke();
                    break;

                case 'cosmic': // WEB
                    c.beginPath();
                    for (let i = 0; i < 8; i++) {
                        c.rotate(Math.PI / 4);
                        c.moveTo(0, 0); c.bezierCurveTo(s / 2, s / 4, s / 2, -s / 4, s, 0);
                    }
                    c.stroke();
                    c.beginPath(); c.arc(0, 0, s * 0.2, 0, 7); c.fill();
                    break;
                case 'create_wave':
                    c.beginPath();
                    const intensity = parseFloat(c.canvas ? (c.canvas.dataset.intensity || 0) : 0);
                    for (let i = 0; i < 6; i++) {
                        const r = s * (0.2 + i * 0.2) * (1 + intensity * 0.5);
                        c.moveTo(r, 0);
                        c.arc(0, 0, r, 0, Math.PI * 2);
                    }
                    c.stroke();
                    break;
            }
        }

        // GRAND VIZ FUNCTIONS (Epic Scale)
        function getVizFns() {
            return {
                fabric: (c, w, h, t) => {
                    c.strokeStyle = 'rgba(0,221,255,0.15)'; c.lineWidth = 1;
                    // Infinite 3D Grid Floor & Ceiling
                    const horizon = h * 0.5;
                    c.beginPath();
                    // Vertical perspective lines
                    for (let i = -w; i <= w * 2; i += 60) {
                        c.moveTo(i, h);
                        c.lineTo(w / 2 + (i - w / 2) * 0.1, horizon);
                    }
                    // Horizontal moving lines
                    const offset = (t * 50) % 50;
                    for (let y = h; y > horizon; y -= 10 + (y - horizon) * 0.1) {
                        const yPos = y + offset * ((y - horizon) / h);
                        if (yPos < h) {
                            c.moveTo(0, yPos); c.lineTo(w, yPos);
                        }
                    }
                    c.stroke();

                    // Floating Data Particles
                    c.fillStyle = 'rgba(0,221,255,0.5)';
                    for (let i = 0; i < 300; i++) {
                        const x = Math.random() * w;
                        const y = Math.random() * horizon;
                        c.fillRect(x, y + Math.sin(t + x) * 10, 1 + Math.random() * 2, 1);
                    }
                },
                spacetime: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.strokeStyle = 'rgba(255,107,157,0.4)';
                    c.lineWidth = 2;
                    c.lineCap = 'round';

                    // Warp Speed Tunnel
                    const count = 60;
                    for (let i = 0; i < count; i++) {
                        const ang = (i / count) * Math.PI * 2;
                        const rx = Math.cos(ang);
                        const ry = Math.sin(ang);
                        const depth = (t * 500 + i * 100) % 2000;
                        const scale = 2000 / (2000 - depth);

                        const x = cx + rx * 20 * scale;
                        const y = cy + ry * 20 * scale;
                        const len = scale * 40;

                        c.beginPath();
                        c.moveTo(x, y);
                        c.lineTo(x + rx * len, y + ry * len);
                        c.globalAlpha = Math.min(1, scale * 0.1);
                        c.stroke();
                    }
                    c.globalAlpha = 1;
                },
                blackhole: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    // Accretion Disk (Layers)
                    for (let i = 0; i < 40; i++) {
                        c.beginPath();
                        c.ellipse(cx, cy, 300 - i * 5, 80 - i * 1.5, t * 0.5 + i * 0.05, 0, 7);
                        c.strokeStyle = `rgba(255, ${150 + i * 2}, 0, ${0.1 + i * 0.01})`;
                        c.stroke();
                    }

                    // Infalling Stars
                    c.fillStyle = '#fff';
                    for (let i = 0; i < 600; i++) {
                        const angle = Math.random() * 7;
                        const dist = 50 + (t * 200 + i * 20) % 800;
                        const spiral = angle + 200 / dist;
                        const x = cx + Math.cos(spiral) * dist;
                        const y = cy + Math.sin(spiral) * dist * 0.3; // Perspective
                        c.globalAlpha = Math.min(1, dist / 800);
                        c.fillRect(x, y, 1.5, 1.5);
                    }
                    c.globalAlpha = 1;

                    // Event Horizon Shadow
                    c.fillStyle = '#000'; c.shadowBlur = 80; c.shadowColor = '#ffaa00';
                    c.beginPath(); c.arc(cx, cy, 50, 0, 7); c.fill(); c.shadowBlur = 0;
                },
                expansion: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    c.fillStyle = 'rgba(255,100,50,0.8)';
                    // Big Bang Explosion
                    for (let i = 0; i < 1500; i++) {
                        const angle = Math.random() * 7;
                        const speed = 1 + Math.random() * 4;
                        const dist = (t * 100 * speed + i * 10) % (Math.max(w, h));

                        const x = cx + Math.cos(angle) * dist;
                        const y = cy + Math.sin(angle) * dist;

                        c.globalAlpha = 1 - (dist / Math.max(w, h));
                        const size = (dist / 100) * 1.5;
                        c.fillRect(x, y, size, size);
                    }
                    c.globalAlpha = 1;
                },
                quantum: (c, w, h, t) => {
                    // Dirac Sea / Field Fluctuations
                    const rows = 15;
                    for (let j = 0; j < rows; j++) {
                        const rowY = h * 0.3 + (j / rows) * h * 0.4;
                        const alpha = (1 - Math.abs(j - rows / 2) / (rows / 2)) * 0.2;
                        c.strokeStyle = `rgba(0, 255, 170, ${alpha})`;
                        c.lineWidth = 1;
                        c.beginPath();
                        for (let x = 0; x <= w; x += 15) {
                            const phase = x * 0.01 + t * 2 + j * 0.5;
                            const amp = Math.sin(phase) * Math.cos(phase * 0.5) * 40;
                            // Add "Quantum Foam" spikes
                            const noise = Math.sin(x * 0.1 - t * 5) * 5;
                            c.lineTo(x, rowY + amp + noise);
                        }
                        c.stroke();
                    }
                    // Virtual Particle Pairs
                    c.fillStyle = 'rgba(0, 255, 170, 0.4)';
                    for (let i = 0; i < 50; i++) {
                        const x = (Math.sin(i + t) * 0.5 + 0.5) * w;
                        const y = (Math.cos(i * 1.5 + t * 0.5) * 0.5 + 0.5) * h;
                        const size = Math.random() * 2;
                        c.beginPath();
                        c.arc(x, y, size, 0, Math.PI * 2);
                        c.fill();
                    }
                },
                resonance: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    // Cymatic Manifold
                    c.lineWidth = 1.5;
                    const count = 25;
                    for (let i = 0; i < count; i++) {
                        const r = i * 25 + (t * 40) % 25;
                        const alpha = (1 - r / (w * 0.8)) * 0.3;
                        if (alpha <= 0) continue;

                        // Chromatic Aberration Layers
                        ['#ff0055', '#00ddff'].forEach((color, ci) => {
                            c.strokeStyle = color;
                            c.globalAlpha = alpha * 0.5;
                            c.beginPath();
                            for (let ang = 0; ang < Math.PI * 2; ang += 0.1) {
                                // Modulate radius by harmonics
                                const harmonic = Math.sin(ang * 6 + t * 2) * 15 + Math.sin(ang * 12 - t) * 5;
                                const dr = r + harmonic + (ci * 2);
                                const px = cx + Math.cos(ang) * dr;
                                const py = cy + Math.sin(ang) * dr * 0.4; // Perspective tilt
                                if (ang === 0) c.moveTo(px, py);
                                else c.lineTo(px, py);
                            }
                            c.closePath();
                            c.stroke();
                        });
                    }
                    c.globalAlpha = 1;
                },
                chaos: (c, w, h, t) => {
                    // Butterfly Effect Trails
                    c.strokeStyle = 'rgba(255,50,50,0.4)'; c.lineWidth = 1;
                    const cx = w / 2, cy = h * 0.5;
                    const scale = 20;
                    // Draw multiple Lorenz-like curves
                    for (let k = 0; k < 5; k++) {
                        let x = 0.1 + k, y = 0, z = 0; // Fake state
                        c.beginPath();
                        for (let i = 0; i < 100; i++) {
                            // Simple strange attractor math approx
                            const dx = Math.sin(t * 2 + i * 0.1 + k) * 100;
                            const dy = Math.cos(t * 1.5 + i * 0.1) * 80 * Math.sin(t * 0.5);
                            c.lineTo(cx + dx + Math.cos(k + t) * 200, cy + dy);
                        }
                        c.stroke();
                    }
                },
                wormhole: (c, w, h, t) => {
                    const cx = w / 2, cy = h * 0.5;
                    // Spiral Tunnel
                    for (let i = 0; i < 100; i++) {
                        const dist = 500 - (t * 200 + i * 30) % 500; // Moving IN
                        const scale = 500 / Math.max(1, dist);
                        const rot = t * 2 + dist * 0.01;

                        c.strokeStyle = `rgba(100,255,100,${dist / 500 * 0.5})`;
                        c.lineWidth = 2 * scale;

                        c.beginPath();
                        c.ellipse(cx, cy, 100 * scale, 100 * scale, rot, 0, 7);
                        c.stroke();
                    }
                },
                uncertainty: (c, w, h, t) => {
                    // Glitch Field
                    c.fillStyle = 'rgba(255,255,255,0.1)';
                    for (let i = 0; i < 50; i++) {
                        const wBox = Math.random() * w;
                        const hBox = Math.random() * 20;
                        const x = Math.random() * w;
                        const y = Math.random() * h;
                        if (Math.sin(t * 10 + y) > 0.5) {
                            c.fillRect(x, y, wBox, hBox);
                        }
                    }
                },
                wave_theory: (c, w, h, t) => {
                    // Universal Surface
                    c.strokeStyle = 'rgba(255,255,255,0.2)';
                    for (let i = 0; i < 50; i++) {
                        c.beginPath();
                        for (let x = 0; x <= w; x += 20) {
                            const y = h * 0.5 + Math.sin(x * 0.01 + t + i * 0.2) * 50 + (i - 25) * 10;
                            c.lineTo(x, y);
                        }
                        c.stroke();
                    }
                },
                arrow: (c, w, h, t) => {
                    c.fillStyle = 'rgba(255,80,0,0.6)';
                    // Flow from Order (Left) to Chaos (Right)
                    for (let i = 0; i < 800; i++) {
                        const x = (t * 200 + i * 5) % (w + 200) - 100;
                        const chaosFactor = Math.max(0, x / w); // 0 invar -> 1 chaos
                        const yBase = h * 0.5;
                        const spread = Math.pow(chaosFactor, 2) * h;
                        const y = yBase + (Math.sin(i) * spread / 2) + (Math.random() - 0.5) * spread;

                        const size = 2 * (1 - chaosFactor * 0.5);
                        c.globalAlpha = 1 - chaosFactor * 0.8;
                        c.fillRect(x, y, size, size);
                    }
                    c.globalAlpha = 1;
                },
                cosmic: (c, w, h, t) => {
                    c.strokeStyle = 'rgba(0,136,255,0.15)';
                    c.fillStyle = '#fff';
                    const cx = w / 2, cy = h * 0.5;
                    // Rotating Cosmic Web
                    for (let i = 0; i < 80; i++) {
                        const r = 200 + Math.sin(i) * 100;
                        const ang = i * 0.5 + t * 0.1;
                        const x = cx + Math.cos(ang) * r * Math.sin(t * 0.2 + i);
                        const y = cy + Math.sin(ang) * r;

                        // Connections
                        for (let j = 1; j < 3; j++) {
                            const r2 = 200 + Math.sin(i + j) * 100;
                            const ang2 = (i + j) * 0.5 + t * 0.1;
                            const x2 = cx + Math.cos(ang2) * r2 * Math.sin(t * 0.2 + i + j);
                            const y2 = cy + Math.sin(ang2) * r2;

                            const dist = Math.hypot(x - x2, y - y2);
                            if (dist < 150) {
                                c.lineWidth = (150 - dist) / 150;
                                c.beginPath(); c.moveTo(x, y); c.lineTo(x2, y2); c.stroke();
                            }
                        }
                    }
                },
                create_wave: (c, w, h, t) => {
                    // SEPARATION OF CONCERNS:
                    // 'c' is the 2D Context of the Top Canvas (Event Layer).
                    // We need to find and drive the Background WebGL Canvas.

                    const topCanvas = c.canvas;
                    if (!topCanvas.parentElement) return;

                    const glCanvas = topCanvas.parentElement.querySelector('canvas[id^="viz-webgl-"]');
                    if (!glCanvas) return;

                    // Initialize WebGL on the BACKGROUND canvas
                    if (!glCanvas.fiveInitialized) { // Unique key to avoid re-init
                        initCreateWaveWebGL(glCanvas);
                        glCanvas.fiveInitialized = true;
                    }

                    // Sync Dimensions
                    if (glCanvas.width !== w || glCanvas.height !== h) {
                        glCanvas.width = w;
                        glCanvas.height = h;
                    }

                    // Bridge Data: Get intensity from Top Canvas -> Send to Bottom Canvas
                    const intensity = parseFloat(topCanvas.dataset.intensity || 0);
                    if (glCanvas.waveUniforms) {
                        glCanvas.waveUniforms.uTime.value = t;
                        glCanvas.waveUniforms.uIntensity.value = intensity;
                    }

                    // Clear 2D Top Canvas (It just holds events + Totem drawn later)
                    // The Totem is drawn by the main loop after this function returns.
                }
            };
        }

        /**
         * WebGL Substrate for Haptic Interaction
         * Replaces the 2D ripple with a 3D deformed manifold
         */
        function initCreateWaveWebGL(canvas) {
            if (!window.THREE) return;
            canvas.threeInitialized = true;

            const w = canvas.width;
            const h = canvas.height;
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(w, h);
            renderer.setPixelRatio(window.devicePixelRatio);

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
            camera.position.set(0, 1.5, 3);
            camera.lookAt(0, 0, 0);

            // Substrate Geometry: A dense mesh for smooth deformation
            const geometry = new THREE.PlaneGeometry(4, 4, 128, 128);
            geometry.rotateX(-Math.PI / 2.5); // Perspective Tilt

            const uniforms = {
                uTime: { value: 0 },
                uIntensity: { value: 0 },
                uColor: { value: new THREE.Color(0xFFFFFF) }
            };
            canvas.waveUniforms = uniforms;

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                transparent: true,
                vertexShader: `
                    uniform float uTime;
                    uniform float uIntensity;
                    varying float vElevation;
                    varying vec2 vUv;

                    // Simple noise for shakiness
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }

                    void main() {
                        vUv = uv;
                        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
                        
                        // Distance from center for radial ripple
                        float dist = distance(uv, vec2(0.5));
                        
                        // Shaky Wave Logic: Periodic noise based on intensity
                        float shake = noise(uv + uTime) * uIntensity * 0.05;
                        
                        // Base wave (Subtle background noise)
                        float elevation = sin(modelPosition.x * 2.0 + uTime) * 0.02;
                        elevation += sin(modelPosition.z * 1.5 - uTime * 0.8) * 0.02;

                        // Haptic-Induced Ripple (Triggered by intensity)
                        if (uIntensity > 0.01) {
                            float ripple = sin((dist * 30.0) - (uTime * 10.0)) * 0.15;
                            ripple *= uIntensity;
                            ripple *= exp(-dist * 4.0); // Dampen away from center
                            elevation += ripple + shake; // Add shakiness here
                        }

                        modelPosition.y += elevation;
                        vElevation = elevation;

                        gl_Position = projectionMatrix * viewMatrix * modelPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    uniform float uIntensity;
                    varying float vElevation;
                    varying vec2 vUv;

                    void main() {
                        // Create a grid/wireframe texture dynamically
                        float grid = 0.0;
                        float freq = 60.0;
                        if (fract(vUv.x * freq) < 0.05 || fract(vUv.y * freq) < 0.05) grid = 0.5;

                        float dist = distance(vUv, vec2(0.5));
                        float alpha = (0.2 + grid) * (1.0 - dist * 1.5);
                        
                        // Glow based on elevation and intensity
                        vec3 finalColor = uColor;
                        if (uIntensity > 0.0) {
                            finalColor += vec3(0.1, 0.5, 1.0) * uIntensity * abs(vElevation) * 10.0;
                        }

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            function animate() {
                if (!canvas.parentElement) return; // Stop if removed
                requestAnimationFrame(animate);
                renderer.render(scene, camera);

                // Keep renderer size synced
                if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                }
            }
            animate();
        }
    </script>
</body>

</html>