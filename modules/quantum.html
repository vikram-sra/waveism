<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="../favicon.png">
    <link rel="apple-touch-icon" href="../icons/icon-180.png">
    <link rel="manifest" href="../manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Realm | Wave Manifolds</title>
    <style>
        html,
        body {
            background: #000 !important;
        }
    </style>
    <link rel="stylesheet" href="../components/shared.css">
    <script src="../components/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: transparent;
        }

        .theory-tab.quantum-tab {
            color: #00ffaa;
        }

        .theory-tab.quantum-tab.active {
            background: rgba(0, 255, 170, 0.1);
            color: #00ffaa;
            box-shadow: inset 0 0 15px rgba(0, 255, 170, 0.2);
        }





        .manifold-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.03;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 255, 170, 0.05) 1px, rgba(0, 255, 170, 0.05) 2px);
        }



        /* Mobile Cleanup */
        @media (max-width: 600px) {




            /* Info Panel needs to be above the tiny labels but not blocking view */
            .info-panel {
                bottom: 50px !important;
                width: 90% !important;
                padding-bottom: 20px;
            }

            .theory-name {
                font-size: 0.9rem;
            }

            .theory-year {
                display: none;
            }

            /* Hide year on tiny screens */
            .equation-box {
                padding: 5px 10px;
                margin-bottom: 5px;
            }

            .theory-facts {
                display: none;
            }

            /* Hide facts on tiny screens */
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="three-container"></div>

    <div class="manifold-glitch"></div>



    <div id="nav-container"></div>

    <div class="theory-nav-header">
        <div class="theory-nav-title">EXPLORE MODES</div>
        <div class="theory-nav-desc">Choose a simulation mode below to change the visualization</div>
    </div>
    <div class="theory-tabs">
        <button class="theory-tab quantum-tab active" data-theory="superposition">Superposition Art</button>
        <button class="theory-tab" data-theory="double-slit">Double Slit</button>
        <button class="theory-tab" data-theory="orbitals">Atomic Orbitals</button>
        <button class="theory-tab" data-theory="strings">String Manifolds</button>
        <button class="theory-tab" data-theory="crystal">Time Crystals</button>
        <button class="theory-tab" data-theory="gedanken">Schr√∂dinger's Cat</button>
        <button class="theory-tab" data-theory="tunneling">Tunneling</button>
        <button class="theory-tab" data-theory="entanglement">Entanglement</button>
        <button class="theory-tab" data-theory="teleportation">Teleportation</button>
        <button class="theory-tab" data-theory="zeno">Zeno Effect</button>
    </div>

    <div class="params-panel">
        <div class="param-group">
            <div class="param-label" id="param1-label">Energy Level (n)</div>
            <div class="param-value" id="param1-value">1</div>
            <input type="range" class="param-slider" id="param1-slider" min="1" max="10" value="1">
        </div>
        <div class="param-group">
            <div class="param-label">Decherence Rate</div>
            <div class="param-value" id="speed-value">1.0√ó</div>
            <input type="range" class="param-slider" id="speed-slider" min="0" max="300" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Quantum Zoom</div>
            <div class="param-value" id="zoom-value">1.0√ó</div>
            <input type="range" class="param-slider" id="zoom-slider" min="30" max="400" value="100">
        </div>
    </div>

    <div class="info-panel">
        <div class="theory-name" id="theory-name">Double-Slit Interference</div>
        <div class="theory-year" id="theory-year">The Wave-Particle Duality (1927)</div>
        <div class="equation-box">
            <div class="equation-label" id="equation-label">The Schr√∂dinger Equation</div>
            <div class="equation" id="equation">i‚Ñè ‚àÇ/‚àÇt œà = ƒ§œà</div>
        </div>
        <div class="theory-facts" id="theory-facts"></div>
    </div>

    <button class="info-btn" id="info-btn">‚ìò</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header">
            <span class="info-modal-title">Quantum Manifold Protocol</span>
            <button class="info-modal-close" id="info-close">√ó</button>
        </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Axiomatic Description</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Geometric Phase</div>
                <ul id="info-concepts"></ul>
            </div>
            <div class="info-section">
                <div class="info-section-title">Mathematical Backbone</div>
                <p id="info-equation-explanation"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Waveism Interconnect</div>
                <p id="info-physics"></p>
            </div>
        </div>
    </div>

    <script>
        // ============ CORE SETUP ============
        document.getElementById('nav-container').innerHTML = renderMainNav('quantum');

        let scene, camera, renderer, currentMode = 'double-slit';
        let activeGroup;
        let p1 = 1, timeScale = 1.0, time = 0;
        let smoothedZoom = 1.0;

        const theories = {
            'superposition': {
                name: 'Observer Paradox', year: 'Aesthetic Interpretation',
                equation: '|Œ®‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©',
                equationLabel: 'Superposition Principle',
                equationExpl: 'A state vector |Œ®‚ü© is a linear combination (superposition) of basis states. In this simulation, it represents the blending of two distinct visual forms.',
                facts: [{ text: 'Morphological', status: 'yes' }, { text: 'Interactive', status: 'yes' }],
                description: 'Visual metaphor for superposition. The object exists as both a localized entity (Face) and a distributed field (Landscape), choosing a form only upon interaction.',
                concepts: [
                    { term: 'Collapse', definition: 'The reduction of possibilities into a concrete reality upon measurement.' },
                    { term: 'Complementarity', definition: 'Duality of nature that cannot be observed simultaneously.' }
                ],
                physics: 'Waveism: Reality is a probability cloud that solidifies only when questioned.'
            },
            'double-slit': {
                name: 'Interference Patterns', year: 'Wave-Particle Duality',
                equation: 'I(Œ∏) = I‚ÇÄ cos¬≤(œÄd sin Œ∏ / Œª)',
                equationLabel: 'Interference Intensity',
                equationExpl: 'The intensity at angle Œ∏ depends on the path difference between waves from both slits. When Œ¥ = 2œÄd sin(Œ∏)/Œª is a multiple of 2œÄ, constructive interference occurs.',
                facts: [{ text: 'Superposition', status: 'yes' }, { text: 'Pattern Persistence', status: 'yes' }],
                description: 'The prototypical quantum test. Particles travel through two slits and interfere with themselves, creating a deterministic distribution pattern even if sent one at a time.',
                concepts: [
                    { term: 'Probability Amplitude', definition: 'A complex number (œà) whose squared magnitude gives probability.' },
                    { term: 'Fringe Spacing', definition: 'The distance between maxima, governed by wavelength and slit separation.' }
                ],
                physics: 'Waveism: Phase-coherence test. The substrate maintains parallel states until a decoherence event forces a reset.'
            },
            'orbitals': {
                name: 'Atomic Orbitals', year: 'Harmonic States',
                equation: 'ƒ§œà = Eœà',
                equationLabel: 'The Schr√∂dinger Equation',
                equationExpl: 'The time-independent Schr√∂dinger equation. The Hamiltonian operator H acts on the wavefunction œà to yield the possible energy levels E.',
                facts: [{ text: 'Stable States', status: 'yes' }, { text: 'Quantized energy', status: 'yes' }],
                description: 'Probability clouds of electron residence. These are standing-wave patterns (Spherical Harmonics) in the field around the nucleus.',
                concepts: [
                    { term: 'Nodal Planes', definition: 'Regions of zero probability where the wavefunction changes sign.' },
                    { term: 'Shell Stability', definition: 'The geometric arrangement defining all chemical properties.' }
                ],
                physics: 'Waveism: Orbitals are the harmonic resonances of the atomic substrate.'
            },
            'strings': {
                name: 'Superstring Manifolds', year: 'Harmonic Elements',
                equation: 'S = -T ‚à´ d¬≤œÉ ‚àö(-h)',
                equationLabel: 'Polyakov Action',
                equationExpl: 'The fundamental action describing the dynamics of a relativistic string moving through spacetime.',
                facts: [{ text: '10 Dimensions', status: 'yes' }, { text: 'Calabi-Yau', status: 'yes' }],
                description: 'Point-particles as vibrating strings. Different vibration modes correspond to electrons, photons, and gravitons.',
                concepts: [
                    { term: 'Calabi-Yau', definition: 'Extra dimensions curled into complex geometric manifolds.' },
                    { term: 'Planck Scale', definition: 'The distance (10‚Åª¬≥‚Åµm) where string effects dominate.' }
                ],
                physics: 'Waveism: The universe as a multi-dimensional interference pattern of a fundamental string.'
            },
            'crystal': {
                name: 'Time Crystals', year: 'Temporal Order',
                equation: '‚ü®œà(t+T)‚ü© = ‚ü®œà(t)‚ü©',
                equationLabel: 'Floquet Periodicity',
                equationExpl: 'Discrete time-translation symmetry. The state of the system returns to itself after a specific time period T, breaking continuous temporal symmetry.',
                facts: [{ text: 'Broken T-Symmetry', status: 'yes' }, { text: 'Non-equilibrium', status: 'yes' }],
                description: 'A phase of matter breaking time-translation symmetry. Pattern repetition occurs through time rather than space, even at lowest energy states.',
                concepts: [
                    { term: 'Floquet Protocol', definition: 'Periodic drive leading to stable non-equilibrium phases.' },
                    { term: 'Temporal Rigidity', definition: 'Resistance to noise, maintaining rhythmic oscillation.' }
                ],
                physics: 'Waveism: Time crystals prove time is a phase-dimension capable of crystallization.'
            },
            'gedanken': {
                name: "Schr√∂dinger's Cat", year: 'Measurement Problem',
                equation: '|Œ®‚ü© = 1/‚àö2 (|L‚ü© + |D‚ü©)',
                equationLabel: 'Entangled State',
                equationExpl: 'A maximally entangled state between a quantum trigger and a macroscopic object (cat). Illustrates the challenge of objective reality.',
                facts: [{ text: 'Macroscopic', status: 'yes' }, { text: 'Entangled', status: 'yes' }],
                description: 'Paradox illustrating interpretation limits. A cat is simultaneously alive and dead until the system is observed.',
                concepts: [
                    { term: 'Many Worlds', definition: 'Interpretation where all outcomes occur in branching manifolds.' },
                    { term: 'Decoherence', definition: 'Interaction with environment forcing state selection.' }
                ],
                physics: 'Waveism: Illustration of the measurement problem and state-selection.'
            },
            'tunneling': {
                name: 'Quantum Tunneling', year: 'Barrier Penetration',
                equation: 'T ‚âà e^{-2‚à´Œ∫(x)dx}',
                equationLabel: 'WKB Transmission',
                equationExpl: 'The transmission coefficient shows that a particle probability density decays exponentially but remains non-zero through a forbidden energy barrier.',
                facts: [{ text: 'Evanescent Wave', status: 'yes' }, { text: 'Barrier Leak', status: 'yes' }],
                description: 'Barrier penetration via wave mechanics. Classically impossible: the field permeates the barrier, re-establishing on the other side.',
                concepts: [
                    { term: 'Evanescence', definition: 'The exponential decay of the field within the forbidden zone.' },
                    { term: 'Alpha Decay', definition: 'The mechanism of nuclear particle escape via tunneling.' }
                ],
                physics: 'Waveism: Non-local resonance through classically forbidden regions.'
            },
            'entanglement': {
                name: 'Quantum Entanglement', year: 'EPR Paradox',
                equation: '|Œ®‚ü© = (|00‚ü© + |11‚ü©)/‚àö2',
                equationLabel: 'Bell State',
                equationExpl: 'Two particles are in a single, inseparable quantum state where measuring one instantly defines the state of the other.',
                facts: [{ text: 'Non-locality', status: 'yes' }, { text: 'Phase Lock', status: 'yes' }],
                description: 'Instantaneous correlation between distant particles. Einstein‚Äôs "Spooky Action"‚Äîthe state of one defines the state of the other globally.',
                concepts: [
                    { term: 'Bell State', definition: 'Maximally entangled quantum states.' },
                    { term: 'Non-locality', definition: 'Instantaneous synchronization across spatial separation.' }
                ],
                physics: 'Waveism: Space is not a separator but a medium; entangled points are phase-locked across the manifold.'
            },
            'teleportation': {
                name: 'Quantum Teleportation', year: 'Bennett Protocol',
                equation: '|œà‚ü©‚Çê|Œ¶‚Å∫‚ü©·µ¶ÍúÄ ‚Üí |œà‚ü©ÍúÄ',
                equationLabel: 'Bennett Protocol',
                equationExpl: 'Through Bell measurement and classical communication, an unknown quantum state is transferred from Alice to Bob via shared entanglement, without the state traversing the intervening space.',
                facts: [{ text: 'State Transfer', status: 'yes' }, { text: 'No Cloning', status: 'yes' }],
                description: 'Transfer of quantum states via entanglement. The original state is destroyed (No-Cloning), re-appearing at the destination through classic-quantum bridging.',
                concepts: [
                    { term: 'Bell Measure', definition: 'Projecting qubits onto maximally entangled states.' },
                    { term: 'Qubit Geometry', definition: 'The informational footprint of matter in the field.' }
                ],
                physics: 'Waveism: Matter is local geometry. Replicating geometry elsewhere identicals the object.'
            },
            'zeno': {
                name: 'Quantum Zeno Effect', year: 'Turing Paradox',
                equation: 'P(t) ‚âà 1 - (t/œÑ_Z)¬≤',
                equationLabel: 'Survival Probability',
                equationExpl: 'For short times, the probability of remaining in the initial state decreases quadratically. Frequent measurements at intervals Œît << œÑ_Z prevent decay, "freezing" the quantum state.',
                facts: [{ text: 'Evolution Freeze', status: 'yes' }, { text: 'Watched Pot', status: 'yes' }],
                description: 'System arrest via frequent observation. Measuring the state repeatedly collapses it back to initial conditions, preventing transition.',
                concepts: [
                    { term: 'Unitary Drift', definition: 'The smooth change of a system over time.' },
                    { term: 'Measurement Bias', definition: 'The physical pressure exerted by the act of observation.' }
                ],
                physics: 'Waveism: Observation as an active force. Repeated collapse prevents the phase-shift of the substrate.'
            }
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('three-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x00ffaa, 2.5, 600);
            pointLight.position.set(100, 200, 50);
            scene.add(pointLight);
            const fillLight = new THREE.PointLight(0xffffff, 1, 600);
            fillLight.position.set(-100, 50, 150);
            scene.add(fillLight);

            setupGraphics();
            createStarField(scene); // Add global starfield

            initParamSlider('param1-slider', 'param1-value', {
                onChange: v => { p1 = v / 100; updateParamDisplay(); },
                formatter: v => v.toFixed(2)
            });
            initParamSlider('speed-slider', 'speed-value', {
                onChange: v => timeScale = v / 100,
                formatter: v => (v / 100).toFixed(1) + '√ó'
            });
            initParamSlider('zoom-slider', 'zoom-value', {
                onChange: v => { if (window.zoomControl) window.zoomControl.zoom = v / 100; },
                formatter: v => (v / 100).toFixed(1) + '√ó'
            });

            const drag = initDragRotation(renderer.domElement, {
                initialRotationX: 0.6,
                initialRotationY: -0.4
            });
            window.globalDrag = drag;
            const zoomControl = initZoomHandler(renderer.domElement, { initialZoom: 0.8 });
            window.zoomControl = zoomControl;

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (window.clickPrevented) { window.clickPrevented = false; return; }
                drag.autoRotate = !drag.autoRotate;
            });

            initTheoryTabs(mode => switchMode(mode));
            initInfoModal();
            switchMode('superposition');
            animate(drag, zoomControl);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupGraphics() { }

        function createEmojiSprite(emoji, size = 256) {
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.font = `${size * 0.75}px "Apple Color Emoji", "Segoe UI Emoji", serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, size / 2, size / 2 + size * 0.1);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            return new THREE.Sprite(mat);
        }

        function createLabel(text, color = "#ffffff") {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = color;
            ctx.font = 'bold 36px JetBrains Mono, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(40, 10, 1);
            return sprite;
        }

        function updateParamDisplay() {
            const valEl = document.getElementById('param1-value');
            const labelEl = document.getElementById('param1-label');

            if (currentMode === 'orbitals') {
                labelEl.innerText = "Energy Level (n)";
                valEl.innerText = p1;
            } else if (currentMode === 'strings') {
                labelEl.innerText = "Harmonic Mode";
                valEl.innerText = p1;
            } else if (currentMode === 'crystal') {
                labelEl.innerText = "Frequency";
                valEl.innerText = p1;
            } else if (currentMode === 'double-slit') {
                labelEl.innerText = "Wavelength (Œª)";
                valEl.innerText = (p1 * 10).toFixed(1);
            } else {
                labelEl.innerText = "Energy Level (n)";
                valEl.innerText = p1;
            }
        }

        function switchMode(mode) {
            currentMode = mode;
            scene.children.forEach(c => { if (c.type === "Group") scene.remove(c); });

            activeGroup = new THREE.Group();
            activeGroup.position.y = 2;

            if (mode === 'double-slit') {
                // WAVE PLANE: High-res for interference
                const geo = new THREE.PlaneGeometry(240, 400, 120, 200);
                const mat = new THREE.MeshPhongMaterial({
                    color: 0x00ffaa,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                });
                const plane = new THREE.Mesh(geo, mat);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -20;
                plane.name = "wave_plane";
                activeGroup.add(plane);

                // WALL WITH SLITS
                const wallGroup = new THREE.Group();
                const wallMat = new THREE.MeshPhongMaterial({ color: 0x111111, side: THREE.DoubleSide });
                const w1 = new THREE.Mesh(new THREE.BoxGeometry(100, 60, 4), wallMat); w1.position.x = -65;
                const w2 = new THREE.Mesh(new THREE.BoxGeometry(20, 60, 4), wallMat); w2.position.x = 0;
                const w3 = new THREE.Mesh(new THREE.BoxGeometry(100, 60, 4), wallMat); w3.position.x = 65;
                wallGroup.add(w1, w2, w3);
                wallGroup.position.z = -80;
                wallGroup.position.y = 10;
                activeGroup.add(wallGroup);

                // DETECTION SCREEN
                const screen = new THREE.Mesh(
                    new THREE.PlaneGeometry(240, 60),
                    new THREE.MeshBasicMaterial({ color: 0x000505, side: THREE.DoubleSide })
                );
                screen.position.set(0, 10, 150);
                activeGroup.add(screen);

                // INTENSITY GRAPH (Probability Distribution)
                const intGeo = new THREE.PlaneGeometry(240, 60, 200, 1);
                const intMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffaa,
                    wireframe: true,
                    opacity: 0.8,
                    transparent: true
                });
                const intensity = new THREE.Mesh(intGeo, intMat);
                intensity.position.set(0, 10, 149);
                intensity.name = "intensity_graph";
                activeGroup.add(intensity);

                // PHOTONS
                const pCount = 100;
                const pPos = new Float32Array(pCount * 3);
                const pVel = new Float32Array(pCount); // Stores velocity/lifetime
                for (let i = 0; i < pCount; i++) {
                    pPos[i * 3] = (Math.random() - 0.5) * 40;
                    pPos[i * 3 + 1] = 10 + (Math.random() - 0.5) * 10;
                    pPos[i * 3 + 2] = -200 - Math.random() * 200;
                }
                const pGeo = new THREE.BufferGeometry();
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const parts = new THREE.Points(pGeo, new THREE.PointsMaterial({
                    color: 0x00ffaa,
                    size: 2,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8
                }));
                parts.name = "photons";
                activeGroup.add(parts);

                activeGroup.add(createLabel("INTERFERENCE TEST", "#00ffaa").translateY(50).translateZ(-80));
            }
            else if (mode === 'superposition') {
                // SUPERPOSITION ART: Face vs Landscape
                const pCount = 8000;
                const pPos = new Float32Array(pCount * 3);

                // Initialize as Sphere (Face approximation)
                for (let i = 0; i < pCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / pCount);
                    const theta = Math.sqrt(pCount * Math.PI) * phi;

                    // Sphere Coords
                    const sx = 60 * Math.cos(theta) * Math.sin(phi);
                    const sy = 60 * Math.sin(theta) * Math.sin(phi);
                    const sz = 60 * Math.cos(phi);

                    pPos[i * 3] = sx;
                    pPos[i * 3 + 1] = sy;
                    pPos[i * 3 + 2] = sz;
                }

                const pGeo = new THREE.BufferGeometry();
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const material = new THREE.PointsMaterial({ size: 1.5, color: 0x00ffaa, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
                const points = new THREE.Points(pGeo, material);
                points.name = "morph_points";

                // Store target states in userData
                const landscapeTargets = new Float32Array(pCount * 3);
                for (let i = 0; i < pCount; i++) {
                    // Grid Plane
                    const ix = (i % 80);
                    const iz = Math.floor(i / 80);
                    landscapeTargets[i * 3] = (ix - 40) * 4; // x
                    landscapeTargets[i * 3 + 1] = -50 + Math.random() * 5; // y (flat-ish)
                    landscapeTargets[i * 3 + 2] = (iz - 50) * 4; // z
                }
                points.userData = { landscape: landscapeTargets };

                activeGroup.add(points);
                activeGroup.add(createLabel("OBSERVE ME", "#00ffaa").translateY(80));
            }
            else if (mode === 'orbitals') {
                const pCount = 5000;
                const pPos = new Float32Array(pCount * 3);
                for (let i = 0; i < pCount; i++) {
                    const x = Math.random() * 2 - 1; const y = Math.random() * 2 - 1; const z = Math.random() * 2 - 1;
                    const r = Math.sqrt(x * x + y * y + z * z);
                    pPos[i * 3] = x * 50 / r; pPos[i * 3 + 1] = y * 50 / r; pPos[i * 3 + 2] = z * 50 / r;
                }
                const pGeo = new THREE.BufferGeometry();
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const cloud = new THREE.Points(pGeo, new THREE.PointsMaterial({ size: 1.5, color: 0x00ffaa, transparent: true, opacity: 0.6 }));
                cloud.name = "orbital_cloud";
                activeGroup.add(cloud);
            }
            else if (mode === 'strings') {
                for (let i = 0; i < 10; i++) {
                    const curve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(-50, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20),
                        new THREE.Vector3(0, (Math.random() - 0.5) * 40, (Math.random() - 0.5) * 40),
                        new THREE.Vector3(50, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20)
                    ]);
                    const string = new THREE.Mesh(new THREE.TubeGeometry(curve, 64, 0.5, 8, false), new THREE.MeshPhongMaterial({ color: 0x00ffaa }));
                    string.position.y = (i - 5) * 10;
                    string.userData.baseY = string.position.y;
                    activeGroup.add(string);
                }
            }
            else if (mode === 'crystal') {
                const geo = new THREE.IcosahedronGeometry(5, 0);
                const mat = new THREE.MeshPhongMaterial({ color: 0x00ffaa });
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        const m = new THREE.Mesh(geo, mat);
                        m.position.set((i - 3) * 25, 0, (j - 3) * 25);
                        m.userData.phaseOffset = (i + j) * 0.5;
                        activeGroup.add(m);
                    }
                }
            }
            else if (mode === 'gedanken') {
                const box = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 50), new THREE.MeshBasicMaterial({ color: 0x00ffaa, wireframe: true, transparent: true, opacity: 0.3 }));
                box.name = "containment";
                activeGroup.add(box);

                const alive = createEmojiSprite("üò∫", 256);
                alive.name = "cat_alive";
                alive.scale.set(30, 30, 1);
                activeGroup.add(alive);

                const dead = createEmojiSprite("‚ò†Ô∏è", 256);
                dead.name = "cat_dead";
                dead.scale.set(30, 30, 1);
                dead.visible = false;
                activeGroup.add(dead);

                const label = createLabel("|Œ®‚ü© = (|üò∫‚ü© + |‚ò†Ô∏è‚ü©)/‚àö2", "#00ffaa");
                label.position.set(0, 45, 0);
                activeGroup.add(label);
            }
            else if (mode === 'tunneling') {
                const barrier = new THREE.Mesh(new THREE.BoxGeometry(10, 60, 60), new THREE.MeshPhongMaterial({ color: 0xff0055, transparent: true, opacity: 0.5 }));
                barrier.name = "barrier";
                activeGroup.add(barrier);

                const pCount = 1000;
                const pPos = new Float32Array(pCount * 3);
                const pCol = new Float32Array(pCount * 3);
                for (let i = 0; i < pCount; i++) {
                    pPos[i * 3] = -100 + Math.random() * 150;
                    pPos[i * 3 + 1] = (Math.random() - 0.5) * 40;
                    pPos[i * 3 + 2] = (Math.random() - 0.5) * 40;
                    pCol[i * 3] = 0; pCol[i * 3 + 1] = 1; pCol[i * 3 + 2] = 1;
                }
                const pGeo = new THREE.BufferGeometry();
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                pGeo.setAttribute('color', new THREE.BufferAttribute(pCol, 3));
                const parts = new THREE.Points(pGeo, new THREE.PointsMaterial({ size: 1.5, vertexColors: true }));
                parts.name = "tunnel_particles";
                activeGroup.add(parts);

                const label = createLabel("Tunneling", "#ff0055");
                label.position.set(0, 50, 0);
                activeGroup.add(label);
            }
            else if (mode === 'entanglement') {
                const sGeo = new THREE.SphereGeometry(15, 32, 32);
                const sMat = new THREE.MeshPhongMaterial({ color: 0x00aaff });
                const A = new THREE.Mesh(sGeo, sMat); A.position.x = -60; A.name = "ent_A";
                const B = new THREE.Mesh(sGeo, sMat); B.position.x = 60; B.name = "ent_B";
                const line = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 120), new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true }));
                line.rotation.z = Math.PI / 2;
                line.name = "ent_bond";
                activeGroup.add(A, B, line);
                const label = createLabel("Entangled Pair", "#00aaff");
                label.position.set(0, 50, 0);
                activeGroup.add(label);
            }
            else if (mode === 'teleportation') {
                const ring = new THREE.TorusGeometry(20, 1, 16, 50);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
                const s1 = new THREE.Mesh(ring, mat); s1.position.x = -80;
                const s2 = new THREE.Mesh(ring, mat); s2.position.x = 80;
                activeGroup.add(s1, s2);

                const payload = new THREE.Mesh(new THREE.IcosahedronGeometry(8), new THREE.MeshPhongMaterial({ color: 0xffff00 }));
                payload.position.x = -80;
                payload.name = "tele_payload";
                activeGroup.add(payload);

                const label = createLabel("Teleportation", "#ff00ff");
                label.position.set(0, 50, 0);
                activeGroup.add(label);
            }
            else if (mode === 'zeno') {
                const atom = new THREE.Mesh(new THREE.SphereGeometry(20), new THREE.MeshPhongMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 }));
                atom.name = "zeno_atom";
                activeGroup.add(atom);

                const eye = createEmojiSprite("üëÅÔ∏è", 128);
                eye.position.set(0, 60, 0);
                eye.scale.set(40, 40, 1);
                eye.name = "zeno_eye";
                activeGroup.add(eye);

                const label = createLabel("Zeno Effect", "#ffffff");
                label.position.set(0, -50, 0);
                activeGroup.add(label);
            }

            scene.add(activeGroup);
            updateTheoryHeader(theories[mode].name, theories[mode].description);
            updateInfoPanel(theories[mode]);

            // Update Equation Label
            const eqnLabel = document.getElementById('equation-label');
            if (eqnLabel) {
                eqnLabel.innerText = theories[mode].equationLabel || "The Schr√∂dinger Equation";
            }

            updateInfoModalContent(theories[mode]);
            updateParamDisplay();
        }

        function updateSim() {
            const dt = 0.01 * timeScale;
            time += dt;

            if (currentMode === 'double-slit') {
                const plane = activeGroup.getObjectByName("wave_plane");
                const slitDist = 30; // 15 each side
                const wavelength = p1 * 10 + 2;

                if (plane) {
                    const pos = plane.geometry.attributes.position;
                    for (let i = 0; i < pos.count; i++) {
                        const px = pos.getX(i);
                        const pz = pos.getY(i); // Local Y is world -Z

                        // Plane ranges from Y: -200 to 200 (World Z: -200 to 200)
                        // Slit wall at World Z: -80 (Local Y: 80)
                        const worldZ = -pz;

                        if (worldZ < -80) {
                            // Single source wave before slits
                            const d = Math.sqrt(px ** 2 + (worldZ + 180) ** 2);
                            pos.setZ(i, Math.sin(2 * Math.PI * (d / wavelength) - time * 10) * 4);
                        } else {
                            // Two sources from slits
                            const d1 = Math.sqrt((px - slitDist / 2) ** 2 + (worldZ + 80) ** 2);
                            const d2 = Math.sqrt((px + slitDist / 2) ** 2 + (worldZ + 80) ** 2);
                            const w1 = Math.sin(2 * Math.PI * (d1 / wavelength) - time * 10);
                            const w2 = Math.sin(2 * Math.PI * (d2 / wavelength) - time * 10);
                            pos.setZ(i, (w1 + w2) * 2);
                        }
                    }
                    pos.needsUpdate = true;
                }

                // Update Intensity Graph on Screen
                const intensity = activeGroup.getObjectByName("intensity_graph");
                if (intensity) {
                    const pos = intensity.geometry.attributes.position;
                    const screenZ = 150;
                    const wallZ = -80;
                    const L = screenZ - wallZ;
                    for (let i = 0; i < pos.count; i++) {
                        const px = pos.getX(i);
                        const theta = Math.atan(px / L);
                        // Interference intensity formula: I = 4 * I0 * cos^2(delta/2)
                        // delta = 2pi/lambda * d * sin(theta)
                        const delta = (2 * Math.PI / wavelength) * slitDist * Math.sin(theta);
                        const val = Math.pow(Math.cos(delta / 2), 2);
                        pos.setY(i, val * 30); // Local Y of vertical graph
                    }
                    pos.needsUpdate = true;
                }

                const parts = activeGroup.getObjectByName("photons");
                if (parts) {
                    const pos = parts.geometry.attributes.position;
                    const screenZ = 150;
                    const wallZ = -80;
                    const L = screenZ - wallZ;

                    for (let i = 0; i < pos.count; i++) {
                        let x = pos.getX(i);
                        let y = pos.getY(i);
                        let z = pos.getZ(i);

                        z += 4 * timeScale;

                        if (z > screenZ) {
                            // Reset to start
                            z = -200 - Math.random() * 100;
                            x = (Math.random() - 0.5) * 40;
                            y = 10 + (Math.random() - 0.5) * 10;
                        } else if (z > wallZ && z < wallZ + 5) {
                            // Probability-based slit choice or bounce
                            // For simplicity, we snap them to slits if they are close
                            if (Math.abs(x - slitDist / 2) < 5 || Math.abs(x + slitDist / 2) < 5) {
                                // Pass through
                            } else {
                                // Reflect or block (reset)
                                z = -200 - Math.random() * 100;
                            }
                        } else if (z > wallZ + 5) {
                            // Move according to interference distribution?
                            // Accurate way: pick a target X based on distribution when passing slit
                            // Simple way: keep straight or slightly spread
                        }

                        pos.setX(i, x);
                        pos.setY(i, y);
                        pos.setZ(i, z);
                    }
                    pos.needsUpdate = true;
                }
            } else if (currentMode === 'superposition') {
                const points = activeGroup.getObjectByName("morph_points");
                if (points) {
                    const pos = points.geometry.attributes.position;
                    const landscape = points.userData.landscape;
                    const isObserved = window.globalDrag ? window.globalDrag.isDragging : false;

                    // Collapse State: 0 (Landscape/Unobserved) -> 1 (Face/Observed)
                    // Logic: If Observed (Dragging), morph to Face (Sphere). If Idle, morph to Landscape.
                    // Wait, user said "Two things at once UNTIL observed". So default should be a confusing mix, 
                    // and clicking snaps it to ONE.

                    const targetState = isObserved ? 1 : 0; // 1 = Sphere, 0 = Landscape
                    // Smooth transition
                    if (!points.userData.morphFactor) points.userData.morphFactor = 0;
                    points.userData.morphFactor += (targetState - points.userData.morphFactor) * 0.05;

                    const t = points.userData.morphFactor;

                    for (let i = 0; i < pos.count; i++) {
                        const phi = Math.acos(-1 + (2 * i) / pos.count);
                        const theta = Math.sqrt(pos.count * Math.PI) * phi;

                        // Re-calculate Sphere (Face) target on fly or store it?
                        // Let's calc on fly for memory save, it's cheap.
                        const sx = 60 * Math.cos(theta) * Math.sin(phi);
                        const sy = 60 * Math.sin(theta) * Math.sin(phi);
                        const sz = 60 * Math.cos(phi);

                        // Landscape Target
                        const lx = landscape[i * 3];
                        const ly = landscape[i * 3 + 1] + Math.sin(lx * 0.1 + time) * 5; // Wave the landscape
                        const lz = landscape[i * 3 + 2];

                        // Superposition Mix
                        // When t=0.5 (halfway), it's a mess. 

                        pos.setX(i, sx * t + lx * (1 - t));
                        pos.setY(i, sy * t + ly * (1 - t));
                        pos.setZ(i, sz * t + lz * (1 - t));
                    }
                    pos.needsUpdate = true;
                    points.rotation.y += 0.002;
                }
            } else if (currentMode === 'orbitals') {
                const cloud = activeGroup.getObjectByName("orbital_cloud");
                if (cloud) {
                    const pos = cloud.geometry.attributes.position;
                    const n = parseInt(p1);
                    for (let i = 0; i < pos.count; i++) {
                        const x = pos.getX(i); const y = pos.getY(i); const z = pos.getZ(i);
                        const r = Math.sqrt(x * x + y * y + z * z);
                        const s = 1 + Math.sin(time * 2 + r * 0.1) * 0.02 * n;
                        // Just subtle pulse
                    }
                    cloud.rotation.y += dt * 0.1;
                }
            } else if (currentMode === 'strings') {
                activeGroup.children.forEach((s, idx) => {
                    if (s.type === "Mesh") {
                        s.rotation.x += dt * (idx + 1) * 0.2;
                        s.position.y = s.userData.baseY + Math.sin(time * 5 + idx) * 2;
                    }
                });
            } else if (currentMode === 'crystal') {
                activeGroup.children.forEach(m => {
                    const phase = time * (p1 / 2) + m.userData.phaseOffset;
                    const scale = 1 + Math.sin(phase) * 0.5;
                    m.scale.setScalar(scale);
                    m.rotation.y += dt;
                });
            } else if (currentMode === 'gedanken') {
                const alive = activeGroup.getObjectByName('cat_alive');
                const dead = activeGroup.getObjectByName('cat_dead');
                const box = activeGroup.getObjectByName('containment');
                if (box) { box.rotation.y += dt; }
                if (alive && dead) {
                    const t = (Math.sin(time * 2) + 1) / 2;
                    alive.visible = true; dead.visible = true;
                    alive.material.opacity = t;
                    dead.material.opacity = 1 - t;
                }
            } else if (currentMode === 'tunneling') {
                const parts = activeGroup.getObjectByName('tunnel_particles');
                if (parts) {
                    const pos = parts.geometry.attributes.position.array;
                    const col = parts.geometry.attributes.color.array;
                    for (let i = 0; i < pos.length / 3; i++) {
                        let x = pos[i * 3];
                        x += 2 * timeScale;
                        if (x > 100) x = -100;
                        pos[i * 3] = x;
                        // Color logic (red in barrier)
                        if (x > -5 && x < 5) { col[i * 3] = 1; col[i * 3 + 1] = 0; col[i * 3 + 2] = 0; }
                        else { col[i * 3] = 0; col[i * 3 + 1] = 1; col[i * 3 + 2] = 1; }
                    }
                    parts.geometry.attributes.position.needsUpdate = true;
                    parts.geometry.attributes.color.needsUpdate = true;
                }
            } else if (currentMode === 'entanglement') {
                const A = activeGroup.getObjectByName('ent_A');
                const B = activeGroup.getObjectByName('ent_B');
                if (A && B) {
                    A.rotation.y += dt; B.rotation.y -= dt;
                    const cVal = (Math.sin(time * 3) + 1) / 2;
                    A.material.emissive.setHSL(0.6, 1, cVal * 0.5);
                    B.material.emissive.setHSL(0.6, 1, cVal * 0.5);
                }
            } else if (currentMode === 'teleportation') {
                const p = activeGroup.getObjectByName('tele_payload');
                if (p) {
                    const seq = time % 4;
                    if (seq < 1) { p.position.x = -80; p.visible = true; p.material.opacity = 1; }
                    else if (seq < 2) { p.material.opacity = 2 - seq; p.scale.setScalar(1 + (seq - 1) * 2); }
                    else if (seq < 3) { p.position.x = 80; p.material.opacity = seq - 2; p.scale.setScalar(3 - (seq - 2) * 2); }
                    else { p.position.x = 80; p.material.opacity = 1; p.scale.setScalar(1); }
                }
            } else if (currentMode === 'zeno') {
                const atom = activeGroup.getObjectByName('zeno_atom');
                const eye = activeGroup.getObjectByName('zeno_eye');
                const watching = (time % 1.5) < 0.2;
                if (eye) { eye.scale.setScalar(watching ? 40 : 30); eye.material.opacity = watching ? 1 : 0.3; }
                if (atom) {
                    if (watching) { atom.material.color.setHex(0x00ff00); atom.scale.setScalar(1); }
                    else {
                        const prog = ((time % 1.5) - 0.2) / 1.3;
                        atom.material.color.setHSL(0.3 - prog * 0.3, 1, 0.5);
                        atom.scale.setScalar(1 + prog * 0.5);
                    }
                }
            }
        }

        function animate(drag, zoomControl) {
            requestAnimationFrame(() => animate(drag, zoomControl));
            updateSim();

            const stars = scene.getObjectByName("global_starfield");
            updateStarField(stars, time, drag);

            const targetZoom = zoomControl.zoom;
            smoothedZoom += (targetZoom - smoothedZoom) * 0.1;
            camera.position.z = 350 / smoothedZoom;

            const zSlider = document.getElementById('zoom-slider');
            if (zSlider && !zSlider.matches(':active')) zSlider.value = smoothedZoom * 100;
            document.getElementById('zoom-value').innerText = smoothedZoom.toFixed(1) + '√ó';

            if (activeGroup) {
                drag.update();
                activeGroup.rotation.y = drag.rotationY;
                activeGroup.rotation.x = drag.rotationX;
            }

            renderer.render(scene, camera);
        }


        window.onload = function () {
            init();
        };
    </script>
</body>

</html>