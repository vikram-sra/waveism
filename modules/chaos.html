<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="../favicon.png">
    <link rel="apple-touch-icon" href="../icons/icon-180.png">
    <link rel="manifest" href="../manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Dynamics | The Strange Attractor Suite</title>
    <style>
        html,
        body {
            background: #000 !important;
        }
    </style>
    <link rel="stylesheet" href="../components/shared.css">
    <script src="../components/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: transparent;
        }

        .theory-tab.chaos-tab {
            color: #cc00ff;
        }

        .theory-tab.chaos-tab.active {
            background: rgba(204, 0, 255, 0.15);
            color: #cc00ff;
            box-shadow: inset 0 0 15px rgba(204, 0, 255, 0.2);
        }






        .manifold-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.02;
            background: repeating-linear-gradient(45deg, transparent, transparent 1px, #cc00ff 1px, #cc00ff 2px);
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="three-container"></div>

    <div class="manifold-glow"></div>



    <div id="nav-container"></div>

    <div class="theory-nav-header">
        <div class="theory-nav-title">EXPLORE MODES</div>
        <div class="theory-nav-desc">Choose a simulation mode below to change the visualization</div>
    </div>
    <div class="theory-tabs">
        <button class="theory-tab chaos-tab active" data-theory="sensitivity">Sensitivity</button>
        <button class="theory-tab" data-theory="lorenz">Lorenz Attractor</button>
        <button class="theory-tab" data-theory="three-body">Restricted 3-Body</button>
        <button class="theory-tab" data-theory="pendulum">Double Pendulum</button>
        <button class="theory-tab" data-theory="logistic">Logistic Bifurcation</button>
    </div>

    <div class="params-panel">
        <div class="param-group">
            <div class="param-label" id="param1-label">Sensitivity (δ)</div>
            <div class="param-value" id="param1-value">0.05</div>
            <input type="range" class="param-slider" id="param1-slider" min="1" max="100" value="5">
        </div>
        <div class="param-group">
            <div class="param-label">Simulation Speed</div>
            <div class="param-value" id="speed-value">1.0×</div>
            <input type="range" class="param-slider" id="speed-slider" min="0" max="300" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Phase Zoom</div>
            <div class="param-value" id="zoom-value">1.0×</div>
            <input type="range" class="param-slider" id="zoom-slider" min="30" max="400" value="100">
        </div>
    </div>

    <div class="info-panel">
        <div class="theory-name" id="theory-name">The Lorenz Butterfly</div>
        <div class="theory-year" id="theory-year">Deterministic Chaos (1963)</div>
        <div class="equation-box">
            <div class="equation-label">Attractor Topology</div>
            <div class="equation" id="equation">dx/dt = σ(y - x)</div>
        </div>
        <div class="theory-facts" id="theory-facts"></div>
    </div>

    <button class="info-btn" id="info-btn">ⓘ</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header">
            <span class="info-modal-title">Non-Linear Dynamics Protocol</span>
            <button class="info-modal-close" id="info-close">×</button>
        </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Axiomatic Description</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Structural Chaos</div>
                <ul id="info-concepts"></ul>
            </div>
            <div class="info-section">
                <div class="info-section-title">Mathematical Backbone</div>
                <p id="info-equation-explanation"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Waveism Interconnect</div>
                <p id="info-physics"></p>
            </div>
        </div>
    </div>

    <script>
        // ============ CORE SETUP ============
        document.getElementById('nav-container').innerHTML = renderMainNav('chaos');

        let scene, camera, renderer, currentMode = 'lorenz';
        let activeGroup;
        let p1 = 0.05, timeScale = 1.0, time = 0;
        let targetZoom = 1.0, smoothedZoom = 1.0;

        const theories = {
            'sensitivity': {
                name: 'Initial Sensitivity', year: 'Butterfly Effect',
                equation: 'δx(t) ≈ e^(λt)δx(0)',
                equationExpl: 'The Lyapunov divergence. It shows how initial errors grow exponentially in chaotic systems, making long-term prediction impossible.',
                facts: [{ text: 'Exponential Drift', status: 'yes' }, { text: 'Ordered Collapse', status: 'yes' }],
                description: 'A crystalline "Linear" system. Fundamentally unstable: a single perturbation introduces micro-errors that amplify exponentially into total entropy.',
                concepts: [
                    { term: 'Lyapunov Exponent', definition: 'The rate of trajectory divergence over time.' },
                    { term: 'Perturbation', definition: 'A slight deviation in the starting state.' }
                ],
                physics: 'Waveism: Reality is a balancing act. A single decoherent ripple can shatter the standing-wave manifold.'
            },
            'lorenz': {
                name: 'Strange Attractor', year: 'Edward Lorenz',
                equation: 'dx/dt = σ(y - x)',
                equationExpl: 'The Lorenz Attractor equations. They represent a simplified model of atmospheric convection, leading to the famous butterfly-shaped strange attractor.',
                facts: [{ text: 'Deterministic', status: 'yes' }, { text: 'Non-Periodic', status: 'yes' }],
                description: 'Deterministic unpredictability. The Attractor is a fractal manifold trapping trajectories in an infinite loop.',
                concepts: [
                    { term: 'Butterfly Effect', definition: 'Infinitesimal perturbations cause macroscopic divergence.' },
                    { term: 'Fractal Dimension', definition: 'The non-integer geometry of chaotic sets.' }
                ],
                physics: 'Waveism: Chaos is the emergent interference of high-frequency wave-packet collisions.'
            },
            'three-body': {
                name: '3-Body Problem', year: 'Orbital Chaos',
                equation: '∇²Φ = -4πGρ',
                equationExpl: 'The Poisson equation for gravity. In the three-body problem, the overlapping potentials create non-linear motions that lead to chaotic orbits.',
                facts: [{ text: 'Non-Integrable', status: 'yes' }, { text: 'Unstable', status: 'yes' }],
                description: 'Unsolved astrodynamics. A 3rd body introduces non-linearities that lead to orbital ejection and system divergence.',
                concepts: [
                    { term: 'KAM Theory', definition: 'The physics of near-integrable stability.' },
                    { term: 'Symplectic Flow', definition: 'Energy-conserving paths in phase space.' }
                ],
                physics: 'Waveism: Gravitational bodies are resonant spikes whose worldlines tangle in the manifold.'
            },
            'pendulum': {
                name: 'Double Pendulum', year: 'Lagrangian Chaos',
                equation: 'L = T - V',
                equationExpl: 'The Lagrangian for mechanical systems. For a double pendulum, the coupling between the arms creates a high-dimensional phase space dominated by chaos.',
                facts: [{ text: 'Highly Unstable', status: 'yes' }, { text: 'Coupled Modes', status: 'yes' }],
                description: 'Mechanical unpredictability. Coupled weights form non-linear feedback loops, creating motion that defies intuition.',
                concepts: [
                    { term: 'Bifurcation', definition: 'The threshold where stable orbits split into chaos.' },
                    { term: 'Feedback Loops', definition: 'Energy transfer between coupled oscillatory modes.' }
                ],
                physics: 'Waveism: Mechanical manifestation of multi-modal wave interference.'
            },
            'logistic': {
                name: 'Logistic Map', year: 'Universal Chaos',
                equation: 'x_(n+1) = r x_n(1 - x_n)',
                equationExpl: 'The Logistic Map. This recursive relation exhibits the universal path to chaos through period-doubling bifurcations as the parameter (r) increases.',
                facts: [{ text: 'Feigenbaum δ', status: '4.669' }, { text: 'Universality', status: 'yes' }],
                description: 'Mathematical proof of universal chaos. The path to turbulence follows a precise "Period Doubling" geometric ratio in all systems.',
                concepts: [
                    { term: 'Feigenbaum Constant', definition: 'The universal ratio governing the onset of chaos.' },
                    { term: 'Self-Similarity', definition: 'Infinite nested copies of the system structure.' }
                ],
                physics: 'Waveism: Geometric template for entropy production in high-energy manifolds.'
            }
        };

        // ============ UTILITIES ============
        function createLabel(text, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64;
            ctx.font = 'Bold 24px JetBrains Mono';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.fillText(text, 128, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(20, 5, 1);
            return sprite;
        }

        // INTEGRATORS
        const LorenzDynamics = (p, dt, σ = 10, ρ = 28, β = 8 / 3) => {
            const dx = σ * (p.y - p.x);
            const dy = p.x * (ρ - p.z) - p.y;
            const dz = p.x * p.y - β * p.z;
            return { x: dx, y: dy, z: dz };
        };

        const RK4_Lorenz = (p, dt) => {
            const k1 = LorenzDynamics(p, dt);
            const k2 = LorenzDynamics({ x: p.x + k1.x * dt / 2, y: p.y + k1.y * dt / 2, z: p.z + k1.z * dt / 2 }, dt);
            const k3 = LorenzDynamics({ x: p.x + k2.x * dt / 2, y: p.y + k2.y * dt / 2, z: p.z + k2.z * dt / 2 }, dt);
            const k4 = LorenzDynamics({ x: p.x + k3.x * dt, y: p.y + k3.y * dt, z: p.z + k3.z * dt }, dt);

            p.x += (dt / 6) * (k1.x + 2 * k2.x + 2 * k3.x + k4.x);
            p.y += (dt / 6) * (k1.y + 2 * k2.y + 2 * k3.y + k4.y);
            p.z += (dt / 6) * (k1.z + 2 * k2.z + 2 * k3.z + k4.z);
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 50); // Centered camera

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('three-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x444444, 1.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xcc00ff, 2, 100);
            pointLight.position.set(20, 20, 20);
            scene.add(pointLight);

            setupGraphics();
            createStarField(scene); // Add 3D Starfield

            // Improved control state: Click to pause ROTATION, slider for SIMULATION
            const drag = initDragRotation(renderer.domElement, {
                initialRotationX: 0.2
            });
            window.globalDrag = drag;
            const zoomControl = initZoomHandler(renderer.domElement, { initialZoom: 1.0 });

            initParamSlider('param1-slider', 'param1-value', {
                onChange: v => { p1 = v / 100; resetChaos(); },
                formatter: v => v
            });
            initParamSlider('speed-slider', 'speed-value', {
                onChange: v => timeScale = v / 100,
                formatter: v => (v / 100).toFixed(1) + '×'
            });
            initParamSlider('zoom-slider', 'zoom-value', {
                onChange: v => { if (zoomControl) zoomControl.zoom = v / 100; },
                formatter: v => (v / 100).toFixed(1) + '×'
            });

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (window.clickPrevented) { window.clickPrevented = false; return; }
                drag.autoRotate = !drag.autoRotate;
            });

            initTheoryTabs(mode => switchMode(mode));
            initInfoModal();
            switchMode('sensitivity');
            animate(drag, zoomControl);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        let lorenzData = { pts: [], lines: [] };
        let bodies = [];
        let pendulumData = { a1: 0, a2: 0, v1: 0, v2: 0, trail: [] };

        function setupGraphics() {
            // LORENZ
            lorenzData.pts = [
                { x: 0.1, y: 0.1, z: 0.1, color: 0xcc00ff, trail: [] },
                { x: 0.1001, y: 0.1, z: 0.1, color: 0xffffff, trail: [] }
            ];
            const lGroup = new THREE.Group();
            lGroup.name = "lorenz_group";
            lorenzData.pts.forEach((p, i) => {
                const geo = new THREE.BufferGeometry();
                const mat = new THREE.LineBasicMaterial({ color: p.color, transparent: true, opacity: 0.5 });
                const line = new THREE.Line(geo, mat);
                lorenzData.lines.push(line);
                lGroup.add(line);
            });
            activeGroup = lGroup;

            // 3-BODY (Pre-render setup)
            initThreeBody();
        }

        function initThreeBody() {
            bodies = [
                { pos: new THREE.Vector3(15, 0, 0), vel: new THREE.Vector3(0, 4, 0), m: 10, color: 0xcc00ff, trail: [] },
                { pos: new THREE.Vector3(-15, 0, 0), vel: new THREE.Vector3(0, -4, 0), m: 10, color: 0xffffff, trail: [] },
                { pos: new THREE.Vector3(0, 15, 0), vel: new THREE.Vector3(-4, 0, 0), m: 1 + p1 * 5, color: 0x00ffff, trail: [] }
            ];
        }

        function resetChaos() {
            if (currentMode === 'lorenz') {
                lorenzData.pts[1].x = 0.1 + (p1 * 0.1);
                lorenzData.pts.forEach(p => p.trail = []);
            } else if (currentMode === 'three-body') {
                initThreeBody();
            } else if (currentMode === 'pendulum') {
                pendulumData = { a1: Math.PI / 2, a2: Math.PI / 2 + p1, v1: 0, v2: 0, trail: [] };
            }
        }

        function switchMode(mode) {
            currentMode = mode;
            scene.children.forEach(c => { if (c.type === "Group") scene.remove(c); });

            activeGroup = new THREE.Group();
            activeGroup.position.y = 2;
            resetChaos();

            if (mode === 'lorenz') {
                lorenzData.lines.forEach(l => activeGroup.add(l));
                document.getElementById('param1-label').innerText = "Initial δ";
            } else if (mode === 'three-body') {
                bodies.forEach(b => {
                    const sphere = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({ color: b.color }));
                    sphere.name = "body";
                    sphere.userData.b = b;
                    activeGroup.add(sphere);
                    const tGeo = new THREE.BufferGeometry();
                    const tMat = new THREE.LineBasicMaterial({ color: b.color, transparent: true, opacity: 0.5 });
                    const line = new THREE.Line(tGeo, tMat);
                    line.name = "trail";
                    activeGroup.add(line);
                });
                document.getElementById('param1-label').innerText = "3rd Body Mass";
            } else if (mode === 'pendulum') {
                const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 10), new THREE.MeshBasicMaterial({ color: 0xcc00ff }));
                arm1.name = "arm1";
                activeGroup.add(arm1);
                const arm2 = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 10), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                arm2.name = "arm2";
                activeGroup.add(arm2);
                const trailGeo = new THREE.BufferGeometry();
                const trailMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                const trailLine = new THREE.Line(trailGeo, trailMat);
                trailLine.name = "trail";
                activeGroup.add(trailLine);
                document.getElementById('param1-label').innerText = "Start Offset";
            } else if (mode === 'logistic') {
                const points = [];
                for (let r = 2.8; r < 4.0; r += 0.002) {
                    let x = 0.5;
                    for (let i = 0; i < 150; i++) x = r * x * (1 - x);
                    for (let i = 0; i < 60; i++) {
                        x = r * x * (1 - x);
                        points.push(new THREE.Vector3((r - 3.3) * 20, (x - 0.5) * 30, (Math.random() - 0.5) * 2));
                    }
                }
                const cloud = new THREE.Points(new THREE.BufferGeometry().setFromPoints(points), new THREE.PointsMaterial({ color: 0xcc00ff, size: 0.08, transparent: true, opacity: 0.4 }));
                activeGroup.add(cloud);
                document.getElementById('param1-label').innerText = "Grain Size";
            } else if (mode === 'sensitivity') {
                // THE BUTTERFLY EFFECT VISUALIZATION
                // A Sphere that explodes when rotated
                const geo = new THREE.IcosahedronGeometry(20, 4); // High detail
                const wireframe = new THREE.WireframeGeometry(geo);
                const line = new THREE.LineSegments(wireframe);
                line.material.depthTest = false;
                line.material.opacity = 0.5;
                line.material.transparent = true;
                line.material.color.setHex(0xcc00ff);
                line.name = "unstable_mesh";

                // Store original positions for reset or calculation
                line.userData.originalPos = line.geometry.attributes.position.array.slice();
                line.userData.chaosFactor = 0;

                activeGroup.add(line);

                const label = createLabel("TOUCH TO PERTURB", "#cc00ff");
                label.position.y = 30;
                activeGroup.add(label);

                document.getElementById('param1-label').innerText = "Fragility (λ)";
            }

            // Sync group rotation with current drag state to avoid snapping
            if (window.globalDrag) {
                activeGroup.rotation.y = window.globalDrag.rotationY;
                activeGroup.rotation.x = window.globalDrag.rotationX;
            }

            scene.add(activeGroup);
            updateTheoryHeader(theories[mode].name, theories[mode].description);
            updateInfoPanel(theories[mode]);
            updateInfoModalContent(theories[mode]);
            updateParamDisplay();
        }

        function updateParamDisplay() {
            const valEl = document.getElementById('param1-value');
            if (currentMode === 'lorenz') valEl.innerText = (p1 * 0.1).toFixed(4);
            else if (currentMode === 'three-body') valEl.innerText = (1 + p1 * 5).toFixed(2) + ' M';
            else if (currentMode === 'pendulum') valEl.innerText = (p1 * 180).toFixed(0) + '°';
            else if (currentMode === 'logistic') valEl.innerText = (p1 * 100).toFixed(0);
        }

        function updateSim(dt) {
            if (currentMode === 'lorenz') {
                lorenzData.pts.forEach((p, i) => {
                    RK4_Lorenz(p, dt * 2.5);
                    p.trail.push(new THREE.Vector3(p.x, p.y, p.z - 25));
                    if (p.trail.length > 1000) p.trail.shift();
                    lorenzData.lines[i].geometry.setFromPoints(p.trail);
                });
                const d = lorenzData.pts[0].trail[lorenzData.pts[0].trail.length - 1].distanceTo(lorenzData.pts[1].trail[lorenzData.pts[1].trail.length - 1]);
            } else if (currentMode === 'three-body') {
                const G = 100.0;
                for (let s = 0; s < 10; s++) {
                    const dts = dt / 10;
                    bodies.forEach(b1 => {
                        let force = new THREE.Vector3();
                        bodies.forEach(b2 => {
                            if (b1 === b2) return;
                            let dir = b2.pos.clone().sub(b1.pos);
                            let r3 = Math.pow(dir.lengthSq() + 0.1, 1.5);
                            force.add(dir.multiplyScalar(G * b1.m * b2.m / r3));
                        });
                        b1.vel.add(force.multiplyScalar(dts / b1.m));
                    });
                    bodies.forEach(b => {
                        b.pos.add(b.vel.clone().multiplyScalar(dts));
                        b.trail.push(b.pos.clone());
                        if (b.trail.length > 500) b.trail.shift();
                    });
                }
                let trailIdx = 0;
                activeGroup.children.forEach(c => {
                    if (c.name === "body") c.position.copy(c.userData.b.pos);
                    if (c.name === "trail") {
                        c.geometry.setFromPoints(bodies[trailIdx].trail);
                        trailIdx++;
                    }
                });
            } else if (currentMode === 'pendulum') {
                const g = 9.8, m1 = 1, m2 = 1, l1 = 10, l2 = 10;
                const h = dt * 10;
                const d2a1 = (-g * (2 * m1 + m2) * Math.sin(pendulumData.a1) - m2 * g * Math.sin(pendulumData.a1 - 2 * pendulumData.a2) - 2 * Math.sin(pendulumData.a1 - pendulumData.a2) * m2 * (pendulumData.v2 * pendulumData.v2 * l2 + pendulumData.v1 * pendulumData.v1 * l1 * Math.cos(pendulumData.a1 - pendulumData.a2))) / (l1 * (2 * m1 + m2 - m2 * Math.cos(2 * pendulumData.a1 - 2 * pendulumData.a2)));
                const d2a2 = (2 * Math.sin(pendulumData.a1 - pendulumData.a2) * (pendulumData.v1 * pendulumData.v1 * l1 * (m1 + m2) + g * (m1 + m2) * Math.cos(pendulumData.a1) + pendulumData.v2 * pendulumData.v2 * l2 * m2 * Math.cos(pendulumData.a1 - pendulumData.a2))) / (l2 * (2 * m1 + m2 - m2 * Math.cos(2 * pendulumData.a1 - 2 * pendulumData.a2)));

                pendulumData.v1 += d2a1 * h; pendulumData.v2 += d2a2 * h;
                pendulumData.a1 += pendulumData.v1 * h; pendulumData.a2 += pendulumData.v2 * h;

                const x1 = l1 * Math.sin(pendulumData.a1), y1 = -l1 * Math.cos(pendulumData.a1);
                const x2 = x1 + l2 * Math.sin(pendulumData.a2), y2 = y1 - l2 * Math.cos(pendulumData.a2);

                activeGroup.getObjectByName("arm1").position.set(x1 / 2, y1 / 2, 0);
                activeGroup.getObjectByName("arm1").rotation.z = -pendulumData.a1;
                activeGroup.getObjectByName("arm2").position.set(x1 + (x2 - x1) / 2, y1 + (y2 - y1) / 2, 0);
                activeGroup.getObjectByName("arm2").rotation.z = -pendulumData.a2;

                pendulumData.trail.push(new THREE.Vector3(x2, y2, 0));
                if (pendulumData.trail.length > 200) pendulumData.trail.shift();
                activeGroup.getObjectByName("trail").geometry.setFromPoints(pendulumData.trail);
                pendulumData.trail.push(new THREE.Vector3(x2, y2, 0));
                if (pendulumData.trail.length > 200) pendulumData.trail.shift();
                activeGroup.getObjectByName("trail").geometry.setFromPoints(pendulumData.trail);
            } else if (currentMode === 'sensitivity') {
                const mesh = activeGroup.getObjectByName("unstable_mesh");
                if (mesh) {
                    const isInteracting = window.globalDrag ? window.globalDrag.isDragging : false;

                    // If interacting, increase chaos. If not, slowly heal (or stay broken?)
                    // "Collapse into a different form" implies permanent or semi-permanent change.
                    // Let's make it explode then re-form slowly.

                    if (isInteracting) {
                        mesh.userData.chaosFactor += 0.05 * (p1 * 2); // p1 is fragility
                    } else {
                        mesh.userData.chaosFactor *= 0.98; // Heal slowly
                    }

                    const chaos = mesh.userData.chaosFactor;
                    const pos = mesh.geometry.attributes.position.array;
                    const orig = mesh.userData.originalPos;

                    for (let i = 0; i < pos.length; i += 3) {
                        // Per-vertex noise
                        const noiseX = Math.sin(time * 10 + i) * chaos * 5;
                        const noiseY = Math.cos(time * 15 + i) * chaos * 5;
                        const noiseZ = Math.sin(time * 20 + i) * chaos * 5;

                        pos[i] = orig[i] + noiseX;
                        pos[i + 1] = orig[i + 1] + noiseY;
                        pos[i + 2] = orig[i + 2] + noiseZ;
                    }
                    mesh.geometry.attributes.position.needsUpdate = true;

                    mesh.rotation.y += 0.002; // Slow drift
                }
            }
        }

        function animate(drag, zoomControl) {
            requestAnimationFrame(() => animate(drag, zoomControl));
            const dt = 0.01 * timeScale;
            time += dt;
            updateSim(dt);

            const stars = scene.getObjectByName("global_starfield");
            updateStarField(stars, time, drag);

            targetZoom = zoomControl.zoom;
            smoothedZoom += (targetZoom - smoothedZoom) * 0.1;
            camera.position.z = 50 / smoothedZoom;

            const zSlider = document.getElementById('zoom-slider');
            if (zSlider && !zSlider.matches(':active')) zSlider.value = smoothedZoom * 100;
            document.getElementById('zoom-value').innerText = smoothedZoom.toFixed(1) + '×';

            if (activeGroup) {
                drag.update();
                activeGroup.rotation.y = drag.rotationY;
                activeGroup.rotation.x = drag.rotationX;
            }

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>