<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="../favicon.png">
    <link rel="apple-touch-icon" href="../icons/icon-180.png">
    <link rel="manifest" href="../manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrow of Time | The Irreversibility Engine</title>
    <link rel="stylesheet" href="../components/shared.css">
    <script src="../components/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            background: transparent;
        }

        .theory-tab.entropy-tab {
            color: #ff5500;
        }

        .theory-tab.entropy-tab.active {
            background: rgba(255, 85, 0, 0.15);
            color: #ff5500;
            box-shadow: inset 0 0 15px rgba(255, 85, 0, 0.2);
        }

        .manifold-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.1;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255, 100, 0, 0.05) 1px, rgba(255, 100, 0, 0.05) 2px);
        }





        .manifold-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.05;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255, 100, 0, 0.05) 1px, rgba(255, 100, 0, 0.05) 2px);
        }
    </style>
</head>

<body>
    <div id="background-stars"></div>
    <div id="three-container"></div>

    <div class="manifold-glitch"></div>
    <div id="nav-container"></div>

    <div class="theory-nav-header">
        <div class="theory-nav-title">EXPLORE MODES</div>
        <div class="theory-nav-desc">Choose a simulation mode below to change the visualization</div>
    </div>
    <div class="theory-tabs">
        <button class="theory-tab entropy-tab active" data-theory="entropy">Entropy Flow</button>
        <button class="theory-tab" data-theory="block">Block Time</button>
        <button class="theory-tab" data-theory="demon">Maxwell's Demon</button>
        <button class="theory-tab" data-theory="subjective">The Specious Now</button>
    </div>

    <div class="params-panel">
        <div class="param-group">
            <div class="param-label" id="param1-label">System Agitation</div>
            <div class="param-value" id="param1-value">50%</div>
            <input type="range" class="param-slider" id="param1-slider" min="0" max="100" value="50">
        </div>
        <div class="param-group">
            <div class="param-label">Simulation Speed</div>
            <div class="param-value" id="speed-value">1.0×</div>
            <input type="range" class="param-slider" id="speed-slider" min="0" max="300" value="100">
        </div>
        <div class="param-group">
            <div class="param-label">Temporal Depth</div>
            <div class="param-value" id="zoom-value">1.0×</div>
            <input type="range" class="param-slider" id="zoom-slider" min="30" max="300" value="100">
        </div>
    </div>

    <div class="info-panel">
        <div class="theory-name" id="theory-name">Statistical Irreversibility</div>
        <div class="theory-year" id="theory-year">The Second Law of Thermodynamics</div>
        <div class="equation-box">
            <div class="equation-label">Boltzmann Formula</div>
            <div class="equation" id="equation">S = k_B ln Ω</div>
        </div>
        <div class="theory-facts" id="theory-facts"></div>
    </div>

    <button class="info-btn" id="info-btn">ⓘ</button>
    <div class="info-modal" id="info-modal">
        <div class="info-modal-header">
            <span class="info-modal-title">Entropy Ontology Protocol</span>
            <button class="info-modal-close" id="info-close">×</button>
        </div>
        <div class="info-modal-body">
            <div class="info-section">
                <div class="info-section-title">Axiomatic Description</div>
                <p id="info-description"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Phase Space Dynamics</div>
                <ul id="info-concepts"></ul>
            </div>
            <div class="info-section">
                <div class="info-section-title">Mathematical Backbone</div>
                <p id="info-equation-explanation"></p>
            </div>
            <div class="info-section">
                <div class="info-section-title">Deep Statistical Physics</div>
                <p id="info-physics"></p>
            </div>
        </div>
    </div>

    <script>
        // ============ CORE SETUP ============
        document.getElementById('nav-container').innerHTML = renderMainNav('arrow');

        let scene, camera, renderer, currentMode = 'entropy';
        let entropyParticles, demonGroup, blockGroup, subjectiveGroup;
        // Default Agitation 50%
        let p1 = 0.5, zoom = 1.0, time = 0, timeScale = 1.0;
        let targetZoom = 1.0, smoothedZoom = 1.0;

        const theories = {
            'entropy': {
                name: 'Entropy & The Arrow', year: 'Boltzmann / Clausius',
                equation: 'ΔS_univ ≥ 0',
                equationExpl: 'The Second Law of Thermodynamics. It states that the total entropy of an isolated system can never decrease over time, defining the thermodynamic arrow.',
                facts: [{ text: 'Increasing', status: 'yes' }, { text: 'Probabilistic', status: 'yes' }],
                description: 'The movement from low-entropy order to high-entropy disorder. Time\'s arrow is not a fundamental law, but a statistical inevitability. There are simply more ways for a system to be messy than organized.',
                concepts: [
                    { term: 'Microstates (Ω)', definition: 'The hidden configurations that result in a macrostate.' },
                    { term: 'Past Hypothesis', definition: 'The initial state was uniquely ordered (Low Entropy).' }
                ],
                physics: 'Entropy is the decoherence of wave-functions into statistical noise. In the context of Waveism, it is the drift from phase-coherence to destructive interference/randomness.'
            },
            'block': {
                name: 'Static Temporal Block', year: 'Minkowski Space',
                equation: 'M⁴ = {t, x, y, z}',
                equationExpl: 'The 4D Minkowski manifold. In the block universe, time is simply the fourth dimension, and the "past", "present", and "future" are all equally real and fixed.',
                facts: [{ text: 'Static', status: 'yes' }, { text: 'Eternal', status: 'yes' }],
                description: 'The 4D perspective where time is a spatial dimension. Every event that has happened or will happen exists simultaneously in the manifold. The "arrow" is a biological illusion of perspective.',
                concepts: [
                    { term: 'Simultaneity', definition: 'The "Now" is a slice determined by the observer\'s speed.' },
                    { term: 'Immutable Past', definition: 'The worldline is a fixed geometric object in the block.' }
                ],
                physics: 'The Block Universe satisfies the requirements of Relativity. The "flow" of time is a cognitive artifact, not a property of the geometric solution.'
            },
            'demon': {
                name: "Maxwell's Demon", year: 'Information Paradox',
                equation: 'ΔS_Total = 8πG - ☠️',
                equationExpl: 'A playful representation of the Maxwell\'s Demon paradox. It highlights that sorting molecules requires information processing, which generates its own entropy.',
                facts: [{ text: 'Information Cost', status: 'high' }, { text: 'Sorting Power', status: 'yes' }],
                description: 'A thought experiment where a demon sorts fast and slow molecules to reverse entropy. The paradox is resolved by Information Theory: the demon creates more entropy erasing its memory than it saves by sorting.',
                concepts: [
                    { term: 'Landauer Limit', definition: 'The energetic cost of erasing one bit of information.' },
                    { term: 'Entropy/Information', definition: 'Information is the negative of entropy (Negentropy).' }
                ],
                physics: 'The demon proves that knowing the state of a system (low entropy) requires the consumption of energy. Information is physical.'
            },
            'subjective': {
                name: 'The Specious Now', year: 'Biological Time',
                equation: 'T_subj = f(Metabolism)',
                equationExpl: 'A model of subjective time perception. It suggests that our internal sense of "duration" is a function of our biological and metabolic state.',
                facts: [{ text: 'Non-Linear', status: 'yes' }, { text: 'Metabolic', status: 'yes' }],
                description: 'Subjective time is determined by the rate of information processing. During moments of high intensity, your brain samples events at a higher frequency, making time appear to "slow down."',
                concepts: [
                    { term: 'Metabolic Clock', definition: 'Our internal oscillators are chemical and biological.' },
                    { term: 'Now-Buffer', definition: 'The short delay between experience and conscious perception.' }
                ],
                physics: 'The subjective arrow is the biological alignment with the thermodynamic arrow. We perceive the increase of entropy as the "passage" of time.'
            }
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8); // Centered

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('three-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const spotLight = new THREE.SpotLight(0xff5500, 2);
            spotLight.position.set(10, 10, 10);
            scene.add(spotLight);

            createStarField(scene); // Add global starfield

            setupGraphics();

            initParamSlider('param1-slider', 'param1-value', {
                onChange: v => { p1 = v / 100; updateParamDisplay(); },
                formatter: v => v
            });
            // Ensure UI matches p1=0.5
            document.getElementById('param1-slider').value = 50;

            initParamSlider('speed-slider', 'speed-value', {
                onChange: v => timeScale = v / 100,
                formatter: v => (v / 100).toFixed(1) + '×'
            });
            initParamSlider('zoom-slider', 'zoom-value', {
                onChange: v => { if (zoomControl) zoomControl.zoom = v / 100; },
                formatter: v => (v / 100).toFixed(1) + '×'
            });

            // Interactive Handlers
            const drag = initDragRotation(renderer.domElement, {
                autoRotate: false,
                initialRotationX: 0.3
            });
            window.globalDrag = drag;
            const zoomControl = initZoomHandler(renderer.domElement, { initialZoom: 1.0 });

            renderer.domElement.addEventListener('mouseup', (e) => {
                if (window.clickPrevented) { window.clickPrevented = false; return; }
                drag.autoRotate = !drag.autoRotate;
            });

            initTheoryTabs(mode => switchMode(mode));
            initInfoModal();
            switchMode('entropy');
            animate(drag, zoomControl);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updateParamDisplay() {
            const valEl = document.getElementById('param1-value');
            if (currentMode === 'entropy') valEl.innerText = (p1 * 100).toFixed(0) + '% Disorder';
            else if (currentMode === 'block') valEl.innerText = 'Slice: ' + (p1 * 100).toFixed(0);
            else if (currentMode === 'demon') valEl.innerText = 'Efficiency: ' + (p1 * 100).toFixed(0) + '%';
            else if (currentMode === 'subjective') valEl.innerText = 'Processing: ' + (p1 * 100).toFixed(0) + '%';
        }

        function setupGraphics() {
            // mode: ENTROPY
            entropyParticles = new THREE.Group();
            const count = 3000;
            const pGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3);
            const initialPos = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const ix = (Math.random() - 0.5) * 0.1;
                const iy = (Math.random() - 0.5) * 0.1;
                const iz = (Math.random() - 0.5) * 0.1;
                positions[i * 3] = ix; positions[i * 3 + 1] = iy; positions[i * 3 + 2] = iz;
                initialPos[i * 3] = ix; initialPos[i * 3 + 1] = iy; initialPos[i * 3 + 2] = iz;
                velocities[i * 3] = (Math.random() - 0.5) * 0.5;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const pMat = new THREE.PointsMaterial({ color: 0xff4400, size: 0.05, transparent: true, opacity: 0.6 });
            const points = new THREE.Points(pGeo, pMat);
            points.name = "particles";
            points.userData.initial = initialPos;
            points.userData.vel = velocities;
            entropyParticles.add(points);

            const cage = new THREE.Mesh(
                new THREE.BoxGeometry(6, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xff5500, wireframe: true, transparent: true, opacity: 0.1 })
            );
            entropyParticles.add(cage);

            // mode: BLOCK
            blockGroup = new THREE.Group();
            for (let i = 0; i < 10; i++) {
                const layer = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 4, 0.1),
                    new THREE.MeshPhongMaterial({ color: 0xff3300, transparent: true, opacity: 0.1, wireframe: true })
                );
                layer.position.z = (i - 5) * 0.5;
                blockGroup.add(layer);
            }
            const activeNow = new THREE.Mesh(
                new THREE.BoxGeometry(4, 4, 0.2),
                new THREE.MeshPhongMaterial({ color: 0xffaa00, transparent: true, opacity: 0.4 })
            );
            activeNow.name = "now";
            blockGroup.add(activeNow);

            // mode: DEMON
            demonGroup = new THREE.Group();
            const wall = new THREE.Mesh(new THREE.BoxGeometry(0.1, 4, 4), new THREE.MeshBasicMaterial({ color: 0xff5500, transparent: true, opacity: 0.2, wireframe: true }));
            demonGroup.add(wall);
            const door = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            door.name = "door";
            demonGroup.add(door);
            for (let i = 0; i < 100; i++) {
                const color = Math.random() > 0.5 ? 0xff0000 : 0x0000ff;
                const ball = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({ color }));
                ball.position.set((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4);
                demonGroup.add(ball);
            }

            // mode: SUBJECTIVE
            subjectiveGroup = new THREE.Group();
            subjectiveGroup.position.y = 0.5;
            const tunnelGeo = new THREE.TorusGeometry(3, 1, 16, 100);
            const tunnelMat = new THREE.MeshBasicMaterial({ color: 0xff5500, wireframe: true, transparent: true, opacity: 0.2 });
            const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
            tunnel.rotation.x = Math.PI / 2;
            subjectiveGroup.add(tunnel);
        }

        function switchMode(mode) {
            currentMode = mode;
            scene.children.forEach(c => { if (c.type === "Group") scene.remove(c); });

            let active;
            if (mode === 'entropy') active = entropyParticles;
            else if (mode === 'block') active = blockGroup;
            else if (mode === 'demon') active = demonGroup;
            else if (mode === 'subjective') active = subjectiveGroup;

            if (active) {
                active.position.y = 0.8;
                if (window.globalDrag) {
                    active.rotation.y = window.globalDrag.rotationY;
                    active.rotation.x = window.globalDrag.rotationX;
                }
                scene.add(active);
            }
            updateTheoryHeader(theories[mode].name, theories[mode].description);
            updateInfoPanel(theories[mode]);
            updateInfoModalContent(theories[mode]);
            updateParamDisplay();
        }

        function animate(drag, zoomControl) {
            requestAnimationFrame(() => animate(drag, zoomControl));
            time += 0.01 * timeScale;

            const stars = scene.getObjectByName("global_starfield");
            updateStarField(stars, time, drag);

            // Interaction State
            targetZoom = zoomControl.zoom;
            smoothedZoom += (targetZoom - smoothedZoom) * 0.1;
            camera.position.z = 8 / smoothedZoom;

            // Sync Slider
            const zSlider = document.getElementById('zoom-slider');
            if (zSlider && !zSlider.matches(':active')) zSlider.value = smoothedZoom * 100;
            document.getElementById('zoom-value').innerText = smoothedZoom.toFixed(1) + '×';

            const activeGroup = scene.children.find(c => c.type === "Group");

            if (activeGroup) {
                drag.update();
                activeGroup.rotation.y = drag.rotationY;
                activeGroup.rotation.x = drag.rotationX;

                if (currentMode === 'entropy') {
                    const points = activeGroup.getObjectByName("particles");
                    if (points) {
                        const pos = points.geometry.attributes.position.array;
                        const vel = points.userData.vel;
                        // Always moving slightly
                        const agitation = Math.max(0.1, p1 * 5);

                        for (let i = 0; i < pos.length; i += 3) {
                            // Chaotic Motion
                            pos[i] += vel[i] * agitation * 0.01;
                            pos[i + 1] += vel[i + 1] * agitation * 0.01;
                            pos[i + 2] += vel[i + 2] * agitation * 0.01;

                            // Time Flow Drift (Arrow)
                            pos[i] += 0.005 * timeScale; // Drift Right (Time)

                            // Bounce/Wrap
                            if (pos[i] > 3) pos[i] = -3; // Loop time
                            if (Math.abs(pos[i + 1]) > 3) vel[i + 1] *= -1;
                            if (Math.abs(pos[i + 2]) > 3) vel[i + 2] *= -1;
                        }
                        points.geometry.attributes.position.needsUpdate = true;
                    }
                } else if (currentMode === 'block') {
                    const now = activeGroup.getObjectByName("now");
                    if (now) now.position.z = (p1 - 0.5) * 5;
                } else if (currentMode === 'demon') {
                    const door = activeGroup.getObjectByName("door");
                    if (door) door.scale.y = Math.sin(time * 5) > 0 ? 0.1 : 1;
                    activeGroup.children.forEach(c => {
                        if (c.type === "Mesh" && c.name !== "door") {
                            c.position.x += (Math.random() - 0.5) * 0.05 * timeScale;
                        }
                    });
                } else if (currentMode === 'subjective') {
                    activeGroup.rotation.z += 0.01 * (1 + p1 * 5) * timeScale;
                }
            }

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>